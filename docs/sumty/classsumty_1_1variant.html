<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sumty: variant&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">sumty<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Better sum types for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classsumty_1_1variant.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classsumty_1_1variant-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">variant&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>General discriminated union.  
 <a href="classsumty_1_1variant.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="variant_8hpp_source.html">sumty/variant.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaff7515701528c079656b289d2e002ca" id="r_aaff7515701528c079656b289d2e002ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#aaff7515701528c079656b289d2e002ca">variant</a> () <a class="el" href="classsumty_1_1result.html">CONDITIONALLY_NOEXCEPT</a></td></tr>
<tr class="memdesc:aaff7515701528c079656b289d2e002ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:aaff7515701528c079656b289d2e002ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd70aa4985ff543492dd1d33f5790064" id="r_acd70aa4985ff543492dd1d33f5790064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#acd70aa4985ff543492dd1d33f5790064">variant</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1variant.html">variant</a> &amp;)</td></tr>
<tr class="memdesc:acd70aa4985ff543492dd1d33f5790064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:acd70aa4985ff543492dd1d33f5790064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c32b34499275a35b567b7989b79eb7" id="r_a13c32b34499275a35b567b7989b79eb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a13c32b34499275a35b567b7989b79eb7">variant</a> (<a class="el" href="classsumty_1_1variant.html">variant</a> &amp;&amp;)</td></tr>
<tr class="memdesc:a13c32b34499275a35b567b7989b79eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:a13c32b34499275a35b567b7989b79eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110b0144688c0ec68334267e06e47942" id="r_a110b0144688c0ec68334267e06e47942"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> IDX, typename... Args&gt; </td></tr>
<tr class="memitem:a110b0144688c0ec68334267e06e47942"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a110b0144688c0ec68334267e06e47942">variant</a> (std::in_place_index_t&lt; <a class="el" href="classsumty_1_1result.html">IDX</a> &gt; <a class="el" href="classsumty_1_1result.html">inplace</a>, <a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;... <a class="el" href="classsumty_1_1result.html">args</a>)</td></tr>
<tr class="memdesc:a110b0144688c0ec68334267e06e47942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index emplacement constructor.  <br /></td></tr>
<tr class="separator:a110b0144688c0ec68334267e06e47942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85be3479b6c3fac697ce535ca16c53cf" id="r_a85be3479b6c3fac697ce535ca16c53cf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> IDX, <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </td></tr>
<tr class="memitem:a85be3479b6c3fac697ce535ca16c53cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a85be3479b6c3fac697ce535ca16c53cf">variant</a> (std::in_place_index_t&lt; <a class="el" href="classsumty_1_1result.html">IDX</a> &gt; <a class="el" href="classsumty_1_1result.html">inplace</a>, std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; <a class="el" href="classsumty_1_1result.html">init</a>, <a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;... <a class="el" href="classsumty_1_1result.html">args</a>)</td></tr>
<tr class="memdesc:a85be3479b6c3fac697ce535ca16c53cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index emplacement constructor with <code>std::initializer_list</code>  <br /></td></tr>
<tr class="separator:a85be3479b6c3fac697ce535ca16c53cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ba6a427080fa9ba989e750e3e3ef83" id="r_ab1ba6a427080fa9ba989e750e3e3ef83"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </td></tr>
<tr class="memitem:ab1ba6a427080fa9ba989e750e3e3ef83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#ab1ba6a427080fa9ba989e750e3e3ef83">variant</a> (std::in_place_type_t&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; <a class="el" href="classsumty_1_1result.html">inplace</a>, <a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;... <a class="el" href="classsumty_1_1result.html">args</a>)</td></tr>
<tr class="memdesc:ab1ba6a427080fa9ba989e750e3e3ef83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type emplacement constructor.  <br /></td></tr>
<tr class="separator:ab1ba6a427080fa9ba989e750e3e3ef83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf6dd2547652a573fca2414801db408" id="r_a2cf6dd2547652a573fca2414801db408"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> , typename... Args&gt; </td></tr>
<tr class="memitem:a2cf6dd2547652a573fca2414801db408"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a2cf6dd2547652a573fca2414801db408">variant</a> (std::in_place_type_t&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; <a class="el" href="classsumty_1_1result.html">inplace</a>, std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">V</a> &gt; <a class="el" href="classsumty_1_1result.html">init</a>, <a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;... <a class="el" href="classsumty_1_1result.html">args</a>)</td></tr>
<tr class="memdesc:a2cf6dd2547652a573fca2414801db408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type emplacement constructor with <code>std::initializer_list</code>  <br /></td></tr>
<tr class="separator:a2cf6dd2547652a573fca2414801db408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208fbd1bb90c81cfa04386b3b0413108" id="r_a208fbd1bb90c81cfa04386b3b0413108"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:a208fbd1bb90c81cfa04386b3b0413108"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a208fbd1bb90c81cfa04386b3b0413108">variant</a> (<a class="el" href="classsumty_1_1result.html">U</a> &amp;&amp;value)</td></tr>
<tr class="memdesc:a208fbd1bb90c81cfa04386b3b0413108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwarding constructor.  <br /></td></tr>
<tr class="separator:a208fbd1bb90c81cfa04386b3b0413108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9623720145e83ee0bbc52bc1a2b8bd" id="r_a7a9623720145e83ee0bbc52bc1a2b8bd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:a7a9623720145e83ee0bbc52bc1a2b8bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a7a9623720145e83ee0bbc52bc1a2b8bd">variant</a> (std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; <a class="el" href="classsumty_1_1result.html">init</a>)</td></tr>
<tr class="memdesc:a7a9623720145e83ee0bbc52bc1a2b8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwarding constructor with initializer list.  <br /></td></tr>
<tr class="separator:a7a9623720145e83ee0bbc52bc1a2b8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25170b8c12360697907375ef3473cb2e" id="r_a25170b8c12360697907375ef3473cb2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a25170b8c12360697907375ef3473cb2e">~variant</a> () <a class="el" href="classsumty_1_1result.html">CONDITIONALLY_NOEXCEPT</a></td></tr>
<tr class="memdesc:a25170b8c12360697907375ef3473cb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a25170b8c12360697907375ef3473cb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d754384322f67c2e60c186cade74c2" id="r_a42d754384322f67c2e60c186cade74c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1variant.html">variant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a42d754384322f67c2e60c186cade74c2">operator=</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1variant.html">variant</a> &amp;<a class="el" href="classsumty_1_1result.html">rhs</a>)</td></tr>
<tr class="memdesc:a42d754384322f67c2e60c186cade74c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <br /></td></tr>
<tr class="separator:a42d754384322f67c2e60c186cade74c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e42c25246108ccd1829706ca0b3e23" id="r_af1e42c25246108ccd1829706ca0b3e23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1variant.html">variant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#af1e42c25246108ccd1829706ca0b3e23">operator=</a> (<a class="el" href="classsumty_1_1variant.html">variant</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">rhs</a>)</td></tr>
<tr class="memdesc:af1e42c25246108ccd1829706ca0b3e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <br /></td></tr>
<tr class="separator:af1e42c25246108ccd1829706ca0b3e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783ed86ae62c0aacfdb49ecbfa78ad85" id="r_a783ed86ae62c0aacfdb49ecbfa78ad85"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:a783ed86ae62c0aacfdb49ecbfa78ad85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1variant.html">variant</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a783ed86ae62c0aacfdb49ecbfa78ad85">operator=</a> (<a class="el" href="classsumty_1_1result.html">U</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">rhs</a>)</td></tr>
<tr class="memdesc:a783ed86ae62c0aacfdb49ecbfa78ad85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwarding assignment operator.  <br /></td></tr>
<tr class="separator:a783ed86ae62c0aacfdb49ecbfa78ad85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eaebd4a61a16c8f222eecae4bfdc9ca" id="r_a7eaebd4a61a16c8f222eecae4bfdc9ca"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:a7eaebd4a61a16c8f222eecae4bfdc9ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1variant.html">variant</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a7eaebd4a61a16c8f222eecae4bfdc9ca">operator=</a> (std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; <a class="el" href="classsumty_1_1result.html">rhs</a>)</td></tr>
<tr class="memdesc:a7eaebd4a61a16c8f222eecae4bfdc9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwarding assignment operator with initializer list.  <br /></td></tr>
<tr class="separator:a7eaebd4a61a16c8f222eecae4bfdc9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16ab6b77ec8c07ce9c5e558de5cd82b" id="r_ae16ab6b77ec8c07ce9c5e558de5cd82b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#ae16ab6b77ec8c07ce9c5e558de5cd82b">index</a> () <a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:ae16ab6b77ec8c07ce9c5e558de5cd82b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index of the contained alternative.  <br /></td></tr>
<tr class="separator:ae16ab6b77ec8c07ce9c5e558de5cd82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51aa9c79ed9d904626ad89616ee4990f" id="r_a51aa9c79ed9d904626ad89616ee4990f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... Args&gt; </td></tr>
<tr class="memitem:a51aa9c79ed9d904626ad89616ee4990f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a51aa9c79ed9d904626ad89616ee4990f">emplace</a> (<a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;... <a class="el" href="classsumty_1_1result.html">args</a>)</td></tr>
<tr class="memdesc:a51aa9c79ed9d904626ad89616ee4990f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new alternative in place by index.  <br /></td></tr>
<tr class="separator:a51aa9c79ed9d904626ad89616ee4990f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d75a701faaf7cda03a358a84acfe3ac" id="r_a4d75a701faaf7cda03a358a84acfe3ac"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </td></tr>
<tr class="memitem:a4d75a701faaf7cda03a358a84acfe3ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a4d75a701faaf7cda03a358a84acfe3ac">emplace</a> (std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; <a class="el" href="classsumty_1_1result.html">ilist</a>, <a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;... <a class="el" href="classsumty_1_1result.html">args</a>)</td></tr>
<tr class="memdesc:a4d75a701faaf7cda03a358a84acfe3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new alternative in place by index.  <br /></td></tr>
<tr class="separator:a4d75a701faaf7cda03a358a84acfe3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51aa9c79ed9d904626ad89616ee4990f" id="r_a51aa9c79ed9d904626ad89616ee4990f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </td></tr>
<tr class="memitem:a51aa9c79ed9d904626ad89616ee4990f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a51aa9c79ed9d904626ad89616ee4990f">emplace</a> (<a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;... <a class="el" href="classsumty_1_1result.html">args</a>)</td></tr>
<tr class="memdesc:a51aa9c79ed9d904626ad89616ee4990f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new alternative in place by type.  <br /></td></tr>
<tr class="separator:a51aa9c79ed9d904626ad89616ee4990f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9de1c1c1f667f57155919abb7e79d6" id="r_abe9de1c1c1f667f57155919abb7e79d6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> , typename... Args&gt; </td></tr>
<tr class="memitem:abe9de1c1c1f667f57155919abb7e79d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#abe9de1c1c1f667f57155919abb7e79d6">emplace</a> (std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">V</a> &gt; <a class="el" href="classsumty_1_1result.html">ilist</a>, <a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;... <a class="el" href="classsumty_1_1result.html">args</a>)</td></tr>
<tr class="memdesc:abe9de1c1c1f667f57155919abb7e79d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new alternative in place by type.  <br /></td></tr>
<tr class="separator:abe9de1c1c1f667f57155919abb7e79d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2d2b17eb46b78620e923b1b58a1899" id="r_aff2d2b17eb46b78620e923b1b58a1899"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </td></tr>
<tr class="memitem:aff2d2b17eb46b78620e923b1b58a1899"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#aff2d2b17eb46b78620e923b1b58a1899">operator[]</a> (<a class="el" href="structsumty_1_1index__t.html">index_t</a>&lt; <a class="el" href="classsumty_1_1result.html">I</a> &gt; <a class="el" href="classsumty_1_1variant.html#ae16ab6b77ec8c07ce9c5e558de5cd82b">index</a>) &amp;<a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:aff2d2b17eb46b78620e923b1b58a1899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative access operator by index.  <br /></td></tr>
<tr class="separator:aff2d2b17eb46b78620e923b1b58a1899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acc04a3c20910caf473d04e3df96dac" id="r_a4acc04a3c20910caf473d04e3df96dac"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </td></tr>
<tr class="memitem:a4acc04a3c20910caf473d04e3df96dac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a4acc04a3c20910caf473d04e3df96dac">operator[]</a> (<a class="el" href="structsumty_1_1index__t.html">index_t</a>&lt; <a class="el" href="classsumty_1_1result.html">I</a> &gt; <a class="el" href="classsumty_1_1variant.html#ae16ab6b77ec8c07ce9c5e558de5cd82b">index</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;<a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:a4acc04a3c20910caf473d04e3df96dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative access operator by index.  <br /></td></tr>
<tr class="separator:a4acc04a3c20910caf473d04e3df96dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d78cf19fadfc52be6fc46b972746912" id="r_a7d78cf19fadfc52be6fc46b972746912"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </td></tr>
<tr class="memitem:a7d78cf19fadfc52be6fc46b972746912"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a7d78cf19fadfc52be6fc46b972746912">operator[]</a> (<a class="el" href="structsumty_1_1index__t.html">index_t</a>&lt; <a class="el" href="classsumty_1_1result.html">I</a> &gt; <a class="el" href="classsumty_1_1variant.html#ae16ab6b77ec8c07ce9c5e558de5cd82b">index</a>) &amp;&amp;</td></tr>
<tr class="memdesc:a7d78cf19fadfc52be6fc46b972746912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative access operator by index.  <br /></td></tr>
<tr class="separator:a7d78cf19fadfc52be6fc46b972746912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015017e598c8340b3be3481a5ef7d1f8" id="r_a015017e598c8340b3be3481a5ef7d1f8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </td></tr>
<tr class="memitem:a015017e598c8340b3be3481a5ef7d1f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a015017e598c8340b3be3481a5ef7d1f8">operator[]</a> (<a class="el" href="structsumty_1_1index__t.html">index_t</a>&lt; <a class="el" href="classsumty_1_1result.html">I</a> &gt; <a class="el" href="classsumty_1_1variant.html#ae16ab6b77ec8c07ce9c5e558de5cd82b">index</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:a015017e598c8340b3be3481a5ef7d1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative access operator by index.  <br /></td></tr>
<tr class="separator:a015017e598c8340b3be3481a5ef7d1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe93f72a909cf965adbf3fc1c3b73e6b" id="r_abe93f72a909cf965adbf3fc1c3b73e6b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:abe93f72a909cf965adbf3fc1c3b73e6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#abe93f72a909cf965adbf3fc1c3b73e6b">operator[]</a> (<a class="el" href="structsumty_1_1type__t.html">type_t</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; type) &amp;<a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:abe93f72a909cf965adbf3fc1c3b73e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative access operator by type.  <br /></td></tr>
<tr class="separator:abe93f72a909cf965adbf3fc1c3b73e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7947e07a7b41fa6276746a4244a4923a" id="r_a7947e07a7b41fa6276746a4244a4923a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:a7947e07a7b41fa6276746a4244a4923a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a7947e07a7b41fa6276746a4244a4923a">operator[]</a> (<a class="el" href="structsumty_1_1type__t.html">type_t</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; type) <a class="el" href="classsumty_1_1result.html">const</a> &amp;<a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:a7947e07a7b41fa6276746a4244a4923a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative access operator by type.  <br /></td></tr>
<tr class="separator:a7947e07a7b41fa6276746a4244a4923a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ba2eeeab7db3966934aafe7db79735" id="r_a65ba2eeeab7db3966934aafe7db79735"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:a65ba2eeeab7db3966934aafe7db79735"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a65ba2eeeab7db3966934aafe7db79735">operator[]</a> (<a class="el" href="structsumty_1_1type__t.html">type_t</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; type) &amp;&amp;</td></tr>
<tr class="memdesc:a65ba2eeeab7db3966934aafe7db79735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative access operator by type.  <br /></td></tr>
<tr class="separator:a65ba2eeeab7db3966934aafe7db79735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9e8b0aad003da2ccef9e62f8133ad0" id="r_a5d9e8b0aad003da2ccef9e62f8133ad0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:a5d9e8b0aad003da2ccef9e62f8133ad0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a5d9e8b0aad003da2ccef9e62f8133ad0">operator[]</a> (<a class="el" href="structsumty_1_1type__t.html">type_t</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; type) <a class="el" href="classsumty_1_1result.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:a5d9e8b0aad003da2ccef9e62f8133ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative access operator by type.  <br /></td></tr>
<tr class="separator:a5d9e8b0aad003da2ccef9e62f8133ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb0f2e97a687affd34d9ece8c9c59bc" id="r_a5bb0f2e97a687affd34d9ece8c9c59bc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </td></tr>
<tr class="memitem:a5bb0f2e97a687affd34d9ece8c9c59bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a5bb0f2e97a687affd34d9ece8c9c59bc">get</a> () &amp;</td></tr>
<tr class="memdesc:a5bb0f2e97a687affd34d9ece8c9c59bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by index.  <br /></td></tr>
<tr class="separator:a5bb0f2e97a687affd34d9ece8c9c59bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cce71efb47892db3403e54fef6072e" id="r_a25cce71efb47892db3403e54fef6072e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </td></tr>
<tr class="memitem:a25cce71efb47892db3403e54fef6072e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a25cce71efb47892db3403e54fef6072e">get</a> () <a class="el" href="classsumty_1_1result.html">const</a> &amp;</td></tr>
<tr class="memdesc:a25cce71efb47892db3403e54fef6072e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by index.  <br /></td></tr>
<tr class="separator:a25cce71efb47892db3403e54fef6072e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e0f8f4c60cc6726ce6571168835d89" id="r_a66e0f8f4c60cc6726ce6571168835d89"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </td></tr>
<tr class="memitem:a66e0f8f4c60cc6726ce6571168835d89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a66e0f8f4c60cc6726ce6571168835d89">get</a> () &amp;&amp;</td></tr>
<tr class="memdesc:a66e0f8f4c60cc6726ce6571168835d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by index.  <br /></td></tr>
<tr class="separator:a66e0f8f4c60cc6726ce6571168835d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcc32bc6f1d424bb8041401437cd401" id="r_acfcc32bc6f1d424bb8041401437cd401"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </td></tr>
<tr class="memitem:acfcc32bc6f1d424bb8041401437cd401"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#acfcc32bc6f1d424bb8041401437cd401">get</a> () <a class="el" href="classsumty_1_1result.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:acfcc32bc6f1d424bb8041401437cd401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by index.  <br /></td></tr>
<tr class="separator:acfcc32bc6f1d424bb8041401437cd401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb0f2e97a687affd34d9ece8c9c59bc" id="r_a5bb0f2e97a687affd34d9ece8c9c59bc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:a5bb0f2e97a687affd34d9ece8c9c59bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a5bb0f2e97a687affd34d9ece8c9c59bc">get</a> () &amp;</td></tr>
<tr class="memdesc:a5bb0f2e97a687affd34d9ece8c9c59bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by type.  <br /></td></tr>
<tr class="separator:a5bb0f2e97a687affd34d9ece8c9c59bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cce71efb47892db3403e54fef6072e" id="r_a25cce71efb47892db3403e54fef6072e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:a25cce71efb47892db3403e54fef6072e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a25cce71efb47892db3403e54fef6072e">get</a> () <a class="el" href="classsumty_1_1result.html">const</a> &amp;</td></tr>
<tr class="memdesc:a25cce71efb47892db3403e54fef6072e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by type.  <br /></td></tr>
<tr class="separator:a25cce71efb47892db3403e54fef6072e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e0f8f4c60cc6726ce6571168835d89" id="r_a66e0f8f4c60cc6726ce6571168835d89"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:a66e0f8f4c60cc6726ce6571168835d89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a66e0f8f4c60cc6726ce6571168835d89">get</a> () &amp;&amp;</td></tr>
<tr class="memdesc:a66e0f8f4c60cc6726ce6571168835d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by type.  <br /></td></tr>
<tr class="separator:a66e0f8f4c60cc6726ce6571168835d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcc32bc6f1d424bb8041401437cd401" id="r_acfcc32bc6f1d424bb8041401437cd401"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:acfcc32bc6f1d424bb8041401437cd401"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#acfcc32bc6f1d424bb8041401437cd401">get</a> () <a class="el" href="classsumty_1_1result.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:acfcc32bc6f1d424bb8041401437cd401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by type.  <br /></td></tr>
<tr class="separator:acfcc32bc6f1d424bb8041401437cd401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b10b57fcb769be2c692a4b6df452ab" id="r_a58b10b57fcb769be2c692a4b6df452ab"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </td></tr>
<tr class="memitem:a58b10b57fcb769be2c692a4b6df452ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">POINTER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a58b10b57fcb769be2c692a4b6df452ab">get_if</a> () <a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:a58b10b57fcb769be2c692a4b6df452ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative pointer by index if the <a class="el" href="classsumty_1_1variant.html">variant</a> holds it.  <br /></td></tr>
<tr class="separator:a58b10b57fcb769be2c692a4b6df452ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265bae72c738f8886a40d3fcb358e70d" id="r_a265bae72c738f8886a40d3fcb358e70d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </td></tr>
<tr class="memitem:a265bae72c738f8886a40d3fcb358e70d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_POINTER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a265bae72c738f8886a40d3fcb358e70d">get_if</a> () <a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:a265bae72c738f8886a40d3fcb358e70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative pointer by index if the <a class="el" href="classsumty_1_1variant.html">variant</a> holds it.  <br /></td></tr>
<tr class="separator:a265bae72c738f8886a40d3fcb358e70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b10b57fcb769be2c692a4b6df452ab" id="r_a58b10b57fcb769be2c692a4b6df452ab"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:a58b10b57fcb769be2c692a4b6df452ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">POINTER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a58b10b57fcb769be2c692a4b6df452ab">get_if</a> () <a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:a58b10b57fcb769be2c692a4b6df452ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative pointer by type if the <a class="el" href="classsumty_1_1variant.html">variant</a> holds it.  <br /></td></tr>
<tr class="separator:a58b10b57fcb769be2c692a4b6df452ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265bae72c738f8886a40d3fcb358e70d" id="r_a265bae72c738f8886a40d3fcb358e70d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:a265bae72c738f8886a40d3fcb358e70d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_POINTER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a265bae72c738f8886a40d3fcb358e70d">get_if</a> () <a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:a265bae72c738f8886a40d3fcb358e70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative pointer by type if the <a class="el" href="classsumty_1_1variant.html">variant</a> holds it.  <br /></td></tr>
<tr class="separator:a265bae72c738f8886a40d3fcb358e70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4ebf4f8a4bb3bccd7566476219bfa3" id="r_a7d4ebf4f8a4bb3bccd7566476219bfa3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:a7d4ebf4f8a4bb3bccd7566476219bfa3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a7d4ebf4f8a4bb3bccd7566476219bfa3">holds_alternative</a> () <a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:a7d4ebf4f8a4bb3bccd7566476219bfa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a <a class="el" href="classsumty_1_1variant.html">variant</a> contains a particular alternative.  <br /></td></tr>
<tr class="separator:a7d4ebf4f8a4bb3bccd7566476219bfa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f575e3e78ea2171d1be475f7f9a2d8" id="r_ae2f575e3e78ea2171d1be475f7f9a2d8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:ae2f575e3e78ea2171d1be475f7f9a2d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a> (<a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">visitor</a>) &amp;</td></tr>
<tr class="memdesc:ae2f575e3e78ea2171d1be475f7f9a2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a visitor callable with the contained alternative.  <br /></td></tr>
<tr class="separator:ae2f575e3e78ea2171d1be475f7f9a2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeca86cd9abb551e0c1e52ba81289f29" id="r_aeeca86cd9abb551e0c1e52ba81289f29"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:aeeca86cd9abb551e0c1e52ba81289f29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#aeeca86cd9abb551e0c1e52ba81289f29">visit</a> (<a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">visitor</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;</td></tr>
<tr class="memdesc:aeeca86cd9abb551e0c1e52ba81289f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a visitor callable with the contained alternative.  <br /></td></tr>
<tr class="separator:aeeca86cd9abb551e0c1e52ba81289f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaaf65bdef1581aff9bda2ed4174143d" id="r_adaaf65bdef1581aff9bda2ed4174143d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:adaaf65bdef1581aff9bda2ed4174143d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#adaaf65bdef1581aff9bda2ed4174143d">visit</a> (<a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">visitor</a>) &amp;&amp;</td></tr>
<tr class="memdesc:adaaf65bdef1581aff9bda2ed4174143d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a visitor callable with the contained alternative.  <br /></td></tr>
<tr class="separator:adaaf65bdef1581aff9bda2ed4174143d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b9d6a30c96d7caac920ce264c66de1" id="r_a12b9d6a30c96d7caac920ce264c66de1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:a12b9d6a30c96d7caac920ce264c66de1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a12b9d6a30c96d7caac920ce264c66de1">visit</a> (<a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">visitor</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:a12b9d6a30c96d7caac920ce264c66de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a visitor callable with the contained alternative.  <br /></td></tr>
<tr class="separator:a12b9d6a30c96d7caac920ce264c66de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1656bb14f0a45ec7cfa81bb960acf924" id="r_a1656bb14f0a45ec7cfa81bb960acf924"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:a1656bb14f0a45ec7cfa81bb960acf924"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a1656bb14f0a45ec7cfa81bb960acf924">visit_informed</a> (<a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">visitor</a>) &amp;</td></tr>
<tr class="memdesc:a1656bb14f0a45ec7cfa81bb960acf924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a visitor callable with the contained alternative and metadata.  <br /></td></tr>
<tr class="separator:a1656bb14f0a45ec7cfa81bb960acf924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb3a178a071dfb5bdecb8607d446a4b" id="r_aebb3a178a071dfb5bdecb8607d446a4b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:aebb3a178a071dfb5bdecb8607d446a4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#aebb3a178a071dfb5bdecb8607d446a4b">visit_informed</a> (<a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">visitor</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;</td></tr>
<tr class="memdesc:aebb3a178a071dfb5bdecb8607d446a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a visitor callable with the contained alternative and metadata.  <br /></td></tr>
<tr class="separator:aebb3a178a071dfb5bdecb8607d446a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b181b22d126a38b86f5a93035b6b7bc" id="r_a2b181b22d126a38b86f5a93035b6b7bc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:a2b181b22d126a38b86f5a93035b6b7bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a2b181b22d126a38b86f5a93035b6b7bc">visit_informed</a> (<a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">visitor</a>) &amp;&amp;</td></tr>
<tr class="memdesc:a2b181b22d126a38b86f5a93035b6b7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a visitor callable with the contained alternative and metadata.  <br /></td></tr>
<tr class="separator:a2b181b22d126a38b86f5a93035b6b7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdb84ccc3402ad25040ee85cbffb9a3" id="r_affdb84ccc3402ad25040ee85cbffb9a3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:affdb84ccc3402ad25040ee85cbffb9a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#affdb84ccc3402ad25040ee85cbffb9a3">visit_informed</a> (<a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">visitor</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:affdb84ccc3402ad25040ee85cbffb9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a visitor callable with the contained alternative and metadata.  <br /></td></tr>
<tr class="separator:affdb84ccc3402ad25040ee85cbffb9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e13a6bbf81b8927f418e5e9197ce67c" id="r_a3e13a6bbf81b8927f418e5e9197ce67c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a3e13a6bbf81b8927f418e5e9197ce67c">swap</a> (<a class="el" href="classsumty_1_1variant.html">variant</a> &amp;<a class="el" href="classsumty_1_1result.html">other</a>) <a class="el" href="classsumty_1_1result.html">CONDITIONALLY_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3e13a6bbf81b8927f418e5e9197ce67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two <a class="el" href="classsumty_1_1variant.html">variant</a> instances.  <br /></td></tr>
<tr class="separator:a3e13a6bbf81b8927f418e5e9197ce67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8d73b66c82bd886d69315a8f4b244387" id="r_a8d73b66c82bd886d69315a8f4b244387"><td class="memItemLeft" align="right" valign="top"><a id="a8d73b66c82bd886d69315a8f4b244387" name="a8d73b66c82bd886d69315a8f4b244387"></a>
<a class="el" href="classsumty_1_1result.html">class</a>&#160;</td><td class="memItemRight" valign="bottom"><b>error_set&lt; T... &gt;</b></td></tr>
<tr class="separator:a8d73b66c82bd886d69315a8f4b244387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d3ad0b808ae578a08ec9cde8a6adac" id="r_a65d3ad0b808ae578a08ec9cde8a6adac"><td class="memTemplParams" colspan="2"><a id="a65d3ad0b808ae578a08ec9cde8a6adac" name="a65d3ad0b808ae578a08ec9cde8a6adac"></a>
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> , <a class="el" href="classsumty_1_1result.html">typename</a> &gt; </td></tr>
<tr class="memitem:a65d3ad0b808ae578a08ec9cde8a6adac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">class</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>result</b></td></tr>
<tr class="separator:a65d3ad0b808ae578a08ec9cde8a6adac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:ac57ee49bf006d79fa05d8f309627e2dc" id="r_ac57ee49bf006d79fa05d8f309627e2dc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </td></tr>
<tr class="memitem:ac57ee49bf006d79fa05d8f309627e2dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#ac57ee49bf006d79fa05d8f309627e2dc">holds_alternative</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1variant.html">variant</a>&lt; U... &gt; &amp;<a class="el" href="classsumty_1_1result.html">v</a>) <a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:ac57ee49bf006d79fa05d8f309627e2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a <a class="el" href="classsumty_1_1variant.html">variant</a> contains a particular alternative.  <br /></td></tr>
<tr class="separator:ac57ee49bf006d79fa05d8f309627e2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3063ea8d0698960c87e804a3aab91fb7" id="r_a3063ea8d0698960c87e804a3aab91fb7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... T&gt; </td></tr>
<tr class="memitem:a3063ea8d0698960c87e804a3aab91fb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a3063ea8d0698960c87e804a3aab91fb7">get</a> (<a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T... &gt; &amp;<a class="el" href="classsumty_1_1result.html">v</a>)</td></tr>
<tr class="memdesc:a3063ea8d0698960c87e804a3aab91fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative by index.  <br /></td></tr>
<tr class="separator:a3063ea8d0698960c87e804a3aab91fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a94fa612fae580619b3ca2daa452b19" id="r_a2a94fa612fae580619b3ca2daa452b19"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... T&gt; </td></tr>
<tr class="memitem:a2a94fa612fae580619b3ca2daa452b19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a2a94fa612fae580619b3ca2daa452b19">get</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T... &gt; &amp;<a class="el" href="classsumty_1_1result.html">v</a>)</td></tr>
<tr class="memdesc:a2a94fa612fae580619b3ca2daa452b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative by index.  <br /></td></tr>
<tr class="separator:a2a94fa612fae580619b3ca2daa452b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59495d492a709f1b133567ecb491fd8e" id="r_a59495d492a709f1b133567ecb491fd8e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... T&gt; </td></tr>
<tr class="memitem:a59495d492a709f1b133567ecb491fd8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a59495d492a709f1b133567ecb491fd8e">get</a> (<a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T... &gt; &amp;&amp;<a class="el" href="classsumty_1_1result.html">v</a>)</td></tr>
<tr class="memdesc:a59495d492a709f1b133567ecb491fd8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative by index.  <br /></td></tr>
<tr class="separator:a59495d492a709f1b133567ecb491fd8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e93de94fdccb8aeb6cc7b408310ac2" id="r_a06e93de94fdccb8aeb6cc7b408310ac2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... T&gt; </td></tr>
<tr class="memitem:a06e93de94fdccb8aeb6cc7b408310ac2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a06e93de94fdccb8aeb6cc7b408310ac2">get</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T... &gt; &amp;&amp;<a class="el" href="classsumty_1_1result.html">v</a>)</td></tr>
<tr class="memdesc:a06e93de94fdccb8aeb6cc7b408310ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative by index.  <br /></td></tr>
<tr class="separator:a06e93de94fdccb8aeb6cc7b408310ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28e370bd09931bc720c0dc297c1e2cf" id="r_ad28e370bd09931bc720c0dc297c1e2cf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </td></tr>
<tr class="memitem:ad28e370bd09931bc720c0dc297c1e2cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#ad28e370bd09931bc720c0dc297c1e2cf">get</a> (<a class="el" href="classsumty_1_1variant.html">variant</a>&lt; U... &gt; &amp;<a class="el" href="classsumty_1_1result.html">v</a>)</td></tr>
<tr class="memdesc:ad28e370bd09931bc720c0dc297c1e2cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative by type.  <br /></td></tr>
<tr class="separator:ad28e370bd09931bc720c0dc297c1e2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b993aa6228232cc846c8d030b46ad4" id="r_a74b993aa6228232cc846c8d030b46ad4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </td></tr>
<tr class="memitem:a74b993aa6228232cc846c8d030b46ad4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a74b993aa6228232cc846c8d030b46ad4">get</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1variant.html">variant</a>&lt; U... &gt; &amp;<a class="el" href="classsumty_1_1result.html">v</a>)</td></tr>
<tr class="memdesc:a74b993aa6228232cc846c8d030b46ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative by type.  <br /></td></tr>
<tr class="separator:a74b993aa6228232cc846c8d030b46ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa13af27607b6f326db3341bdcb09f0b" id="r_afa13af27607b6f326db3341bdcb09f0b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </td></tr>
<tr class="memitem:afa13af27607b6f326db3341bdcb09f0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#afa13af27607b6f326db3341bdcb09f0b">get</a> (<a class="el" href="classsumty_1_1variant.html">variant</a>&lt; U... &gt; &amp;&amp;<a class="el" href="classsumty_1_1result.html">v</a>)</td></tr>
<tr class="memdesc:afa13af27607b6f326db3341bdcb09f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative by type.  <br /></td></tr>
<tr class="separator:afa13af27607b6f326db3341bdcb09f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6eebbfa1d2180dbbbf08c00cfb3c4aa" id="r_ac6eebbfa1d2180dbbbf08c00cfb3c4aa"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </td></tr>
<tr class="memitem:ac6eebbfa1d2180dbbbf08c00cfb3c4aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#ac6eebbfa1d2180dbbbf08c00cfb3c4aa">get</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1variant.html">variant</a>&lt; U... &gt; &amp;&amp;<a class="el" href="classsumty_1_1result.html">v</a>)</td></tr>
<tr class="memdesc:ac6eebbfa1d2180dbbbf08c00cfb3c4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative by type.  <br /></td></tr>
<tr class="separator:ac6eebbfa1d2180dbbbf08c00cfb3c4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590e66ffb36c4125361cae5473a04ceb" id="r_a590e66ffb36c4125361cae5473a04ceb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... T&gt; </td></tr>
<tr class="memitem:a590e66ffb36c4125361cae5473a04ceb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">POINTER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a590e66ffb36c4125361cae5473a04ceb">get_if</a> (<a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T... &gt; &amp;<a class="el" href="classsumty_1_1result.html">v</a>) <a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:a590e66ffb36c4125361cae5473a04ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative pointer by index if the <a class="el" href="classsumty_1_1variant.html">variant</a> holds it.  <br /></td></tr>
<tr class="separator:a590e66ffb36c4125361cae5473a04ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d931451f84459fadd8a52f71c90aec" id="r_af3d931451f84459fadd8a52f71c90aec"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... T&gt; </td></tr>
<tr class="memitem:af3d931451f84459fadd8a52f71c90aec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_POINTER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#af3d931451f84459fadd8a52f71c90aec">get_if</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T... &gt; &amp;<a class="el" href="classsumty_1_1result.html">v</a>) <a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:af3d931451f84459fadd8a52f71c90aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative pointer by index if the <a class="el" href="classsumty_1_1variant.html">variant</a> holds it.  <br /></td></tr>
<tr class="separator:af3d931451f84459fadd8a52f71c90aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10db7764a1129d3f79f7de3e6e8517af" id="r_a10db7764a1129d3f79f7de3e6e8517af"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </td></tr>
<tr class="memitem:a10db7764a1129d3f79f7de3e6e8517af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">POINTER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a10db7764a1129d3f79f7de3e6e8517af">get_if</a> (<a class="el" href="classsumty_1_1variant.html">variant</a>&lt; U... &gt; &amp;<a class="el" href="classsumty_1_1result.html">v</a>) <a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:a10db7764a1129d3f79f7de3e6e8517af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative pointer by type if the <a class="el" href="classsumty_1_1variant.html">variant</a> holds it.  <br /></td></tr>
<tr class="separator:a10db7764a1129d3f79f7de3e6e8517af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6017cc1255d8cb5d364b388908ec28cb" id="r_a6017cc1255d8cb5d364b388908ec28cb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </td></tr>
<tr class="memitem:a6017cc1255d8cb5d364b388908ec28cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_POINTER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a6017cc1255d8cb5d364b388908ec28cb">get_if</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1variant.html">variant</a>&lt; U... &gt; &amp;<a class="el" href="classsumty_1_1result.html">v</a>) <a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:a6017cc1255d8cb5d364b388908ec28cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative pointer by type if the <a class="el" href="classsumty_1_1variant.html">variant</a> holds it.  <br /></td></tr>
<tr class="separator:a6017cc1255d8cb5d364b388908ec28cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b53cd212208e109ace84aaebd3c551" id="r_a36b53cd212208e109ace84aaebd3c551"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:a36b53cd212208e109ace84aaebd3c551"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a36b53cd212208e109ace84aaebd3c551">visit</a> (<a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">visitor</a>)</td></tr>
<tr class="memdesc:a36b53cd212208e109ace84aaebd3c551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a visitor callable with the contained <a class="el" href="classsumty_1_1variant.html">variant</a> alternatives.  <br /></td></tr>
<tr class="separator:a36b53cd212208e109ace84aaebd3c551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a6c93a7dc3eb3fa432d88920de7262" id="r_af3a6c93a7dc3eb3fa432d88920de7262"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">T0</a> , typename... TN&gt; </td></tr>
<tr class="memitem:af3a6c93a7dc3eb3fa432d88920de7262"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#af3a6c93a7dc3eb3fa432d88920de7262">visit</a> (<a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">visitor</a>, <a class="el" href="classsumty_1_1result.html">T0</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">var0</a>, <a class="el" href="classsumty_1_1result.html">TN</a> &amp;&amp;... <a class="el" href="classsumty_1_1result.html">varn</a>)</td></tr>
<tr class="memdesc:af3a6c93a7dc3eb3fa432d88920de7262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a visitor callable with the contained <a class="el" href="classsumty_1_1variant.html">variant</a> alternatives.  <br /></td></tr>
<tr class="separator:af3a6c93a7dc3eb3fa432d88920de7262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67aa2067f8434d8f54fd715d893022a7" id="r_a67aa2067f8434d8f54fd715d893022a7"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a67aa2067f8434d8f54fd715d893022a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1variant.html#a67aa2067f8434d8f54fd715d893022a7">swap</a> (<a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T... &gt; &amp;<a class="el" href="classsumty_1_1result.html">a</a>, <a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T... &gt; &amp;<a class="el" href="classsumty_1_1result.html">b</a>) <a class="el" href="classsumty_1_1result.html">CONDITIONALLY_NOEXCEPT</a></td></tr>
<tr class="memdesc:a67aa2067f8434d8f54fd715d893022a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two <a class="el" href="classsumty_1_1variant.html">variant</a> instances.  <br /></td></tr>
<tr class="separator:a67aa2067f8434d8f54fd715d893022a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename... T&gt;<br />
class sumty::variant&lt; T &gt;</div><p>General discriminated union. </p>
<p><a class="el" href="classsumty_1_1variant.html">variant</a> is the fundamental sum type of sumty. <a class="el" href="classsumty_1_1option.html">option</a>, <a class="el" href="classsumty_1_1result.html">result</a>, and <a class="el" href="classsumty_1_1error__set.html">error_set</a> are defined in terms of <a class="el" href="classsumty_1_1variant.html">variant</a>.</p>
<p><a class="el" href="classsumty_1_1variant.html">variant</a> is very similar to <code>std::variant</code>, but it does have some key differences. Most notably, <a class="el" href="classsumty_1_1variant.html">variant</a> does not support type-based alternative selection unless all alternatives have a distinct type. For example, <code>std::variant</code> will allow the code shown below, but <a class="el" href="classsumty_1_1variant.html">variant</a> will not.</p>
<div class="fragment"><div class="line">std::variant&lt;int, int&gt; <a class="code hl_class" href="classsumty_1_1result.html">v</a> = 42;</div>
<div class="ttc" id="aclasssumty_1_1result_html"><div class="ttname"><a href="classsumty_1_1result.html">sumty::result</a></div><div class="ttdoc">Type that contains an ok value, or an error.</div><div class="ttdef"><b>Definition</b> result.hpp:1262</div></div>
</div><!-- fragment --><p>Any such functionality from <code>std::variant</code> that is similarly ambiguous to the reader is disallowed by <a class="el" href="classsumty_1_1variant.html">variant</a>. Otherwise, the interface provided by <a class="el" href="classsumty_1_1variant.html">variant</a> is identical to <code>std::variant</code>, but with some additional functions available.</p>
<p>Another key difference from <code>std::variant</code> is that <a class="el" href="classsumty_1_1variant.html">variant</a> allows alternatives to have <code>void</code> and references (both lvalue and rvalue) as types. When using an lvalue reference as an alternative type, copy and move semantics applied to the <a class="el" href="classsumty_1_1variant.html">variant</a> are the same as a raw pointer (both trivial), instead of immovability of lvalue references.</p>
<p>A more subtle, but important, difference from <code>std::variant</code> is that <a class="el" href="classsumty_1_1variant.html">variant</a> makes size optimizations for several special cases. These special cases revolve around alternatives with types that are lvalue references, <code>void</code>, and empty types (such as <code>std::monostate</code>).</p>
<p><code>void</code> and empty types need not occupy any memory at runtime, despite the fact that <code>sizeof(&lt;empty-type&gt;) == 1</code> in C++. A <a class="el" href="classsumty_1_1variant.html">variant</a> consisting entirely of alternatives with types that are <code>void</code> or empty types only takes up enough space to store a discriminant, which is always the smallest possible integral type necessary to store the value <code>N - 1</code>, where <code>N</code> is the number of alternatives. Here are some examples:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_class" href="classsumty_1_1result.html">empty_t</a> {};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(std::is_empty_v&lt;<a class="code hl_class" href="classsumty_1_1result.html">variant&lt;void&gt;</a>&gt;);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(std::is_empty_v&lt;<a class="code hl_class" href="classsumty_1_1result.html">variant&lt;empty_t&gt;</a>&gt;);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">sizeof</span>(<a class="code hl_class" href="classsumty_1_1result.html">variant&lt;void, empty_t&gt;</a>) == <span class="keyword">sizeof</span>(<span class="keywordtype">bool</span>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">sizeof</span>(<a class="code hl_class" href="classsumty_1_1result.html">variant&lt;empty_t, ...&gt;</a>) <span class="comment">// repeated 256 times</span></div>
<div class="line">        == <span class="keyword">sizeof</span>(<a class="code hl_class" href="classsumty_1_1result.html">uint8_t</a>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">sizeof</span>(<a class="code hl_class" href="classsumty_1_1result.html">variant&lt;empty_t, ...&gt;</a>) <span class="comment">// repeated 257 times</span></div>
<div class="line">        == <span class="keyword">sizeof</span>(<a class="code hl_class" href="classsumty_1_1result.html">uint16_t</a>));</div>
</div><!-- fragment --><p>lvalue references have the invariant that the underlying pointer is not null. This means in cases where there are only two alternatives, with one being an lvalue reference and the other being <code>void</code> or an empty type, null and non-null can be used as the discriminanting values instead of having a separate discriminant. Here are some more examples:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_class" href="classsumty_1_1result.html">empty_t</a> {};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">sizeof</span>(<a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int&amp;, void&gt;</a>) == <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>*));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">sizeof</span>(<a class="code hl_class" href="classsumty_1_1result.html">variant&lt;empty_t, int&amp;&gt;</a>) == <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>*));</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><a class="el" href="classsumty_1_1variant.html">variant</a> alternative types </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaff7515701528c079656b289d2e002ca" name="aaff7515701528c079656b289d2e002ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff7515701528c079656b289d2e002ca">&#9670;&#160;</a></span>variant() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1variant.html">variant</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Initializes the <a class="el" href="classsumty_1_1variant.html">variant</a> such that it contains a default constructed value of the first (index 0) alternative.</p>
<p>The first alternative <em>must</em> be default constructible for this constructor to participate in overload resoltuion, but no other alternatives need be default constructible.</p>
<h2><a class="anchor" id="autotoc_md442"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, bool, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">holds_alternative&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.index() == 0);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;0&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == <span class="keywordtype">int</span>{});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="acd70aa4985ff543492dd1d33f5790064" name="acd70aa4985ff543492dd1d33f5790064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd70aa4985ff543492dd1d33f5790064">&#9670;&#160;</a></span>variant() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1variant.html">variant</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>A new <a class="el" href="classsumty_1_1variant.html">variant</a> is initialized such that it contains a copy constructed instance of the alternative contained in the source <a class="el" href="classsumty_1_1variant.html">variant</a>. If the source <a class="el" href="classsumty_1_1variant.html">variant</a> has more than one alternative of the same type, the new <a class="el" href="classsumty_1_1variant.html">variant</a> will contain the alternative of the same index.</p>
<p>All alternative types <em>must</em> be copy constructible for this constructor to participate in overload resolution.</p>
<h2><a class="anchor" id="autotoc_md443"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, bool, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v1</a>{std::in_place_index&lt;2&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, bool, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v2</a>{<a class="code hl_class" href="classsumty_1_1result.html">v1</a>};</div>
<div class="line"> </div>
<div class="line">assert(holds_alternative&lt;int&gt;(v2));</div>
<div class="line"> </div>
<div class="line">assert(v2.index() == 2);</div>
<div class="line"> </div>
<div class="line">assert(get&lt;2&gt;(v2) == 42);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a13c32b34499275a35b567b7989b79eb7" name="a13c32b34499275a35b567b7989b79eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c32b34499275a35b567b7989b79eb7">&#9670;&#160;</a></span>variant() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1variant.html">variant</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>A new <a class="el" href="classsumty_1_1variant.html">variant</a> is initialized such that it contains a move constructed instance of the alternative contained in the source <a class="el" href="classsumty_1_1variant.html">variant</a>. If the source vairant has more than one alternative of the same type, the new <a class="el" href="classsumty_1_1variant.html">variant</a> will contain the alternative of the same index.</p>
<p>All alternative types <em>must</em> be move constructible for this constructor to participate in overload resolution.</p>
<p>The source variant will continue to contain an instance of the same alternative, but the value of the alternative after being moved depends on the move constructor of the type. In general, moved values are said to be in a valid, but unspecified, state.</p>
<h2><a class="anchor" id="autotoc_md444"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, bool, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v1</a>{std::in_place_index&lt;2&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, bool, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v2</a>{std::move(<a class="code hl_class" href="classsumty_1_1result.html">v1</a>)};</div>
<div class="line"> </div>
<div class="line">assert(holds_alternative&lt;int&gt;(v2));</div>
<div class="line"> </div>
<div class="line">assert(v2.index() == 2);</div>
<div class="line"> </div>
<div class="line">assert(get&lt;2&gt;(v2) == 42);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a110b0144688c0ec68334267e06e47942" name="a110b0144688c0ec68334267e06e47942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110b0144688c0ec68334267e06e47942">&#9670;&#160;</a></span>variant() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> IDX, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1variant.html">variant</a> </td>
          <td>(</td>
          <td class="paramtype">std::in_place_index_t&lt; <a class="el" href="classsumty_1_1result.html">IDX</a> &gt;&#160;</td>
          <td class="paramname"><em>inplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index emplacement constructor. </p>
<p>A new <a class="el" href="classsumty_1_1variant.html">variant</a> is initialized such that it contains a newly constructed instance of the alternative with the specified index. The arguments following <code>inplace</code> are forwarded directly to the constructor of the alternative type.</p>
<p>Given that <code>U</code> is the type of the alternative at the specified index, this constructor is always valid as long as <code>U</code> is constructible with the arguments, <code>std::forward&lt;Args&gt;(args)...</code>.</p>
<h2><a class="anchor" id="autotoc_md445"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 5, <span class="charliteral">&#39;a&#39;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">holds_alternative&lt;std::string&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.index() == 1);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == <span class="stringliteral">&quot;aaaaa&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inplace</td><td>Constructor tag that specifies the alternative index. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments used to construct the alternative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85be3479b6c3fac697ce535ca16c53cf" name="a85be3479b6c3fac697ce535ca16c53cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85be3479b6c3fac697ce535ca16c53cf">&#9670;&#160;</a></span>variant() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> IDX, <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1variant.html">variant</a> </td>
          <td>(</td>
          <td class="paramtype">std::in_place_index_t&lt; <a class="el" href="classsumty_1_1result.html">IDX</a> &gt;&#160;</td>
          <td class="paramname"><em>inplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index emplacement constructor with <code>std::initializer_list</code> </p>
<p>A new <a class="el" href="classsumty_1_1variant.html">variant</a> is initialized such that it contains a newly constructed instance of the alternative with the specified index. The arguments following <code>inplace</code> are forwarded directly to the constructor of the alternative type.</p>
<p>Given that <code>U</code> is the type of the alternative at the specified index, this constructor is always valid as long as <code>U</code> is constructible with the arguments, <code>init, std::forward&lt;Args&gt;(args)...</code>.</p>
<h2><a class="anchor" id="autotoc_md446"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, std::vector&lt;int&gt;</a>&gt; <a class="code hl_class" href="classsumty_1_1result.html">v</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;,</div>
<div class="line">        {1, 2, 3, 4, 5}};</div>
<div class="line"> </div>
<div class="line">assert(<a class="code hl_function" href="classsumty_1_1variant.html#a7d4ebf4f8a4bb3bccd7566476219bfa3">holds_alternative</a>&lt;std::vector&lt;int&gt;&gt;(v));</div>
<div class="line"> </div>
<div class="line">assert(v.index() == 1);</div>
<div class="line"> </div>
<div class="line">assert(get&lt;1&gt;(v).size() == 5);</div>
<div class="ttc" id="aclasssumty_1_1variant_html_a7d4ebf4f8a4bb3bccd7566476219bfa3"><div class="ttname"><a href="classsumty_1_1variant.html#a7d4ebf4f8a4bb3bccd7566476219bfa3">sumty::variant::holds_alternative</a></div><div class="ttdeci">constexpr bool holds_alternative() const noexcept</div><div class="ttdoc">Checks if a variant contains a particular alternative.</div><div class="ttdef"><b>Definition</b> variant.hpp:1821</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inplace</td><td>Constructor tag that specifies the alternative index. </td></tr>
    <tr><td class="paramname">init</td><td>Initializer list forwarded to the alternative constructor </td></tr>
    <tr><td class="paramname">args</td><td>Additional arguments used to construct the alternative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1ba6a427080fa9ba989e750e3e3ef83" name="ab1ba6a427080fa9ba989e750e3e3ef83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ba6a427080fa9ba989e750e3e3ef83">&#9670;&#160;</a></span>variant() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1variant.html">variant</a> </td>
          <td>(</td>
          <td class="paramtype">std::in_place_type_t&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>inplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type emplacement constructor. </p>
<p>A new <a class="el" href="classsumty_1_1variant.html">variant</a> is initialized such that it contains a newly constructed instance of the alternative with the specified type. The arguments following <code>inplace</code> are forwarded directory to the constructor of the alternative type.</p>
<p>This constructor only participates in overload resolution if the alternative type, <code>U</code>, is unique among all alternatives of the <a class="el" href="classsumty_1_1variant.html">variant</a>. That is, <code>variant&lt;A, B, A&gt;</code>, cannot use this constructor to initialize an alternative of type <code>A</code>, but it could use this constructor to initialize the alternative of type <code>B</code>. This constraint is imposed to prevent ambiguity to the reader. Use the index based emplacement constructor instead to initialize the alternative of type <code>A</code>.</p>
<h2><a class="anchor" id="autotoc_md447"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{</div>
<div class="line">        std::in_place_type&lt;std::string&gt;,</div>
<div class="line">        5, <span class="charliteral">&#39;a&#39;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">holds_alternative&lt;std::string&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.index() == 1);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == <span class="stringliteral">&quot;aaaaa&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2cf6dd2547652a573fca2414801db408" name="a2cf6dd2547652a573fca2414801db408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf6dd2547652a573fca2414801db408">&#9670;&#160;</a></span>variant() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1variant.html">variant</a> </td>
          <td>(</td>
          <td class="paramtype">std::in_place_type_t&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>inplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">V</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type emplacement constructor with <code>std::initializer_list</code> </p>
<p>A new <a class="el" href="classsumty_1_1variant.html">variant</a> is initialized such that it contains a newly constructed instance of the alternative with the specified type. The arguments following <code>inplace</code> are forwarded directory to the constructor of the alternative type.</p>
<p>This constructor only participates in overload resolution if the alternative type, <code>U</code>, is unique among all alternatives of the <a class="el" href="classsumty_1_1variant.html">variant</a>. That is, <code>variant&lt;A, B, A&gt;</code>, cannot use this constructor to initialize an alternative of type <code>A</code>, but it could use this constructor to initialize the alternative of type <code>B</code>. This constraint is imposed to prevent ambiguity to the reader. Use the index based emplacement constructor instead to initialize the alternative of type <code>A</code>.</p>
<h2><a class="anchor" id="autotoc_md448"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, std::vector&lt;int&gt;</a>&gt; <a class="code hl_class" href="classsumty_1_1result.html">v</a>{</div>
<div class="line">        std::in_place_type&lt;std::vector&lt;int&gt;&gt;,</div>
<div class="line">        {1, 2, 3, 4, 5}};</div>
<div class="line"> </div>
<div class="line">assert(<a class="code hl_function" href="classsumty_1_1variant.html#a7d4ebf4f8a4bb3bccd7566476219bfa3">holds_alternative</a>&lt;std::vector&lt;int&gt;&gt;(v));</div>
<div class="line"> </div>
<div class="line">assert(v.index() == 1);</div>
<div class="line"> </div>
<div class="line">assert(get&lt;1&gt;(v).size() == 5);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a208fbd1bb90c81cfa04386b3b0413108" name="a208fbd1bb90c81cfa04386b3b0413108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208fbd1bb90c81cfa04386b3b0413108">&#9670;&#160;</a></span>variant() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1variant.html">variant</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">U</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwarding constructor. </p>
<p>A new <a class="el" href="classsumty_1_1variant.html">variant</a> is initialized such that an alternative is constructed in place with the provided value as the constructor argument.</p>
<p>To avoid ambiguity to the reader, this constructor only participates in overload resolution when there is only one alternative that could possibly be constructed from the value.</p>
<p>This constructor is <code>explicit</code> if the value is not implicitly convertible to the target alternative type.</p>
<p>This constructor should be avoided in generic code, because some <a class="el" href="classsumty_1_1variant.html">variant</a> instantiations will have distinct types while others will not. Prefer the emplacement constructors.</p>
<h2><a class="anchor" id="autotoc_md449"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;void, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.index() == 1);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 42);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value that is used to construct the alternative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a9623720145e83ee0bbc52bc1a2b8bd" name="a7a9623720145e83ee0bbc52bc1a2b8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9623720145e83ee0bbc52bc1a2b8bd">&#9670;&#160;</a></span>variant() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1variant.html">variant</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwarding constructor with initializer list. </p>
<p>A new <a class="el" href="classsumty_1_1variant.html">variant</a> is initialized such that an alternative is constructed in place with the provided <code>std::initializer_list</code> as the constructor argument.</p>
<p>To avoid ambiguity to the reader, this constructor only participates in overload resulotion when there is only one alternative that could possible be constructed from the initializer list.</p>
<p>This constructor is <code>explicit</code> if the <code>std::initializer_list</code> is not implicitly convertible to the target alternative type.</p>
<p>This constructor should be avoided in generic code, because some <a class="el" href="classsumty_1_1variant.html">variant</a> instantiations will have distinct types while others will not. Prefer the emplacement constructors.</p>
<h2><a class="anchor" id="autotoc_md450"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;void, std::vector&lt;int&gt;</a>&gt; <a class="code hl_class" href="classsumty_1_1result.html">v</a>({1, 2, 3, 4, 5});</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.index() == 1);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>).<a class="code hl_class" href="classsumty_1_1result.html">size</a>() == 5);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>The <code>std::initializer_list</code> that is used to construct the alternative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25170b8c12360697907375ef3473cb2e" name="a25170b8c12360697907375ef3473cb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25170b8c12360697907375ef3473cb2e">&#9670;&#160;</a></span>~variant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> ~<a class="el" href="classsumty_1_1variant.html">variant</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>The contained alternative of the <a class="el" href="classsumty_1_1variant.html">variant</a> will is destroyed in place.</p>
<p>The destructor is <code>noexcept</code> if all alternative types are nothrow destructible. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a51aa9c79ed9d904626ad89616ee4990f" name="a51aa9c79ed9d904626ad89616ee4990f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51aa9c79ed9d904626ad89616ee4990f">&#9670;&#160;</a></span>emplace() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new alternative in place by index. </p>
<p>This function destroys the alternative that the <a class="el" href="classsumty_1_1variant.html">variant</a> contains before the call, and constructs a new alternative with the specified index in place.</p>
<h2><a class="anchor" id="autotoc_md456"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>.<a class="code hl_function" href="classsumty_1_1result.html#a54263fe060a2027fef396d47ec9fc7ce">emplace</a>&lt;1&gt;(5, <span class="charliteral">&#39;a&#39;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">holds_alternative&lt;std::string&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.index() == 1);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == <span class="stringliteral">&quot;aaaaa&quot;</span>);</div>
<div class="ttc" id="aclasssumty_1_1result_html_a54263fe060a2027fef396d47ec9fc7ce"><div class="ttname"><a href="classsumty_1_1result.html#a54263fe060a2027fef396d47ec9fc7ce">sumty::result::emplace</a></div><div class="ttdeci">constexpr reference emplace(Args &amp;&amp;... args)</div><div class="ttdoc">Constructs a new ok value in place into the result.</div><div class="ttdef"><b>Definition</b> result.hpp:4545</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Constructor arguments forwarded to the new alternative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the new alternative, if applicable </dd></dl>

</div>
</div>
<a id="a51aa9c79ed9d904626ad89616ee4990f" name="a51aa9c79ed9d904626ad89616ee4990f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51aa9c79ed9d904626ad89616ee4990f">&#9670;&#160;</a></span>emplace() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new alternative in place by type. </p>
<p>This function destroy the alternative that the <a class="el" href="classsumty_1_1variant.html">variant</a> contains before the call, and constructs a new alternative with the specified type in place.</p>
<p>This function only participates in overload resolution if the type, <code>U</code>, is unique among all the alternative types of the <a class="el" href="classsumty_1_1variant.html">variant</a>. That is, <code>variant&lt;A, B, A&gt;</code> cannot use this function to emplace an alternative of type <code>A</code>, but it can use this function to emplace an alternative of type <code>B</code>.</p>
<h2><a class="anchor" id="autotoc_md458"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>.<a class="code hl_function" href="classsumty_1_1result.html#a54263fe060a2027fef396d47ec9fc7ce">emplace</a>&lt;std::string&gt;(5, <span class="charliteral">&#39;a&#39;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">holds_alternative&lt;std::string&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.index() == 1);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == <span class="stringliteral">&quot;aaaaa&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Constructor arguments forwarded to the new alternative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the new alternative, if applicable </dd></dl>

</div>
</div>
<a id="a4d75a701faaf7cda03a358a84acfe3ac" name="a4d75a701faaf7cda03a358a84acfe3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d75a701faaf7cda03a358a84acfe3ac">&#9670;&#160;</a></span>emplace() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> emplace </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new alternative in place by index. </p>
<p>This function destroys the alternative that the <a class="el" href="classsumty_1_1variant.html">variant</a> contains before the call, and constructs a new alternative with the specified index in place.</p>
<h2><a class="anchor" id="autotoc_md457"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, std::vector&lt;int&gt;</a>&gt; <a class="code hl_class" href="classsumty_1_1result.html">v</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>.<a class="code hl_function" href="classsumty_1_1result.html#a54263fe060a2027fef396d47ec9fc7ce">emplace</a>&lt;1&gt;({1, 2, 3, 4, 5});</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_function" href="classsumty_1_1variant.html#a7d4ebf4f8a4bb3bccd7566476219bfa3">holds_alternative</a>&lt;std::vector&lt;int&gt;&gt;(<a class="code hl_class" href="classsumty_1_1result.html">v</a>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.index() == 1);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>).<a class="code hl_class" href="classsumty_1_1result.html">size</a>() == 5);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>Initializer list forward to the new alternative </td></tr>
    <tr><td class="paramname">args</td><td>Constructor arguments forwarded to the new alternative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the new alternative, if applicable </dd></dl>

</div>
</div>
<a id="abe9de1c1c1f667f57155919abb7e79d6" name="abe9de1c1c1f667f57155919abb7e79d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9de1c1c1f667f57155919abb7e79d6">&#9670;&#160;</a></span>emplace() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> emplace </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">V</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new alternative in place by type. </p>
<p>This function destroy the alternative that the <a class="el" href="classsumty_1_1variant.html">variant</a> contains before the call, and constructs a new alternative with the specified type in place.</p>
<p>This function only participates in overload resolution if the type, <code>U</code>, is unique among all the alternative types of the <a class="el" href="classsumty_1_1variant.html">variant</a>. That is, <code>variant&lt;A, B, A&gt;</code> cannot use this function to emplace an alternative of type <code>A</code>, but it can use this function to emplace an alternative of type <code>B</code>.</p>
<h2><a class="anchor" id="autotoc_md459"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, std::vector&lt;int&gt;</a>&gt; <a class="code hl_class" href="classsumty_1_1result.html">v</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>.<a class="code hl_function" href="classsumty_1_1result.html#a54263fe060a2027fef396d47ec9fc7ce">emplace</a>&lt;std::vector&lt;int&gt;&gt;({1, 2, 3, 4, 5});</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_function" href="classsumty_1_1variant.html#a7d4ebf4f8a4bb3bccd7566476219bfa3">holds_alternative</a>&lt;std::vector&lt;int&gt;&gt;(<a class="code hl_class" href="classsumty_1_1result.html">v</a>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.index() == 1);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>).<a class="code hl_class" href="classsumty_1_1result.html">size</a>() == 5);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>Initializer list forward to the new alternative </td></tr>
    <tr><td class="paramname">args</td><td>Constructor arguments forwarded to the new alternative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the new alternative, if applicable </dd></dl>

</div>
</div>
<a id="a5bb0f2e97a687affd34d9ece8c9c59bc" name="a5bb0f2e97a687affd34d9ece8c9c59bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb0f2e97a687affd34d9ece8c9c59bc">&#9670;&#160;</a></span>get() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by index. </p>
<p>This function allows accessing alternatives by index, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md468"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;1&gt;() == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;1&gt;() = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
<div class="ttc" id="aclasssumty_1_1result_html_a3bdfc23d3431292af06fb30707025eef"><div class="ttname"><a href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">sumty::result::get</a></div><div class="ttdeci">constexpr REFERENCE get(result&lt; T, E &gt; &amp;res)</div><div class="ttdoc">Gets a result value by index, as if it were a variant.</div><div class="ttdef"><b>Definition</b> result.hpp:5109</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative with the corresponding index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bb0f2e97a687affd34d9ece8c9c59bc" name="a5bb0f2e97a687affd34d9ece8c9c59bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb0f2e97a687affd34d9ece8c9c59bc">&#9670;&#160;</a></span>get() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by type. </p>
<p>This function allows accessing alternatives by type, which is provided as a template argument.</p>
<p>This function only participates in overload resolution if the type is unique across all alternative types of the <a class="el" href="classsumty_1_1variant.html">variant</a>. That is, <code>variant&lt;A, B, A&gt;</code> cannot use this function to access an alternative of type <code>A</code>, but it can use this fucntion to access an alternative of type <code>B</code>.</p>
<h2><a class="anchor" id="autotoc_md472"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;<span class="keywordtype">int</span>&gt;() == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;<span class="keywordtype">int</span>&gt;() = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative with the corresponding type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66e0f8f4c60cc6726ce6571168835d89" name="a66e0f8f4c60cc6726ce6571168835d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e0f8f4c60cc6726ce6571168835d89">&#9670;&#160;</a></span>get() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by index. </p>
<p>This function allows accessing alternatives by index, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md470"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;1&gt;() == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;1&gt;() = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The accessed alternative value, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative with the corresponding index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66e0f8f4c60cc6726ce6571168835d89" name="a66e0f8f4c60cc6726ce6571168835d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e0f8f4c60cc6726ce6571168835d89">&#9670;&#160;</a></span>get() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by type. </p>
<p>This function allows accessing alternatives by type, which is provided as a template argument.</p>
<p>This function only participates in overload resolution if the type is unique across all alternative types of the <a class="el" href="classsumty_1_1variant.html">variant</a>. That is, <code>variant&lt;A, B, A&gt;</code> cannot use this function to access an alternative of type <code>A</code>, but it can use this fucntion to access an alternative of type <code>B</code>.</p>
<h2><a class="anchor" id="autotoc_md474"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;<span class="keywordtype">int</span>&gt;() == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;<span class="keywordtype">int</span>&gt;() = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The accessed alternative value, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative with the corresponding type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25cce71efb47892db3403e54fef6072e" name="a25cce71efb47892db3403e54fef6072e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cce71efb47892db3403e54fef6072e">&#9670;&#160;</a></span>get() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by index. </p>
<p>This function allows accessing alternatives by index, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md469"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;1&gt;() == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;1&gt;() = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative with the corresponding index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25cce71efb47892db3403e54fef6072e" name="a25cce71efb47892db3403e54fef6072e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cce71efb47892db3403e54fef6072e">&#9670;&#160;</a></span>get() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by type. </p>
<p>This function allows accessing alternatives by type, which is provided as a template argument.</p>
<p>This function only participates in overload resolution if the type is unique across all alternative types of the <a class="el" href="classsumty_1_1variant.html">variant</a>. That is, <code>variant&lt;A, B, A&gt;</code> cannot use this function to access an alternative of type <code>A</code>, but it can use this fucntion to access an alternative of type <code>B</code>.</p>
<h2><a class="anchor" id="autotoc_md473"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;<span class="keywordtype">int</span>&gt;() == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;<span class="keywordtype">int</span>&gt;() = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative with the corresponding type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfcc32bc6f1d424bb8041401437cd401" name="acfcc32bc6f1d424bb8041401437cd401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcc32bc6f1d424bb8041401437cd401">&#9670;&#160;</a></span>get() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by index. </p>
<p>This function allows accessing alternatives by index, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md471"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;1&gt;() == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;1&gt;() = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The accessed alternative value, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative with the corresponding index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfcc32bc6f1d424bb8041401437cd401" name="acfcc32bc6f1d424bb8041401437cd401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcc32bc6f1d424bb8041401437cd401">&#9670;&#160;</a></span>get() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by type. </p>
<p>This function allows accessing alternatives by type, which is provided as a template argument.</p>
<p>This function only participates in overload resolution if the type is unique across all alternative types of the <a class="el" href="classsumty_1_1variant.html">variant</a>. That is, <code>variant&lt;A, B, A&gt;</code> cannot use this function to access an alternative of type <code>A</code>, but it can use this fucntion to access an alternative of type <code>B</code>.</p>
<h2><a class="anchor" id="autotoc_md475"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;<span class="keywordtype">int</span>&gt;() == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;<span class="keywordtype">int</span>&gt;() = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The accessed alternative value, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative with the corresponding type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a265bae72c738f8886a40d3fcb358e70d" name="a265bae72c738f8886a40d3fcb358e70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265bae72c738f8886a40d3fcb358e70d">&#9670;&#160;</a></span>get_if() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_POINTER</a> get_if </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative pointer by index if the <a class="el" href="classsumty_1_1variant.html">variant</a> holds it. </p>
<p>This functions tries to access an alternative by index. If the <a class="el" href="classsumty_1_1variant.html">variant</a> contains the alternative, this function returns a pointer to the alternative, if applicable. If the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative, this function returns null. In the case where the alternative is of type <code>void</code>, this function does nothing.</p>
<h2><a class="anchor" id="autotoc_md477"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">v</a>.get_if&lt;1&gt;() == 42);</div>
<div class="line"> </div>
<div class="line">*<a class="code hl_class" href="classsumty_1_1result.html">v</a>.get_if&lt;1&gt;() = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">v</a>.get_if&lt;1&gt;() == 24);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.get_if&lt;0&gt;() == <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the accessed alternative, if applicable, or null </dd></dl>

</div>
</div>
<a id="a265bae72c738f8886a40d3fcb358e70d" name="a265bae72c738f8886a40d3fcb358e70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265bae72c738f8886a40d3fcb358e70d">&#9670;&#160;</a></span>get_if() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_POINTER</a> get_if </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative pointer by type if the <a class="el" href="classsumty_1_1variant.html">variant</a> holds it. </p>
<p>This functions tries to access an alternative by type. If the <a class="el" href="classsumty_1_1variant.html">variant</a> contains the alternative, this function returns a pointer to the alternative, if applicable. If the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative, this function returns null. In the case where the alternative is of type <code>void</code>, this function does nothing.</p>
<p>This function only participates in overload resolution if the type is unique across all alternative types of the <a class="el" href="classsumty_1_1variant.html">variant</a>. That is, <code>variant&lt;A, B, A&gt;</code> cannot use this function to access an alternative of type <code>A</code>, but it can use this fucntion to access an alternative of type <code>B</code>.</p>
<h2><a class="anchor" id="autotoc_md479"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">v</a>.get_if&lt;<span class="keywordtype">int</span>&gt;() == 42);</div>
<div class="line"> </div>
<div class="line">*<a class="code hl_class" href="classsumty_1_1result.html">v</a>.get_if&lt;<span class="keywordtype">int</span>&gt;() = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">v</a>.get_if&lt;<span class="keywordtype">int</span>&gt;() == 24);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.get_if&lt;<span class="keywordtype">bool</span>&gt;() == <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the accessed alternative, if applicable, or null </dd></dl>

</div>
</div>
<a id="a58b10b57fcb769be2c692a4b6df452ab" name="a58b10b57fcb769be2c692a4b6df452ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b10b57fcb769be2c692a4b6df452ab">&#9670;&#160;</a></span>get_if() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">POINTER</a> get_if </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative pointer by index if the <a class="el" href="classsumty_1_1variant.html">variant</a> holds it. </p>
<p>This functions tries to access an alternative by index. If the <a class="el" href="classsumty_1_1variant.html">variant</a> contains the alternative, this function returns a pointer to the alternative, if applicable. If the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative, this function returns null. In the case where the alternative is of type <code>void</code>, this function does nothing.</p>
<h2><a class="anchor" id="autotoc_md476"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">v</a>.get_if&lt;1&gt;() == 42);</div>
<div class="line"> </div>
<div class="line">*<a class="code hl_class" href="classsumty_1_1result.html">v</a>.get_if&lt;1&gt;() = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">v</a>.get_if&lt;1&gt;() == 24);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.get_if&lt;0&gt;() == <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the accessed alternative, if applicable, or null </dd></dl>

</div>
</div>
<a id="a58b10b57fcb769be2c692a4b6df452ab" name="a58b10b57fcb769be2c692a4b6df452ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b10b57fcb769be2c692a4b6df452ab">&#9670;&#160;</a></span>get_if() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">POINTER</a> get_if </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative pointer by type if the <a class="el" href="classsumty_1_1variant.html">variant</a> holds it. </p>
<p>This functions tries to access an alternative by type. If the <a class="el" href="classsumty_1_1variant.html">variant</a> contains the alternative, this function returns a pointer to the alternative, if applicable. If the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative, this function returns null. In the case where the alternative is of type <code>void</code>, this function does nothing.</p>
<p>This function only participates in overload resolution if the type is unique across all alternative types of the <a class="el" href="classsumty_1_1variant.html">variant</a>. That is, <code>variant&lt;A, B, A&gt;</code> cannot use this function to access an alternative of type <code>A</code>, but it can use this fucntion to access an alternative of type <code>B</code>.</p>
<h2><a class="anchor" id="autotoc_md478"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">v</a>.get_if&lt;<span class="keywordtype">int</span>&gt;() == 42);</div>
<div class="line"> </div>
<div class="line">*<a class="code hl_class" href="classsumty_1_1result.html">v</a>.get_if&lt;<span class="keywordtype">int</span>&gt;() = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">v</a>.get_if&lt;<span class="keywordtype">int</span>&gt;() == 24);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.get_if&lt;<span class="keywordtype">bool</span>&gt;() == <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the accessed alternative, if applicable, or null </dd></dl>

</div>
</div>
<a id="a7d4ebf4f8a4bb3bccd7566476219bfa3" name="a7d4ebf4f8a4bb3bccd7566476219bfa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4ebf4f8a4bb3bccd7566476219bfa3">&#9670;&#160;</a></span>holds_alternative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a> holds_alternative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a <a class="el" href="classsumty_1_1variant.html">variant</a> contains a particular alternative. </p>
<p>Given a type parameter, this function checks if the <a class="el" href="classsumty_1_1variant.html">variant</a> currently holds an alternative that has the exact same type.</p>
<h2><a class="anchor" id="autotoc_md480"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, bool, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v1</a>{std::in_place_index&lt;0&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v1</a>.holds_alternative&lt;<span class="keywordtype">int</span>&gt;());</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, bool, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v2</a>{std::in_place_index&lt;2&gt;, 42};</div>
<div class="line"> </div>
<div class="line">assert(v2.holds_alternative&lt;<span class="keywordtype">int</span>&gt;());</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classsumty_1_1variant.html">variant</a> holds an alternative of the given type. </dd></dl>

</div>
</div>
<a id="ae16ab6b77ec8c07ce9c5e558de5cd82b" name="ae16ab6b77ec8c07ce9c5e558de5cd82b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16ab6b77ec8c07ce9c5e558de5cd82b">&#9670;&#160;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">size_t</a> index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the index of the contained alternative. </p>
<p>The set of alternatives of a <a class="el" href="classsumty_1_1variant.html">variant</a> has a zero-based index based on the order in which they are specified in the <a class="el" href="classsumty_1_1variant.html">variant</a> template arguments.</p>
<p>This index is the normalized discriminant of the <a class="el" href="classsumty_1_1variant.html">variant</a>. The discriminant may be represented differently internally, depending on the alternative types, so this function normalizes the discriminant by converting it to a zero-based index in order to provide a common interface for all <a class="el" href="classsumty_1_1variant.html">variant</a> instantiations.</p>
<h2><a class="anchor" id="autotoc_md455"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, bool, float&amp;, std::string, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{</div>
<div class="line">        std::in_place_index&lt;3&gt;, <span class="stringliteral">&quot;hello&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.index() == 3);</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The index of the contained alternative. </dd></dl>

</div>
</div>
<a id="a42d754384322f67c2e60c186cade74c2" name="a42d754384322f67c2e60c186cade74c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d754384322f67c2e60c186cade74c2">&#9670;&#160;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1variant.html">variant</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>Copy assignment of a <a class="el" href="classsumty_1_1variant.html">variant</a> can take one of two possible code paths.</p>
<p>If the source and destination <a class="el" href="classsumty_1_1variant.html">variant</a> hold the same alternative (same index), the alternative value is copied via copy assignment.</p>
<p>Otherwise, if the source and destination hold different alternatives (different indices, but possibly the same type), the alternative of the destination <a class="el" href="classsumty_1_1variant.html">variant</a> is destroyed in place, and the new alternative is copy constructed.</p>
<p>All alternatives <em>must</em> be both copy assignable and copy constructible for this function to participate in overload resolution.</p>
<h2><a class="anchor" id="autotoc_md451"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, bool&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v1</a>{std::in_place_index&lt;0&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, bool&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v2</a>{std::in_place_index&lt;1&gt;, <span class="keyword">true</span>};</div>
<div class="line"> </div>
<div class="line">v1 = v2;</div>
<div class="line"> </div>
<div class="line">assert(holds_alternative&lt;bool&gt;(v1));</div>
<div class="line"> </div>
<div class="line">assert(v1.index() == 1);</div>
<div class="line"> </div>
<div class="line">assert(get&lt;1&gt;(v1) == <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7eaebd4a61a16c8f222eecae4bfdc9ca" name="a7eaebd4a61a16c8f222eecae4bfdc9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eaebd4a61a16c8f222eecae4bfdc9ca">&#9670;&#160;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1variant.html">variant</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwarding assignment operator with initializer list. </p>
<p>This function assigns a <code>std::initializer_list</code> directoy to an alternative. If the <a class="el" href="classsumty_1_1variant.html">variant</a> already contains the target alternative, the <code>std::initializer_list</code> is assigned uting the alternative type's assignment operator. Otherwise, the target alternative is constructed with the <code>std::initializer_list</code>.</p>
<p>To avoid ambiguity to the reader, this function only participates in overload resolution when there is only one alternative that could possibly be assigned from the <code>std::initializer_list</code>.</p>
<p>This opreator should be avoided in generic code, because some <a class="el" href="classsumty_1_1variant.html">variant</a> instantiations will have distinct types while others will not.</p>
<h2><a class="anchor" id="autotoc_md454"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;void, std::vector&lt;int&gt;</a>&gt; <a class="code hl_class" href="classsumty_1_1result.html">v</a>{};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a> = {1, 2, 3, 4, 5};</div>
<div class="line"> </div>
<div class="line">assert(v.index() == 1);</div>
<div class="line"> </div>
<div class="line">assert(get&lt;1&gt;(v).size() == 5);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The <code>std::initializer_list</code> to be assigned to the alternative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a783ed86ae62c0aacfdb49ecbfa78ad85" name="a783ed86ae62c0aacfdb49ecbfa78ad85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783ed86ae62c0aacfdb49ecbfa78ad85">&#9670;&#160;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1variant.html">variant</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">U</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwarding assignment operator. </p>
<p>This function assigns a value directly to an alternative. If the <a class="el" href="classsumty_1_1variant.html">variant</a> already contains the target alternative, the value is assigned using the alternative type's assignemnt operator. Otherwise, the target alternative is constructed with the value.</p>
<p>To avoid ambiguity to the reader, this function only participates in overload resolution when there is only one alternative that could possibly be assigned from the value.</p>
<p>This operator should be avoided in generic code, because some <a class="el" href="classsumty_1_1variant.html">variant</a> instantiations will have distinct types while others will not.</p>
<h2><a class="anchor" id="autotoc_md453"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;void, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a> = 42;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>.index() == 1);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 42);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The value to be assigned to the alternative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1e42c25246108ccd1829706ca0b3e23" name="af1e42c25246108ccd1829706ca0b3e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e42c25246108ccd1829706ca0b3e23">&#9670;&#160;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1variant.html">variant</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<p>Move assignment of a <a class="el" href="classsumty_1_1variant.html">variant</a> can take one of two possible code paths.</p>
<p>If the source and destination <a class="el" href="classsumty_1_1variant.html">variant</a> hold the same alternative (same index), the alternative value is moved from the source to the destination via move assignment.</p>
<p>Otherwise, if the source and destination hold different alternatives (different indices, but possibly the same type), the alternative of the destination <a class="el" href="classsumty_1_1variant.html">variant</a> is destroyed in place, and the new alternative is move constructed.</p>
<p>The source <a class="el" href="classsumty_1_1variant.html">variant</a> will still contain the same alternative, but the value of the alternative depends on the move assignment or move constructor of the alternative's type. In general, moved values are said to be in a valid, but unspecified, state.</p>
<p>All alternatives <em>must</em> be both move assignable and move constructible for this function to participate in overload resolution.</p>
<h2><a class="anchor" id="autotoc_md452"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, bool&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v1</a>{std::in_place_index&lt;0&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, bool&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v2</a>{std::in_place_index&lt;1&gt;, <span class="keyword">true</span>};</div>
<div class="line"> </div>
<div class="line">v1 = std::move(v2);</div>
<div class="line"> </div>
<div class="line">assert(holds_alternative&lt;bool&gt;(v1));</div>
<div class="line"> </div>
<div class="line">assert(v1.index() == 1);</div>
<div class="line"> </div>
<div class="line">assert(get&lt;1&gt;(v1) == <span class="keyword">true</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7d78cf19fadfc52be6fc46b972746912" name="a7d78cf19fadfc52be6fc46b972746912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d78cf19fadfc52be6fc46b972746912">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a> operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsumty_1_1index__t.html">index_t</a>&lt; <a class="el" href="classsumty_1_1result.html">I</a> &gt;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternative access operator by index. </p>
<p>This function allows accessing alternatives by index using the square bracket operator. Because the index must be a compile time value, instead of passing the index directly, the index is provided as an instance of <a class="el" href="structsumty_1_1index__t.html">index_t</a>.</p>
<p>This operator is unchecked and does not throw an exception. Passing an index that does not correspond to the currently contained alternative results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md462"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>[<a class="code hl_class" href="classsumty_1_1result.html">index&lt;1&gt;</a>] == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>[<a class="code hl_class" href="classsumty_1_1result.html">index&lt;1&gt;</a>] = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A tag value that communicates a compile time index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The accessed alternative value, if applicable </dd></dl>

</div>
</div>
<a id="aff2d2b17eb46b78620e923b1b58a1899" name="aff2d2b17eb46b78620e923b1b58a1899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2d2b17eb46b78620e923b1b58a1899">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsumty_1_1index__t.html">index_t</a>&lt; <a class="el" href="classsumty_1_1result.html">I</a> &gt;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternative access operator by index. </p>
<p>This function allows accessing alternatives by index using the square bracket operator. Because the index must be a compile time value, instead of passing the index directly, the index is provided as an instance of <a class="el" href="structsumty_1_1index__t.html">index_t</a>.</p>
<p>This operator is unchecked and does not throw an exception. Passing an index that does not correspond to the currently contained alternative results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md460"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>[<a class="code hl_class" href="classsumty_1_1result.html">index&lt;1&gt;</a>] == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>[<a class="code hl_class" href="classsumty_1_1result.html">index&lt;1&gt;</a>] = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A tag value that communicates a compile time index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed alternative, if applicable </dd></dl>

</div>
</div>
<a id="a015017e598c8340b3be3481a5ef7d1f8" name="a015017e598c8340b3be3481a5ef7d1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015017e598c8340b3be3481a5ef7d1f8">&#9670;&#160;</a></span>operator[]() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a> operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsumty_1_1index__t.html">index_t</a>&lt; <a class="el" href="classsumty_1_1result.html">I</a> &gt;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternative access operator by index. </p>
<p>This function allows accessing alternatives by index using the square bracket operator. Because the index must be a compile time value, instead of passing the index directly, the index is provided as an instance of <a class="el" href="structsumty_1_1index__t.html">index_t</a>.</p>
<p>This operator is unchecked and does not throw an exception. Passing an index that does not correspond to the currently contained alternative results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md463"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>[<a class="code hl_class" href="classsumty_1_1result.html">index&lt;1&gt;</a>] == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>[<a class="code hl_class" href="classsumty_1_1result.html">index&lt;1&gt;</a>] = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A tag value that communicates a compile time index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The accessed alternative value, if applicable </dd></dl>

</div>
</div>
<a id="a4acc04a3c20910caf473d04e3df96dac" name="a4acc04a3c20910caf473d04e3df96dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4acc04a3c20910caf473d04e3df96dac">&#9670;&#160;</a></span>operator[]() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a> operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsumty_1_1index__t.html">index_t</a>&lt; <a class="el" href="classsumty_1_1result.html">I</a> &gt;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternative access operator by index. </p>
<p>This function allows accessing alternatives by index using the square bracket operator. Because the index must be a compile time value, instead of passing the index directly, the index is provided as an instance of <a class="el" href="structsumty_1_1index__t.html">index_t</a>.</p>
<p>This operator is unchecked and does not throw an exception. Passing an index that does not correspond to the currently contained alternative results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md461"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>[<a class="code hl_class" href="classsumty_1_1result.html">index&lt;1&gt;</a>] == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>[<a class="code hl_class" href="classsumty_1_1result.html">index&lt;1&gt;</a>] = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A tag value that communicates a compile time index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed alternative, if applicable </dd></dl>

</div>
</div>
<a id="a65ba2eeeab7db3966934aafe7db79735" name="a65ba2eeeab7db3966934aafe7db79735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ba2eeeab7db3966934aafe7db79735">&#9670;&#160;</a></span>operator[]() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a> operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsumty_1_1type__t.html">type_t</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternative access operator by type. </p>
<p>This function allows accessing alternatives by type using the square bracket operator. Because the type must be a compile time value, the type is provided as an instance of <a class="el" href="structsumty_1_1type__t.html">type_t</a>.</p>
<p>This operator is unchecked and does not throw an exception. Passing a type that does not correspond to the currently contained alternative results in undefined behavior.</p>
<p>This function only participates in overload resolution if the type is unique across all alternative types of the <a class="el" href="classsumty_1_1variant.html">variant</a>. That is, <code>variant&lt;A, B, A&gt;</code> cannot use this function to access an alternative of type <code>A</code>, but it can use this fucntion to access an alternative of type <code>B</code>.</p>
<h2><a class="anchor" id="autotoc_md466"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_type&lt;int&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>[<a class="code hl_class" href="classsumty_1_1result.html">type&lt;int&gt;</a>] == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>[<a class="code hl_class" href="classsumty_1_1result.html">type&lt;int&gt;</a>] = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A tag value that communicates a compile time index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The accessed alternative value, if applicable </dd></dl>

</div>
</div>
<a id="abe93f72a909cf965adbf3fc1c3b73e6b" name="abe93f72a909cf965adbf3fc1c3b73e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe93f72a909cf965adbf3fc1c3b73e6b">&#9670;&#160;</a></span>operator[]() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsumty_1_1type__t.html">type_t</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternative access operator by type. </p>
<p>This function allows accessing alternatives by type using the square bracket operator. Because the type must be a compile time value, the type is provided as an instance of <a class="el" href="structsumty_1_1type__t.html">type_t</a>.</p>
<p>This operator is unchecked and does not throw an exception. Passing a type that does not correspond to the currently contained alternative results in undefined behavior.</p>
<p>This function only participates in overload resolution if the type is unique across all alternative types of the <a class="el" href="classsumty_1_1variant.html">variant</a>. That is, <code>variant&lt;A, B, A&gt;</code> cannot use this function to access an alternative of type <code>A</code>, but it can use this fucntion to access an alternative of type <code>B</code>.</p>
<h2><a class="anchor" id="autotoc_md464"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_type&lt;int&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>[<a class="code hl_class" href="classsumty_1_1result.html">type&lt;int&gt;</a>] == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>[<a class="code hl_class" href="classsumty_1_1result.html">type&lt;int&gt;</a>] = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A tag value that communicates a compile time index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed alternative, if applicable </dd></dl>

</div>
</div>
<a id="a5d9e8b0aad003da2ccef9e62f8133ad0" name="a5d9e8b0aad003da2ccef9e62f8133ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9e8b0aad003da2ccef9e62f8133ad0">&#9670;&#160;</a></span>operator[]() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a> operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsumty_1_1type__t.html">type_t</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternative access operator by type. </p>
<p>This function allows accessing alternatives by type using the square bracket operator. Because the type must be a compile time value, the type is provided as an instance of <a class="el" href="structsumty_1_1type__t.html">type_t</a>.</p>
<p>This operator is unchecked and does not throw an exception. Passing a type that does not correspond to the currently contained alternative results in undefined behavior.</p>
<p>This function only participates in overload resolution if the type is unique across all alternative types of the <a class="el" href="classsumty_1_1variant.html">variant</a>. That is, <code>variant&lt;A, B, A&gt;</code> cannot use this function to access an alternative of type <code>A</code>, but it can use this fucntion to access an alternative of type <code>B</code>.</p>
<h2><a class="anchor" id="autotoc_md467"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_type&lt;int&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>[<a class="code hl_class" href="classsumty_1_1result.html">type&lt;int&gt;</a>] == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>[<a class="code hl_class" href="classsumty_1_1result.html">type&lt;int&gt;</a>] = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A tag value that communicates a compile time index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The accessed alternative value, if applicable </dd></dl>

</div>
</div>
<a id="a7947e07a7b41fa6276746a4244a4923a" name="a7947e07a7b41fa6276746a4244a4923a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7947e07a7b41fa6276746a4244a4923a">&#9670;&#160;</a></span>operator[]() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a> operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsumty_1_1type__t.html">type_t</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternative access operator by type. </p>
<p>This function allows accessing alternatives by type using the square bracket operator. Because the type must be a compile time value, the type is provided as an instance of <a class="el" href="structsumty_1_1type__t.html">type_t</a>.</p>
<p>This operator is unchecked and does not throw an exception. Passing a type that does not correspond to the currently contained alternative results in undefined behavior.</p>
<p>This function only participates in overload resolution if the type is unique across all alternative types of the <a class="el" href="classsumty_1_1variant.html">variant</a>. That is, <code>variant&lt;A, B, A&gt;</code> cannot use this function to access an alternative of type <code>A</code>, but it can use this fucntion to access an alternative of type <code>B</code>.</p>
<h2><a class="anchor" id="autotoc_md465"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_type&lt;int&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>[<a class="code hl_class" href="classsumty_1_1result.html">type&lt;int&gt;</a>] == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>[<a class="code hl_class" href="classsumty_1_1result.html">type&lt;int&gt;</a>] = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A tag value that communicates a compile time index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed alternative, if applicable </dd></dl>

</div>
</div>
<a id="a3e13a6bbf81b8927f418e5e9197ce67c" name="a3e13a6bbf81b8927f418e5e9197ce67c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e13a6bbf81b8927f418e5e9197ce67c">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">void</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two <a class="el" href="classsumty_1_1variant.html">variant</a> instances. </p>
<p>If the two <a class="el" href="classsumty_1_1variant.html">variant</a> instances contain the same alternative, the alternative values are swapped directly. Otherwise, the alternatives are swapped by moving out of the variants, destroying the old alternatives, and move constructed into the new alternatives.</p>
<h2><a class="anchor" id="autotoc_md489"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v1</a>{std::in_place_index&lt;0&gt;, <span class="keyword">true</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v2</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line">v1.<a class="code hl_function" href="classsumty_1_1result.html#a9a3be55eeb914e44478166807b43eef9">swap</a>(v2);</div>
<div class="line"> </div>
<div class="line">assert(v1.index() == 1);</div>
<div class="line"> </div>
<div class="line">assert(get&lt;1&gt;(v1) == 42);</div>
<div class="line"> </div>
<div class="line">assert(v2.index() == 0);</div>
<div class="line"> </div>
<div class="line">assert(get&lt;2&gt;(v2) == <span class="keyword">true</span>);</div>
<div class="ttc" id="aclasssumty_1_1result_html_a9a3be55eeb914e44478166807b43eef9"><div class="ttname"><a href="classsumty_1_1result.html#a9a3be55eeb914e44478166807b43eef9">sumty::result::swap</a></div><div class="ttdeci">constexpr void swap(result &amp;other) CONDITIONALLY_NOEXCEPT</div><div class="ttdoc">Swaps two result instances.</div><div class="ttdef"><b>Definition</b> result.hpp:5066</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The "other" <a class="el" href="classsumty_1_1variant.html">variant</a> to swap with this <a class="el" href="classsumty_1_1variant.html">variant</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2f575e3e78ea2171d1be475f7f9a2d8" name="ae2f575e3e78ea2171d1be475f7f9a2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f575e3e78ea2171d1be475f7f9a2d8">&#9670;&#160;</a></span>visit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a visitor callable with the contained alternative. </p>
<p>This function calls the visitor as <code>std::invoke(visitor, alternative)</code> and returns the result of that call, if any. As such, <code>visitor</code> <em>must</em> be able to accecpt any alternative type as an argument. In the case of an alternative of type <code>void</code>, the visitor must be callable as <code>std::invoke(visitor, void_v)</code>.</p>
<p>Note that the overload function can be helpful for defining a visitor inline.</p>
<p>Also note that this function is implemented as a compile-time-defined jump table (array of function pointers). In performance critical applications, be wary of any assumptions about how well or poorly your compiler will optimize a call to this function.</p>
<h2><a class="anchor" id="autotoc_md481"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v1</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v1</a>.<a class="code hl_function" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>(overload(</div>
<div class="line">    [](<span class="keywordtype">bool</span> <a class="code hl_class" href="classsumty_1_1result.html">bool_value</a>) { <a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">false</span>); },</div>
<div class="line">    [](<span class="keywordtype">int</span> int_value) { assert(int_value == 42); },</div>
<div class="line">    [](void_t void_value) { assert(<span class="keyword">false</span>); }</div>
<div class="line">));</div>
<div class="ttc" id="aclasssumty_1_1result_html_ae2f575e3e78ea2171d1be475f7f9a2d8"><div class="ttname"><a href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">sumty::result::visit</a></div><div class="ttdeci">constexpr DEDUCED visit(V &amp;&amp;visitor) &amp;</div><div class="ttdoc">Invokes a visitor witht he contained value.</div><div class="ttdef"><b>Definition</b> result.hpp:4664</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The callable object that will be passed an alternative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the visitor, if any. </dd></dl>

</div>
</div>
<a id="adaaf65bdef1581aff9bda2ed4174143d" name="adaaf65bdef1581aff9bda2ed4174143d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaaf65bdef1581aff9bda2ed4174143d">&#9670;&#160;</a></span>visit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a visitor callable with the contained alternative. </p>
<p>This function calls the visitor as <code>std::invoke(visitor, alternative)</code> and returns the result of that call, if any. As such, <code>visitor</code> <em>must</em> be able to accecpt any alternative type as an argument. In the case of an alternative of type <code>void</code>, the visitor must be callable as <code>std::invoke(visitor, void_v)</code>.</p>
<p>Note that the overload function can be helpful for defining a visitor inline.</p>
<p>Also note that this function is implemented as a compile-time-defined jump table (array of function pointers). In performance critical applications, be wary of any assumptions about how well or poorly your compiler will optimize a call to this function.</p>
<h2><a class="anchor" id="autotoc_md483"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v1</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v1</a>.<a class="code hl_function" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>(overload(</div>
<div class="line">    [](<span class="keywordtype">bool</span> <a class="code hl_class" href="classsumty_1_1result.html">bool_value</a>) { <a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">false</span>); },</div>
<div class="line">    [](<span class="keywordtype">int</span> int_value) { assert(int_value == 42); },</div>
<div class="line">    [](void_t void_value) { assert(<span class="keyword">false</span>); }</div>
<div class="line">));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The callable object that will be passed an alternative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the visitor, if any. </dd></dl>

</div>
</div>
<a id="aeeca86cd9abb551e0c1e52ba81289f29" name="aeeca86cd9abb551e0c1e52ba81289f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeca86cd9abb551e0c1e52ba81289f29">&#9670;&#160;</a></span>visit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a visitor callable with the contained alternative. </p>
<p>This function calls the visitor as <code>std::invoke(visitor, alternative)</code> and returns the result of that call, if any. As such, <code>visitor</code> <em>must</em> be able to accecpt any alternative type as an argument. In the case of an alternative of type <code>void</code>, the visitor must be callable as <code>std::invoke(visitor, void_v)</code>.</p>
<p>Note that the overload function can be helpful for defining a visitor inline.</p>
<p>Also note that this function is implemented as a compile-time-defined jump table (array of function pointers). In performance critical applications, be wary of any assumptions about how well or poorly your compiler will optimize a call to this function.</p>
<h2><a class="anchor" id="autotoc_md482"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v1</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v1</a>.<a class="code hl_function" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>(overload(</div>
<div class="line">    [](<span class="keywordtype">bool</span> <a class="code hl_class" href="classsumty_1_1result.html">bool_value</a>) { <a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">false</span>); },</div>
<div class="line">    [](<span class="keywordtype">int</span> int_value) { assert(int_value == 42); },</div>
<div class="line">    [](void_t void_value) { assert(<span class="keyword">false</span>); }</div>
<div class="line">));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The callable object that will be passed an alternative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the visitor, if any. </dd></dl>

</div>
</div>
<a id="a12b9d6a30c96d7caac920ce264c66de1" name="a12b9d6a30c96d7caac920ce264c66de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b9d6a30c96d7caac920ce264c66de1">&#9670;&#160;</a></span>visit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a visitor callable with the contained alternative. </p>
<p>This function calls the visitor as <code>std::invoke(visitor, alternative)</code> and returns the result of that call, if any. As such, <code>visitor</code> <em>must</em> be able to accecpt any alternative type as an argument. In the case of an alternative of type <code>void</code>, the visitor must be callable as <code>std::invoke(visitor, void_v)</code>.</p>
<p>Note that the overload function can be helpful for defining a visitor inline.</p>
<p>Also note that this function is implemented as a compile-time-defined jump table (array of function pointers). In performance critical applications, be wary of any assumptions about how well or poorly your compiler will optimize a call to this function.</p>
<h2><a class="anchor" id="autotoc_md484"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v1</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v1</a>.<a class="code hl_function" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>(overload(</div>
<div class="line">    [](<span class="keywordtype">bool</span> <a class="code hl_class" href="classsumty_1_1result.html">bool_value</a>) { <a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">false</span>); },</div>
<div class="line">    [](<span class="keywordtype">int</span> int_value) { assert(int_value == 42); },</div>
<div class="line">    [](void_t void_value) { assert(<span class="keyword">false</span>); }</div>
<div class="line">));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The callable object that will be passed an alternative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the visitor, if any. </dd></dl>

</div>
</div>
<a id="a1656bb14f0a45ec7cfa81bb960acf924" name="a1656bb14f0a45ec7cfa81bb960acf924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1656bb14f0a45ec7cfa81bb960acf924">&#9670;&#160;</a></span>visit_informed() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit_informed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a visitor callable with the contained alternative and metadata. </p>
<p>This function calls the visitor as <code>std::invoke(visitor, alternative, info)</code>, and returns the result of that call, if any. As such, <code>visitor</code> <em>must</em> be able to accept any alternative type as an argument. In the case of an alternative of type <code>void</code>, the visitor must be callable as <code>std::invoke(visitor, void_v, info)</code>.</p>
<p>The <code>info</code> argument passed to the visitor, which differentiates this function from <code>.visit(...)</code>, communicates <code>constexpr</code> information about the alternative being visited. The type of the <code>info</code> object is not meant to be named, but it has the API shown below. Note that <code>info</code> is always an empty type.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>alternative_info {</div>
<div class="line">    <span class="comment">// index of the alternative in the source variant</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> index = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// type of the alternative as declared in the source variant</span></div>
<div class="line">    <span class="keyword">using </span>type = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// helper function for forwarding non-const alternative values</span></div>
<div class="line">    <span class="comment">// without needing to provide a template argument.</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) forward(...);</div>
<div class="line">};</div>
</div><!-- fragment --><p>Note that the overload function can be helpful for defining a visitor inline.</p>
<p>Also note that this function is implemented as a compile-time-defined jump table (array of function pointers). In performance critical applications, be wary of any assumptions about how well or poorly your compiler will optimize a call to this function.</p>
<h2><a class="anchor" id="autotoc_md485"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v1</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v1</a>.<a class="code hl_function" href="classsumty_1_1result.html#a1656bb14f0a45ec7cfa81bb960acf924">visit_informed</a>([](<span class="keyword">auto</span> value, <span class="keyword">auto</span> <a class="code hl_class" href="classsumty_1_1result.html">info</a>) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<a class="code hl_class" href="classsumty_1_1result.html">info</a>.index == 0) {</div>
<div class="line">        <a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">false</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 1) {</div>
<div class="line">        assert(value == 42);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 2) {</div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="ttc" id="aclasssumty_1_1result_html_a1656bb14f0a45ec7cfa81bb960acf924"><div class="ttname"><a href="classsumty_1_1result.html#a1656bb14f0a45ec7cfa81bb960acf924">sumty::result::visit_informed</a></div><div class="ttdeci">constexpr DEDUCED visit_informed(V &amp;&amp;visitor) &amp;</div><div class="ttdoc">Invokes a visitor with the contained value and meta data.</div><div class="ttdef"><b>Definition</b> result.hpp:4848</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The callable object that will be passed an alternative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the visitor, if any. </dd></dl>

</div>
</div>
<a id="a2b181b22d126a38b86f5a93035b6b7bc" name="a2b181b22d126a38b86f5a93035b6b7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b181b22d126a38b86f5a93035b6b7bc">&#9670;&#160;</a></span>visit_informed() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit_informed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a visitor callable with the contained alternative and metadata. </p>
<p>This function calls the visitor as <code>std::invoke(visitor, alternative, info)</code>, and returns the result of that call, if any. As such, <code>visitor</code> <em>must</em> be able to accept any alternative type as an argument. In the case of an alternative of type <code>void</code>, the visitor must be callable as <code>std::invoke(visitor, void_v, info)</code>.</p>
<p>The <code>info</code> argument passed to the visitor, which differentiates this function from <code>.visit(...)</code>, communicates <code>constexpr</code> information about the alternative being visited. The type of the <code>info</code> object is not meant to be named, but it has the API shown below. Note that <code>info</code> is always an empty type.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>alternative_info {</div>
<div class="line">    <span class="comment">// index of the alternative in the source variant</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> index = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// type of the alternative as declared in the source variant</span></div>
<div class="line">    <span class="keyword">using </span>type = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// helper function for forwarding non-const alternative values</span></div>
<div class="line">    <span class="comment">// without needing to provide a template argument.</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) forward(...);</div>
<div class="line">};</div>
</div><!-- fragment --><p>Note that the overload function can be helpful for defining a visitor inline.</p>
<p>Also note that this function is implemented as a compile-time-defined jump table (array of function pointers). In performance critical applications, be wary of any assumptions about how well or poorly your compiler will optimize a call to this function.</p>
<h2><a class="anchor" id="autotoc_md487"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v1</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line">std::move(<a class="code hl_class" href="classsumty_1_1result.html">v1</a>).<a class="code hl_function" href="classsumty_1_1result.html#a1656bb14f0a45ec7cfa81bb960acf924">visit_informed</a>([](<span class="keyword">auto</span> value, <span class="keyword">auto</span> <a class="code hl_class" href="classsumty_1_1result.html">info</a>) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<a class="code hl_class" href="classsumty_1_1result.html">info</a>.index == 0) {</div>
<div class="line">        <a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">false</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 1) {</div>
<div class="line">        assert(value == 42);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 2) {</div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The callable object that will be passed an alternative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the visitor, if any. </dd></dl>

</div>
</div>
<a id="aebb3a178a071dfb5bdecb8607d446a4b" name="aebb3a178a071dfb5bdecb8607d446a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb3a178a071dfb5bdecb8607d446a4b">&#9670;&#160;</a></span>visit_informed() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit_informed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a visitor callable with the contained alternative and metadata. </p>
<p>This function calls the visitor as <code>std::invoke(visitor, alternative, info)</code>, and returns the result of that call, if any. As such, <code>visitor</code> <em>must</em> be able to accept any alternative type as an argument. In the case of an alternative of type <code>void</code>, the visitor must be callable as <code>std::invoke(visitor, void_v, info)</code>.</p>
<p>The <code>info</code> argument passed to the visitor, which differentiates this function from <code>.visit(...)</code>, communicates <code>constexpr</code> information about the alternative being visited. The type of the <code>info</code> object is not meant to be named, but it has the API shown below. Note that <code>info</code> is always an empty type.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>alternative_info {</div>
<div class="line">    <span class="comment">// index of the alternative in the source variant</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> index = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// type of the alternative as declared in the source variant</span></div>
<div class="line">    <span class="keyword">using </span>type = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// helper function for forwarding non-const alternative values</span></div>
<div class="line">    <span class="comment">// without needing to provide a template argument.</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) forward(...);</div>
<div class="line">};</div>
</div><!-- fragment --><p>Note that the overload function can be helpful for defining a visitor inline.</p>
<p>Also note that this function is implemented as a compile-time-defined jump table (array of function pointers). In performance critical applications, be wary of any assumptions about how well or poorly your compiler will optimize a call to this function.</p>
<h2><a class="anchor" id="autotoc_md486"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v1</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v1</a>.<a class="code hl_function" href="classsumty_1_1result.html#a1656bb14f0a45ec7cfa81bb960acf924">visit_informed</a>([](<span class="keyword">auto</span> value, <span class="keyword">auto</span> <a class="code hl_class" href="classsumty_1_1result.html">info</a>) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<a class="code hl_class" href="classsumty_1_1result.html">info</a>.index == 0) {</div>
<div class="line">        <a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">false</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 1) {</div>
<div class="line">        assert(value == 42);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 2) {</div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The callable object that will be passed an alternative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the visitor, if any. </dd></dl>

</div>
</div>
<a id="affdb84ccc3402ad25040ee85cbffb9a3" name="affdb84ccc3402ad25040ee85cbffb9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdb84ccc3402ad25040ee85cbffb9a3">&#9670;&#160;</a></span>visit_informed() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit_informed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a visitor callable with the contained alternative and metadata. </p>
<p>This function calls the visitor as <code>std::invoke(visitor, alternative, info)</code>, and returns the result of that call, if any. As such, <code>visitor</code> <em>must</em> be able to accept any alternative type as an argument. In the case of an alternative of type <code>void</code>, the visitor must be callable as <code>std::invoke(visitor, void_v, info)</code>.</p>
<p>The <code>info</code> argument passed to the visitor, which differentiates this function from <code>.visit(...)</code>, communicates <code>constexpr</code> information about the alternative being visited. The type of the <code>info</code> object is not meant to be named, but it has the API shown below. Note that <code>info</code> is always an empty type.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>alternative_info {</div>
<div class="line">    <span class="comment">// index of the alternative in the source variant</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> index = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// type of the alternative as declared in the source variant</span></div>
<div class="line">    <span class="keyword">using </span>type = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// helper function for forwarding non-const alternative values</span></div>
<div class="line">    <span class="comment">// without needing to provide a template argument.</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) forward(...);</div>
<div class="line">};</div>
</div><!-- fragment --><p>Note that the overload function can be helpful for defining a visitor inline.</p>
<p>Also note that this function is implemented as a compile-time-defined jump table (array of function pointers). In performance critical applications, be wary of any assumptions about how well or poorly your compiler will optimize a call to this function.</p>
<h2><a class="anchor" id="autotoc_md488"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v1</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line">std::move(<a class="code hl_class" href="classsumty_1_1result.html">v1</a>).<a class="code hl_function" href="classsumty_1_1result.html#a1656bb14f0a45ec7cfa81bb960acf924">visit_informed</a>([](<span class="keyword">auto</span> value, <span class="keyword">auto</span> <a class="code hl_class" href="classsumty_1_1result.html">info</a>) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<a class="code hl_class" href="classsumty_1_1result.html">info</a>.index == 0) {</div>
<div class="line">        <a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">false</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 1) {</div>
<div class="line">        assert(value == 42);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 2) {</div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The callable object that will be passed an alternative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the visitor, if any. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a06e93de94fdccb8aeb6cc7b408310ac2" name="a06e93de94fdccb8aeb6cc7b408310ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e93de94fdccb8aeb6cc7b408310ac2">&#9670;&#160;</a></span>get() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative by index. </p>
<p>This function allows accessing <a class="el" href="classsumty_1_1variant.html">variant</a> alternatives by index, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md426"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <a class="el" href="classsumty_1_1variant.html">variant</a> to access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The accessed alternative value, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative with the corresponding index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a94fa612fae580619b3ca2daa452b19" name="a2a94fa612fae580619b3ca2daa452b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a94fa612fae580619b3ca2daa452b19">&#9670;&#160;</a></span>get() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative by index. </p>
<p>This function allows accessing <a class="el" href="classsumty_1_1variant.html">variant</a> alternatives by index, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md424"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <a class="el" href="classsumty_1_1variant.html">variant</a> to access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative with the corresponding index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6eebbfa1d2180dbbbf08c00cfb3c4aa" name="ac6eebbfa1d2180dbbbf08c00cfb3c4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6eebbfa1d2180dbbbf08c00cfb3c4aa">&#9670;&#160;</a></span>get() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1variant.html">variant</a>&lt; U... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative by type. </p>
<p>This function allows accessing <a class="el" href="classsumty_1_1variant.html">variant</a> alternatives by type, which is provided as a template argument.</p>
<p>This function only participates in overload resolution if the type is unique across all alternative types of the <a class="el" href="classsumty_1_1variant.html">variant</a>. That is, <code>variant&lt;A, B, A&gt;</code> cannot use this function to access an alternative of type <code>A</code>, but it can use this fucntion to access an alternative of type <code>B</code>.</p>
<h2><a class="anchor" id="autotoc_md430"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <a class="el" href="classsumty_1_1variant.html">variant</a> to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The accessed alternative value, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative with the corresponding type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74b993aa6228232cc846c8d030b46ad4" name="a74b993aa6228232cc846c8d030b46ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b993aa6228232cc846c8d030b46ad4">&#9670;&#160;</a></span>get() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1variant.html">variant</a>&lt; U... &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative by type. </p>
<p>This function allows accessing <a class="el" href="classsumty_1_1variant.html">variant</a> alternatives by type, which is provided as a template argument.</p>
<p>This function only participates in overload resolution if the type is unique across all alternative types of the <a class="el" href="classsumty_1_1variant.html">variant</a>. That is, <code>variant&lt;A, B, A&gt;</code> cannot use this function to access an alternative of type <code>A</code>, but it can use this fucntion to access an alternative of type <code>B</code>.</p>
<h2><a class="anchor" id="autotoc_md428"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <a class="el" href="classsumty_1_1variant.html">variant</a> to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative with the corresponding type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59495d492a709f1b133567ecb491fd8e" name="a59495d492a709f1b133567ecb491fd8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59495d492a709f1b133567ecb491fd8e">&#9670;&#160;</a></span>get() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative by index. </p>
<p>This function allows accessing <a class="el" href="classsumty_1_1variant.html">variant</a> alternatives by index, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md425"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <a class="el" href="classsumty_1_1variant.html">variant</a> to access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The accessed alternative value, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative with the corresponding index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3063ea8d0698960c87e804a3aab91fb7" name="a3063ea8d0698960c87e804a3aab91fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3063ea8d0698960c87e804a3aab91fb7">&#9670;&#160;</a></span>get() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative by index. </p>
<p>This function allows accessing <a class="el" href="classsumty_1_1variant.html">variant</a> alternatives by index, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md423"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <a class="el" href="classsumty_1_1variant.html">variant</a> to access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative with the corresponding index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa13af27607b6f326db3341bdcb09f0b" name="afa13af27607b6f326db3341bdcb09f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa13af27607b6f326db3341bdcb09f0b">&#9670;&#160;</a></span>get() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1variant.html">variant</a>&lt; U... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative by type. </p>
<p>This function allows accessing <a class="el" href="classsumty_1_1variant.html">variant</a> alternatives by type, which is provided as a template argument.</p>
<p>This function only participates in overload resolution if the type is unique across all alternative types of the <a class="el" href="classsumty_1_1variant.html">variant</a>. That is, <code>variant&lt;A, B, A&gt;</code> cannot use this function to access an alternative of type <code>A</code>, but it can use this fucntion to access an alternative of type <code>B</code>.</p>
<h2><a class="anchor" id="autotoc_md429"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <a class="el" href="classsumty_1_1variant.html">variant</a> to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The accessed alternative value, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative with the corresponding type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad28e370bd09931bc720c0dc297c1e2cf" name="ad28e370bd09931bc720c0dc297c1e2cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28e370bd09931bc720c0dc297c1e2cf">&#9670;&#160;</a></span>get() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1variant.html">variant</a>&lt; U... &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative by type. </p>
<p>This function allows accessing <a class="el" href="classsumty_1_1variant.html">variant</a> alternatives by type, which is provided as a template argument.</p>
<p>This function only participates in overload resolution if the type is unique across all alternative types of the <a class="el" href="classsumty_1_1variant.html">variant</a>. That is, <code>variant&lt;A, B, A&gt;</code> cannot use this function to access an alternative of type <code>A</code>, but it can use this fucntion to access an alternative of type <code>B</code>.</p>
<h2><a class="anchor" id="autotoc_md427"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 42);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <a class="el" href="classsumty_1_1variant.html">variant</a> to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative with the corresponding type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3d931451f84459fadd8a52f71c90aec" name="af3d931451f84459fadd8a52f71c90aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d931451f84459fadd8a52f71c90aec">&#9670;&#160;</a></span>get_if() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_POINTER</a> get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative pointer by index if the <a class="el" href="classsumty_1_1variant.html">variant</a> holds it. </p>
<p>This functions tries to access a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative by index. If the <a class="el" href="classsumty_1_1variant.html">variant</a> contains the alternative, this function returns a pointer to the alternative, if applicable. If the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative, this function returns null. In the case where the alternative is of type <code>void</code>, this function does nothing.</p>
<h2><a class="anchor" id="autotoc_md432"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 42);</div>
<div class="line"> </div>
<div class="line">*<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;0&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <a class="el" href="classsumty_1_1variant.html">variant</a> to access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the accessed alternative, if applicable, or null </dd></dl>

</div>
</div>
<a id="a6017cc1255d8cb5d364b388908ec28cb" name="a6017cc1255d8cb5d364b388908ec28cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6017cc1255d8cb5d364b388908ec28cb">&#9670;&#160;</a></span>get_if() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_POINTER</a> get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1variant.html">variant</a>&lt; U... &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative pointer by type if the <a class="el" href="classsumty_1_1variant.html">variant</a> holds it. </p>
<p>This functions tries to access an alternative by type. If the <a class="el" href="classsumty_1_1variant.html">variant</a> contains the alternative, this function returns a pointer to the alternative, if applicable. If the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative, this function returns null. In the case where the alternative is of type <code>void</code>, this function does nothing.</p>
<p>This function only participates in overload resolution if the type is unique across all alternative types of the <a class="el" href="classsumty_1_1variant.html">variant</a>. That is, <code>variant&lt;A, B, A&gt;</code> cannot use this function to access an alternative of type <code>A</code>, but it can use this fucntion to access an alternative of type <code>B</code>.</p>
<h2><a class="anchor" id="autotoc_md434"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 42);</div>
<div class="line"> </div>
<div class="line">*<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;bool&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <a class="el" href="classsumty_1_1variant.html">variant</a> to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the accessed alternative, if applicable, or null </dd></dl>

</div>
</div>
<a id="a590e66ffb36c4125361cae5473a04ceb" name="a590e66ffb36c4125361cae5473a04ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590e66ffb36c4125361cae5473a04ceb">&#9670;&#160;</a></span>get_if() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">POINTER</a> get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative pointer by index if the <a class="el" href="classsumty_1_1variant.html">variant</a> holds it. </p>
<p>This functions tries to access a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative by index. If the <a class="el" href="classsumty_1_1variant.html">variant</a> contains the alternative, this function returns a pointer to the alternative, if applicable. If the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative, this function returns null. In the case where the alternative is of type <code>void</code>, this function does nothing.</p>
<h2><a class="anchor" id="autotoc_md431"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 42);</div>
<div class="line"> </div>
<div class="line">*<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;0&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <a class="el" href="classsumty_1_1variant.html">variant</a> to access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the accessed alternative, if applicable, or null </dd></dl>

</div>
</div>
<a id="a10db7764a1129d3f79f7de3e6e8517af" name="a10db7764a1129d3f79f7de3e6e8517af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10db7764a1129d3f79f7de3e6e8517af">&#9670;&#160;</a></span>get_if() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">POINTER</a> get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1variant.html">variant</a>&lt; U... &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classsumty_1_1variant.html">variant</a> alternative pointer by type if the <a class="el" href="classsumty_1_1variant.html">variant</a> holds it. </p>
<p>This functions tries to access an alternative by type. If the <a class="el" href="classsumty_1_1variant.html">variant</a> contains the alternative, this function returns a pointer to the alternative, if applicable. If the <a class="el" href="classsumty_1_1variant.html">variant</a> does not contain the alternative, this function returns null. In the case where the alternative is of type <code>void</code>, this function does nothing.</p>
<p>This function only participates in overload resolution if the type is unique across all alternative types of the <a class="el" href="classsumty_1_1variant.html">variant</a>. That is, <code>variant&lt;A, B, A&gt;</code> cannot use this function to access an alternative of type <code>A</code>, but it can use this fucntion to access an alternative of type <code>B</code>.</p>
<h2><a class="anchor" id="autotoc_md433"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 42);</div>
<div class="line"> </div>
<div class="line">*<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) = 24;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == 24);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;bool&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <a class="el" href="classsumty_1_1variant.html">variant</a> to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the accessed alternative, if applicable, or null </dd></dl>

</div>
</div>
<a id="ac57ee49bf006d79fa05d8f309627e2dc" name="ac57ee49bf006d79fa05d8f309627e2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57ee49bf006d79fa05d8f309627e2dc">&#9670;&#160;</a></span>holds_alternative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a> holds_alternative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1variant.html">variant</a>&lt; U... &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a <a class="el" href="classsumty_1_1variant.html">variant</a> contains a particular alternative. </p>
<p>Given a type parameter, this function checks if the <a class="el" href="classsumty_1_1variant.html">variant</a> currently holds an alternative that has the exact same type.</p>
<h2><a class="anchor" id="autotoc_md422"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, bool, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v1</a>{std::in_place_index&lt;0&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">holds_alternative&lt;int&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v1</a>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;int, bool, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v2</a>{std::in_place_index&lt;2&gt;, 42};</div>
<div class="line"> </div>
<div class="line">assert(holds_alternative&lt;int&gt;(v2));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The <a class="el" href="classsumty_1_1variant.html">variant</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classsumty_1_1variant.html">variant</a> holds an alternative of the given type. </dd></dl>

</div>
</div>
<a id="a67aa2067f8434d8f54fd715d893022a7" name="a67aa2067f8434d8f54fd715d893022a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67aa2067f8434d8f54fd715d893022a7">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">void</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1variant.html">variant</a>&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two <a class="el" href="classsumty_1_1variant.html">variant</a> instances. </p>
<p>If the two <a class="el" href="classsumty_1_1variant.html">variant</a> instances contain the same alternative, the alternative values are swapped directly. Otherwise, the alternatives are swapped by moving out of the variants, destroying the old alternatives, and move constructed into the new alternatives.</p>
<h2><a class="anchor" id="autotoc_md437"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v1</a>{std::in_place_index&lt;0&gt;, <span class="keyword">true</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v2</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="classsumty_1_1variant.html#a3e13a6bbf81b8927f418e5e9197ce67c">swap</a>(v1, v2);</div>
<div class="line"> </div>
<div class="line">assert(v1.index() == 1);</div>
<div class="line"> </div>
<div class="line">assert(get&lt;1&gt;(v1) == 42);</div>
<div class="line"> </div>
<div class="line">assert(v2.index() == 0);</div>
<div class="line"> </div>
<div class="line">assert(get&lt;2&gt;(v2) == <span class="keyword">true</span>);</div>
<div class="ttc" id="aclasssumty_1_1variant_html_a3e13a6bbf81b8927f418e5e9197ce67c"><div class="ttname"><a href="classsumty_1_1variant.html#a3e13a6bbf81b8927f418e5e9197ce67c">sumty::variant::swap</a></div><div class="ttdeci">constexpr void swap(variant &amp;other) CONDITIONALLY_NOEXCEPT</div><div class="ttdoc">Swaps two variant instances.</div><div class="ttdef"><b>Definition</b> variant.hpp:2305</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first variant in the swap </td></tr>
    <tr><td class="paramname">b</td><td>The second variant in the swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36b53cd212208e109ace84aaebd3c551" name="a36b53cd212208e109ace84aaebd3c551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b53cd212208e109ace84aaebd3c551">&#9670;&#160;</a></span>visit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a visitor callable with the contained <a class="el" href="classsumty_1_1variant.html">variant</a> alternatives. </p>
<p>This function calls the visitor as <code>std::invoke(visitor, alternative...)</code> and returns the result of that call, if any. As such, <code>visitor</code> <em>must</em> be able to accecpt any combination of alternative types as arguments. In the case of an alternative type <code>void</code>, the visitor must accept nothing for that argument. That is, the alternative type combination <code>int, void, int</code>, would result in the visitor being called as <code>std::invoke(visitor, int_value, int_value)</code>, essentially skipping the <code>void</code> alternative.</p>
<p>Note that the overload function can be helpful for defining a visitor inline.</p>
<p>Also note that this function is implemented as a compile-time-defined jump table (array of function pointers). In performance critical applications, be wary of any assumptions about how well or poorly your compiler will optimize a call to this function.</p>
<h2><a class="anchor" id="autotoc_md435"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v1</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;float, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v2</a>{std::in_place_index&lt;0&gt;, 3.14};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="classsumty_1_1variant.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>(overload(</div>
<div class="line">    [](<span class="keywordtype">bool</span> val1, <span class="keywordtype">float</span> val2) { assert(<span class="keyword">false</span>); },</div>
<div class="line">    [](<span class="keywordtype">int</span> val1, <span class="keywordtype">float</span> val2) { assert(val1 == 42); },</div>
<div class="line">    [](<span class="keywordtype">float</span> val2) { assert(<span class="keyword">false</span>); },</div>
<div class="line">    [](<span class="keywordtype">bool</span> val1, <span class="keywordtype">int</span> val2) { assert(<span class="keyword">false</span>); },</div>
<div class="line">    [](<span class="keywordtype">int</span> val1, <span class="keywordtype">float</span> val2) { assert(<span class="keyword">false</span>); },</div>
<div class="line">    [](<span class="keywordtype">int</span> val2) { assert(<span class="keyword">false</span>); }</div>
<div class="line">), v1, v2);</div>
<div class="ttc" id="aclasssumty_1_1variant_html_ae2f575e3e78ea2171d1be475f7f9a2d8"><div class="ttname"><a href="classsumty_1_1variant.html#ae2f575e3e78ea2171d1be475f7f9a2d8">sumty::variant::visit</a></div><div class="ttdeci">constexpr DEDUCED visit(V &amp;&amp;visitor) &amp;</div><div class="ttdoc">Calls a visitor callable with the contained alternative.</div><div class="ttdef"><b>Definition</b> variant.hpp:1868</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The callable object that will be passed an alternative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the visitor, if any. </dd></dl>

</div>
</div>
<a id="af3a6c93a7dc3eb3fa432d88920de7262" name="af3a6c93a7dc3eb3fa432d88920de7262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a6c93a7dc3eb3fa432d88920de7262">&#9670;&#160;</a></span>visit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">T0</a> , typename... TN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">T0</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>var0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">TN</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>varn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a visitor callable with the contained <a class="el" href="classsumty_1_1variant.html">variant</a> alternatives. </p>
<p>This function calls the visitor as <code>std::invoke(visitor, alternative...)</code> and returns the result of that call, if any. As such, <code>visitor</code> <em>must</em> be able to accecpt any combination of alternative types as arguments. In the case of an alternative type <code>void</code>, the visitor must accept nothing for that argument. That is, the alternative type combination <code>int, void, int</code>, would result in the visitor being called as <code>std::invoke(visitor, int_value, int_value)</code>, essentially skipping the <code>void</code> alternative.</p>
<p>Note that the overload function can be helpful for defining a visitor inline.</p>
<p>Also note that this function is implemented as a compile-time-defined jump table (array of function pointers). In performance critical applications, be wary of any assumptions about how well or poorly your compiler will optimize a call to this function.</p>
<h2><a class="anchor" id="autotoc_md436"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;bool, int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v1</a>{std::in_place_index&lt;1&gt;, 42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;float, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">v2</a>{std::in_place_index&lt;0&gt;, 3.14};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="classsumty_1_1variant.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>(overload(</div>
<div class="line">    [](<span class="keywordtype">bool</span> val1, <span class="keywordtype">float</span> val2) { assert(<span class="keyword">false</span>); },</div>
<div class="line">    [](<span class="keywordtype">int</span> val1, <span class="keywordtype">float</span> val2) { assert(val1 == 42); },</div>
<div class="line">    [](<span class="keywordtype">float</span> val2) { assert(<span class="keyword">false</span>); },</div>
<div class="line">    [](<span class="keywordtype">bool</span> val1, <span class="keywordtype">int</span> val2) { assert(<span class="keyword">false</span>); },</div>
<div class="line">    [](<span class="keywordtype">int</span> val1, <span class="keywordtype">float</span> val2) { assert(<span class="keyword">false</span>); },</div>
<div class="line">    [](<span class="keywordtype">int</span> val2) { assert(<span class="keyword">false</span>); }</div>
<div class="line">), v1, v2);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The callable object that will be passed an alternative.</td></tr>
    <tr><td class="paramname">var0</td><td>The first variant to visit</td></tr>
    <tr><td class="paramname">varn</td><td>The remaining variant to visit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the visitor, if any. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sumty/detail/<a class="el" href="fwd_8hpp_source.html">fwd.hpp</a></li>
<li>sumty/<a class="el" href="variant_8hpp_source.html">variant.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>sumty</b></li><li class="navelem"><a class="el" href="classsumty_1_1variant.html">variant</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
