<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sumty: result&lt; T, E &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">sumty<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Better sum types for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classsumty_1_1result.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classsumty_1_1result-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">result&lt; T, E &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Type that contains an ok value, or an error.  
 <a href="classsumty_1_1result.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="result_8hpp_source.html">sumty/result.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a75607fd33d5870c1b1f8c0944371a8b0" id="r_a75607fd33d5870c1b1f8c0944371a8b0"><td class="memItemLeft" align="right" valign="top"><a id="a75607fd33d5870c1b1f8c0944371a8b0" name="a75607fd33d5870c1b1f8c0944371a8b0"></a>
<a class="el" href="classsumty_1_1result.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = ...</td></tr>
<tr class="separator:a75607fd33d5870c1b1f8c0944371a8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd1e056bf7f0d304a4d10b63a88ca3f" id="r_afbd1e056bf7f0d304a4d10b63a88ca3f"><td class="memItemLeft" align="right" valign="top"><a id="afbd1e056bf7f0d304a4d10b63a88ca3f" name="afbd1e056bf7f0d304a4d10b63a88ca3f"></a>
<a class="el" href="classsumty_1_1result.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = ...</td></tr>
<tr class="separator:afbd1e056bf7f0d304a4d10b63a88ca3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9151d13227f2b3446d14dcba1fc06bde" id="r_a9151d13227f2b3446d14dcba1fc06bde"><td class="memItemLeft" align="right" valign="top"><a id="a9151d13227f2b3446d14dcba1fc06bde" name="a9151d13227f2b3446d14dcba1fc06bde"></a>
<a class="el" href="classsumty_1_1result.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = ...</td></tr>
<tr class="separator:a9151d13227f2b3446d14dcba1fc06bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbee39f7592f4ed09044ed967c5252fe" id="r_acbee39f7592f4ed09044ed967c5252fe"><td class="memItemLeft" align="right" valign="top"><a id="acbee39f7592f4ed09044ed967c5252fe" name="acbee39f7592f4ed09044ed967c5252fe"></a>
<a class="el" href="classsumty_1_1result.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rvalue_reference</b> = ...</td></tr>
<tr class="separator:acbee39f7592f4ed09044ed967c5252fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b3acc334489b9a3c7c369af86081cc" id="r_aa3b3acc334489b9a3c7c369af86081cc"><td class="memItemLeft" align="right" valign="top"><a id="aa3b3acc334489b9a3c7c369af86081cc" name="aa3b3acc334489b9a3c7c369af86081cc"></a>
<a class="el" href="classsumty_1_1result.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>const_rvalue_reference</b> = ...</td></tr>
<tr class="separator:aa3b3acc334489b9a3c7c369af86081cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d55949726a60830d5f0274475048d73" id="r_a8d55949726a60830d5f0274475048d73"><td class="memItemLeft" align="right" valign="top"><a id="a8d55949726a60830d5f0274475048d73" name="a8d55949726a60830d5f0274475048d73"></a>
<a class="el" href="classsumty_1_1result.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = ...</td></tr>
<tr class="separator:a8d55949726a60830d5f0274475048d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf23278ffc553ad329ccf3d10703643b" id="r_acf23278ffc553ad329ccf3d10703643b"><td class="memItemLeft" align="right" valign="top"><a id="acf23278ffc553ad329ccf3d10703643b" name="acf23278ffc553ad329ccf3d10703643b"></a>
<a class="el" href="classsumty_1_1result.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = ...</td></tr>
<tr class="separator:acf23278ffc553ad329ccf3d10703643b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ba1346277749a0881475b0ce4e0c50" id="r_a20ba1346277749a0881475b0ce4e0c50"><td class="memItemLeft" align="right" valign="top"><a id="a20ba1346277749a0881475b0ce4e0c50" name="a20ba1346277749a0881475b0ce4e0c50"></a>
<a class="el" href="classsumty_1_1result.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>error_type</b> = ...</td></tr>
<tr class="separator:a20ba1346277749a0881475b0ce4e0c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9934a3860092a13f27a69d14642ff70" id="r_ad9934a3860092a13f27a69d14642ff70"><td class="memItemLeft" align="right" valign="top"><a id="ad9934a3860092a13f27a69d14642ff70" name="ad9934a3860092a13f27a69d14642ff70"></a>
<a class="el" href="classsumty_1_1result.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>error_reference</b> = ...</td></tr>
<tr class="separator:ad9934a3860092a13f27a69d14642ff70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde403e40acaf5d002aa5832314b620f" id="r_acde403e40acaf5d002aa5832314b620f"><td class="memItemLeft" align="right" valign="top"><a id="acde403e40acaf5d002aa5832314b620f" name="acde403e40acaf5d002aa5832314b620f"></a>
<a class="el" href="classsumty_1_1result.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>error_const_reference</b> = ...</td></tr>
<tr class="separator:acde403e40acaf5d002aa5832314b620f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80357e6213f6a7df6879df4d69ba6b05" id="r_a80357e6213f6a7df6879df4d69ba6b05"><td class="memItemLeft" align="right" valign="top"><a id="a80357e6213f6a7df6879df4d69ba6b05" name="a80357e6213f6a7df6879df4d69ba6b05"></a>
<a class="el" href="classsumty_1_1result.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>error_rvalue_reference</b> = ...</td></tr>
<tr class="separator:a80357e6213f6a7df6879df4d69ba6b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f847d5e40220425ee202421590ff58" id="r_af0f847d5e40220425ee202421590ff58"><td class="memItemLeft" align="right" valign="top"><a id="af0f847d5e40220425ee202421590ff58" name="af0f847d5e40220425ee202421590ff58"></a>
<a class="el" href="classsumty_1_1result.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>error_const_rvalue_reference</b> = ...</td></tr>
<tr class="separator:af0f847d5e40220425ee202421590ff58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f0052e20f62da8f7fdee368ef788d5" id="r_a09f0052e20f62da8f7fdee368ef788d5"><td class="memItemLeft" align="right" valign="top"><a id="a09f0052e20f62da8f7fdee368ef788d5" name="a09f0052e20f62da8f7fdee368ef788d5"></a>
<a class="el" href="classsumty_1_1result.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>error_pointer</b> = ...</td></tr>
<tr class="separator:a09f0052e20f62da8f7fdee368ef788d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8bea596b2690f78fef4f0c95c279ac" id="r_a9d8bea596b2690f78fef4f0c95c279ac"><td class="memItemLeft" align="right" valign="top"><a id="a9d8bea596b2690f78fef4f0c95c279ac" name="a9d8bea596b2690f78fef4f0c95c279ac"></a>
<a class="el" href="classsumty_1_1result.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>error_const_pointer</b> = ...</td></tr>
<tr class="separator:a9d8bea596b2690f78fef4f0c95c279ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084333ccb6f1c970bdbb304a0dc509bb" id="r_a084333ccb6f1c970bdbb304a0dc509bb"><td class="memTemplParams" colspan="2"><a id="a084333ccb6f1c970bdbb304a0dc509bb" name="a084333ccb6f1c970bdbb304a0dc509bb"></a>
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:a084333ccb6f1c970bdbb304a0dc509bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rebind</b> = <a class="el" href="classsumty_1_1result.html">result</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a>, <a class="el" href="classsumty_1_1result.html">E</a> &gt;</td></tr>
<tr class="separator:a084333ccb6f1c970bdbb304a0dc509bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8449fc639f38cfb1ee04e3b4fbb34f8c" id="r_a8449fc639f38cfb1ee04e3b4fbb34f8c"><td class="memTemplParams" colspan="2"><a id="a8449fc639f38cfb1ee04e3b4fbb34f8c" name="a8449fc639f38cfb1ee04e3b4fbb34f8c"></a>
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:a8449fc639f38cfb1ee04e3b4fbb34f8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rebind_error</b> = <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">V</a> &gt;</td></tr>
<tr class="separator:a8449fc639f38cfb1ee04e3b4fbb34f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a562ff4b6571e2ec9c9ae97faa82e4" id="r_a33a562ff4b6571e2ec9c9ae97faa82e4"><td class="memItemLeft" align="right" valign="top"><a id="a33a562ff4b6571e2ec9c9ae97faa82e4" name="a33a562ff4b6571e2ec9c9ae97faa82e4"></a>
<a class="el" href="classsumty_1_1result.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>unexpected_type</b> = <a class="el" href="classsumty_1_1error__t.html">error_t</a>&lt; <a class="el" href="classsumty_1_1result.html">E</a> &gt;</td></tr>
<tr class="separator:a33a562ff4b6571e2ec9c9ae97faa82e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab840c474538e57fc70384f5edf2d3f28" id="r_ab840c474538e57fc70384f5edf2d3f28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ab840c474538e57fc70384f5edf2d3f28">result</a> () <a class="el" href="classsumty_1_1result.html">CONDITIONALLY_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab840c474538e57fc70384f5edf2d3f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:ab840c474538e57fc70384f5edf2d3f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524fbfb4fe0750f412c05377945468aa" id="r_a524fbfb4fe0750f412c05377945468aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a524fbfb4fe0750f412c05377945468aa">result</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a> &amp;) <a class="el" href="classsumty_1_1result.html">CONDITIONALLY_NOEXCEPT</a></td></tr>
<tr class="memdesc:a524fbfb4fe0750f412c05377945468aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a524fbfb4fe0750f412c05377945468aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad84b79e65d7fa259f0e5f52057df33" id="r_afad84b79e65d7fa259f0e5f52057df33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#afad84b79e65d7fa259f0e5f52057df33">result</a> (<a class="el" href="classsumty_1_1result.html">result</a> &amp;&amp;) <a class="el" href="classsumty_1_1result.html">CONDITIONALLY_NOEXCEPT</a></td></tr>
<tr class="memdesc:afad84b79e65d7fa259f0e5f52057df33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:afad84b79e65d7fa259f0e5f52057df33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46c093d93908baa12792e6294ac6bfc" id="r_ae46c093d93908baa12792e6294ac6bfc"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae46c093d93908baa12792e6294ac6bfc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">CONDITONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ae46c093d93908baa12792e6294ac6bfc">result</a> (std::in_place_t <a class="el" href="classsumty_1_1result.html">inplace</a>, <a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;... <a class="el" href="classsumty_1_1result.html">args</a>)</td></tr>
<tr class="memdesc:ae46c093d93908baa12792e6294ac6bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplacement constructor.  <br /></td></tr>
<tr class="separator:ae46c093d93908baa12792e6294ac6bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56a2d881e3e070c1b536d630a94ce6b" id="r_ac56a2d881e3e070c1b536d630a94ce6b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </td></tr>
<tr class="memitem:ac56a2d881e3e070c1b536d630a94ce6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ac56a2d881e3e070c1b536d630a94ce6b">result</a> (std::in_place_t <a class="el" href="classsumty_1_1result.html">inplace</a>, std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; <a class="el" href="classsumty_1_1result.html">init</a>, <a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;... <a class="el" href="classsumty_1_1result.html">args</a>)</td></tr>
<tr class="memdesc:ac56a2d881e3e070c1b536d630a94ce6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplacement constructor with initializer list.  <br /></td></tr>
<tr class="separator:ac56a2d881e3e070c1b536d630a94ce6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a767f4097b0deff0139d55b697b76e1" id="r_a1a767f4097b0deff0139d55b697b76e1"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a1a767f4097b0deff0139d55b697b76e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a1a767f4097b0deff0139d55b697b76e1">result</a> (std::in_place_index_t&lt; 0 &gt; <a class="el" href="classsumty_1_1result.html">inplace</a>, <a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;... <a class="el" href="classsumty_1_1result.html">args</a>)</td></tr>
<tr class="memdesc:a1a767f4097b0deff0139d55b697b76e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplacement constructor.  <br /></td></tr>
<tr class="separator:a1a767f4097b0deff0139d55b697b76e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a69f1cd0ffab673cab649cb44ae0b8" id="r_a30a69f1cd0ffab673cab649cb44ae0b8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </td></tr>
<tr class="memitem:a30a69f1cd0ffab673cab649cb44ae0b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a30a69f1cd0ffab673cab649cb44ae0b8">result</a> (std::in_place_index_t&lt; 0 &gt; <a class="el" href="classsumty_1_1result.html">inplace</a>, std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; <a class="el" href="classsumty_1_1result.html">init</a>, <a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;... <a class="el" href="classsumty_1_1result.html">args</a>)</td></tr>
<tr class="memdesc:a30a69f1cd0ffab673cab649cb44ae0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplacement constructor with initializer list.  <br /></td></tr>
<tr class="separator:a30a69f1cd0ffab673cab649cb44ae0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d2a5c20888c283e99c1ea16121a7f4" id="r_ad5d2a5c20888c283e99c1ea16121a7f4"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ad5d2a5c20888c283e99c1ea16121a7f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">CONDITONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ad5d2a5c20888c283e99c1ea16121a7f4">result</a> (<a class="el" href="classsumty_1_1result.html">in_place_error_t</a> <a class="el" href="classsumty_1_1result.html">inplace</a>, <a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;... <a class="el" href="classsumty_1_1result.html">args</a>)</td></tr>
<tr class="memdesc:ad5d2a5c20888c283e99c1ea16121a7f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error emplacement constructor.  <br /></td></tr>
<tr class="separator:ad5d2a5c20888c283e99c1ea16121a7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dc049c0a34739004c5a7706dc02585" id="r_ae0dc049c0a34739004c5a7706dc02585"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </td></tr>
<tr class="memitem:ae0dc049c0a34739004c5a7706dc02585"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ae0dc049c0a34739004c5a7706dc02585">result</a> (<a class="el" href="classsumty_1_1result.html">in_place_error_t</a> <a class="el" href="classsumty_1_1result.html">inplace</a>, std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; <a class="el" href="classsumty_1_1result.html">init</a>, <a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;... <a class="el" href="classsumty_1_1result.html">args</a>)</td></tr>
<tr class="memdesc:ae0dc049c0a34739004c5a7706dc02585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error emplacement constructor with initializer list.  <br /></td></tr>
<tr class="separator:ae0dc049c0a34739004c5a7706dc02585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae555ba398fae5f24f00722ef632667ec" id="r_ae555ba398fae5f24f00722ef632667ec"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:ae555ba398fae5f24f00722ef632667ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ae555ba398fae5f24f00722ef632667ec">result</a> (<a class="el" href="classsumty_1_1result.html">U</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>)</td></tr>
<tr class="memdesc:ae555ba398fae5f24f00722ef632667ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwarding constructor.  <br /></td></tr>
<tr class="separator:ae555ba398fae5f24f00722ef632667ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3b3dcc80ae17306d74bafc683b1080" id="r_a2a3b3dcc80ae17306d74bafc683b1080"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:a2a3b3dcc80ae17306d74bafc683b1080"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">CONDITONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a2a3b3dcc80ae17306d74bafc683b1080">result</a> (<a class="el" href="classsumty_1_1ok__t.html">ok_t</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; ok)</td></tr>
<tr class="memdesc:a2a3b3dcc80ae17306d74bafc683b1080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ok converting constructor.  <br /></td></tr>
<tr class="separator:a2a3b3dcc80ae17306d74bafc683b1080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed4a0c5c6bcce05e6ef68439045ea99" id="r_afed4a0c5c6bcce05e6ef68439045ea99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#afed4a0c5c6bcce05e6ef68439045ea99">result</a> (<a class="el" href="classsumty_1_1ok__t.html">ok_t</a>&lt; <a class="el" href="classsumty_1_1result.html">void</a> &gt; ok)</td></tr>
<tr class="memdesc:afed4a0c5c6bcce05e6ef68439045ea99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ok converting constructor for <code>void</code>  <br /></td></tr>
<tr class="separator:afed4a0c5c6bcce05e6ef68439045ea99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97d5c3019e1853d04518722481711bc" id="r_ac97d5c3019e1853d04518722481711bc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:ac97d5c3019e1853d04518722481711bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">CONDITONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ac97d5c3019e1853d04518722481711bc">result</a> (<a class="el" href="classsumty_1_1error__t.html">error_t</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; <a class="el" href="classsumty_1_1result.html">err</a>)</td></tr>
<tr class="memdesc:ac97d5c3019e1853d04518722481711bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error converting constructor.  <br /></td></tr>
<tr class="separator:ac97d5c3019e1853d04518722481711bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbe72a080bd44a240db44c671aa1ade" id="r_a9fbe72a080bd44a240db44c671aa1ade"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a9fbe72a080bd44a240db44c671aa1ade">result</a> (<a class="el" href="classsumty_1_1error__t.html">error_t</a>&lt; <a class="el" href="classsumty_1_1result.html">void</a> &gt; <a class="el" href="classsumty_1_1result.html">err</a>)</td></tr>
<tr class="memdesc:a9fbe72a080bd44a240db44c671aa1ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error converting constructor for <code>void</code>  <br /></td></tr>
<tr class="separator:a9fbe72a080bd44a240db44c671aa1ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae7ab1fdf5530ef9867dd2471c6592b" id="r_abae7ab1fdf5530ef9867dd2471c6592b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:abae7ab1fdf5530ef9867dd2471c6592b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#abae7ab1fdf5530ef9867dd2471c6592b">result</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a>, <a class="el" href="classsumty_1_1result.html">V</a> &gt; &amp;<a class="el" href="classsumty_1_1result.html">other</a>)</td></tr>
<tr class="memdesc:abae7ab1fdf5530ef9867dd2471c6592b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting copy constructor.  <br /></td></tr>
<tr class="separator:abae7ab1fdf5530ef9867dd2471c6592b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3335f398384b9c609fa8bedfa32545" id="r_a3d3335f398384b9c609fa8bedfa32545"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:a3d3335f398384b9c609fa8bedfa32545"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a3d3335f398384b9c609fa8bedfa32545">result</a> (<a class="el" href="classsumty_1_1result.html">result</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a>, <a class="el" href="classsumty_1_1result.html">V</a> &gt; &amp;&amp;<a class="el" href="classsumty_1_1result.html">other</a>)</td></tr>
<tr class="memdesc:a3d3335f398384b9c609fa8bedfa32545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting move constructor.  <br /></td></tr>
<tr class="separator:a3d3335f398384b9c609fa8bedfa32545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f52676096082d9c53ad3062b76c974e" id="r_a8f52676096082d9c53ad3062b76c974e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a8f52676096082d9c53ad3062b76c974e">~result</a> () <a class="el" href="classsumty_1_1result.html">CONDITIONALLY_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8f52676096082d9c53ad3062b76c974e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a8f52676096082d9c53ad3062b76c974e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa090126fd8f5f80c8d60ce3bd95b89b1" id="r_aa090126fd8f5f80c8d60ce3bd95b89b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#aa090126fd8f5f80c8d60ce3bd95b89b1">operator=</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a> &amp;) <a class="el" href="classsumty_1_1result.html">CONDITIONALLY_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa090126fd8f5f80c8d60ce3bd95b89b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <br /></td></tr>
<tr class="separator:aa090126fd8f5f80c8d60ce3bd95b89b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cd1b26b7960cc6dd921ee372146b9f" id="r_ab9cd1b26b7960cc6dd921ee372146b9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ab9cd1b26b7960cc6dd921ee372146b9f">operator=</a> (<a class="el" href="classsumty_1_1result.html">result</a> &amp;&amp;) <a class="el" href="classsumty_1_1result.html">CONDITIONALLY_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab9cd1b26b7960cc6dd921ee372146b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <br /></td></tr>
<tr class="separator:ab9cd1b26b7960cc6dd921ee372146b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd498b6eddbc95ce9557c9eb5ebb60de" id="r_acd498b6eddbc95ce9557c9eb5ebb60de"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:acd498b6eddbc95ce9557c9eb5ebb60de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#acd498b6eddbc95ce9557c9eb5ebb60de">operator=</a> (<a class="el" href="classsumty_1_1result.html">U</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>)</td></tr>
<tr class="memdesc:acd498b6eddbc95ce9557c9eb5ebb60de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value assignment operator.  <br /></td></tr>
<tr class="separator:acd498b6eddbc95ce9557c9eb5ebb60de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad041a28277cb1af5d16b1f40174738b5" id="r_ad041a28277cb1af5d16b1f40174738b5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:ad041a28277cb1af5d16b1f40174738b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ad041a28277cb1af5d16b1f40174738b5">operator=</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1ok__t.html">ok_t</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; &amp;<a class="el" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>)</td></tr>
<tr class="memdesc:ad041a28277cb1af5d16b1f40174738b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment from <a class="el" href="classsumty_1_1ok__t.html">ok_t</a>.  <br /></td></tr>
<tr class="separator:ad041a28277cb1af5d16b1f40174738b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af697bd3286ff5dd2783e0856a4964c64" id="r_af697bd3286ff5dd2783e0856a4964c64"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:af697bd3286ff5dd2783e0856a4964c64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#af697bd3286ff5dd2783e0856a4964c64">operator=</a> (<a class="el" href="classsumty_1_1ok__t.html">ok_t</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; &amp;&amp;<a class="el" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>)</td></tr>
<tr class="memdesc:af697bd3286ff5dd2783e0856a4964c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment from <a class="el" href="classsumty_1_1ok__t.html">ok_t</a>.  <br /></td></tr>
<tr class="separator:af697bd3286ff5dd2783e0856a4964c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac651f94f43334108c005abc0865c6f93" id="r_ac651f94f43334108c005abc0865c6f93"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:ac651f94f43334108c005abc0865c6f93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ac651f94f43334108c005abc0865c6f93">operator=</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1error__t.html">error_t</a>&lt; <a class="el" href="classsumty_1_1result.html">V</a> &gt; &amp;<a class="el" href="classsumty_1_1result.html#a1fc95966d58ae6508accb53ae1617b16">error</a>)</td></tr>
<tr class="memdesc:ac651f94f43334108c005abc0865c6f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment from <a class="el" href="classsumty_1_1error__t.html">error_t</a>.  <br /></td></tr>
<tr class="separator:ac651f94f43334108c005abc0865c6f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cdb324cf406ba97202a4add5b61c82" id="r_aa8cdb324cf406ba97202a4add5b61c82"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:aa8cdb324cf406ba97202a4add5b61c82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#aa8cdb324cf406ba97202a4add5b61c82">operator=</a> (<a class="el" href="classsumty_1_1error__t.html">error_t</a>&lt; <a class="el" href="classsumty_1_1result.html">V</a> &gt; &amp;&amp;<a class="el" href="classsumty_1_1result.html#a1fc95966d58ae6508accb53ae1617b16">error</a>)</td></tr>
<tr class="memdesc:aa8cdb324cf406ba97202a4add5b61c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment from <a class="el" href="classsumty_1_1error__t.html">error_t</a>.  <br /></td></tr>
<tr class="separator:aa8cdb324cf406ba97202a4add5b61c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7990d8e87d9eab2383f94c88c23a6488" id="r_a7990d8e87d9eab2383f94c88c23a6488"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a7990d8e87d9eab2383f94c88c23a6488">operator bool</a> () <a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:a7990d8e87d9eab2383f94c88c23a6488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit conversion to <code>bool</code>.  <br /></td></tr>
<tr class="separator:a7990d8e87d9eab2383f94c88c23a6488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6988ba57722f67cbb444b0931468282e" id="r_a6988ba57722f67cbb444b0931468282e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a6988ba57722f67cbb444b0931468282e">has_value</a> () <a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:a6988ba57722f67cbb444b0931468282e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value.  <br /></td></tr>
<tr class="separator:a6988ba57722f67cbb444b0931468282e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdb1f9707ee1f7b6b49ff2b0dea34a9" id="r_aecdb1f9707ee1f7b6b49ff2b0dea34a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#aecdb1f9707ee1f7b6b49ff2b0dea34a9">is_ok</a> () <a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:aecdb1f9707ee1f7b6b49ff2b0dea34a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value.  <br /></td></tr>
<tr class="separator:aecdb1f9707ee1f7b6b49ff2b0dea34a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ae07e6fffe4be53e3de41c01786d99" id="r_a78ae07e6fffe4be53e3de41c01786d99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a78ae07e6fffe4be53e3de41c01786d99">is_error</a> () <a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:a78ae07e6fffe4be53e3de41c01786d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value.  <br /></td></tr>
<tr class="separator:a78ae07e6fffe4be53e3de41c01786d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af223249c6ba720462d09b5cea77ae573" id="r_af223249c6ba720462d09b5cea77ae573"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#af223249c6ba720462d09b5cea77ae573">operator*</a> () &amp;<a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:af223249c6ba720462d09b5cea77ae573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the ok value contained in the <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:af223249c6ba720462d09b5cea77ae573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bdafe3baa1fce9bad14c2aad77185f" id="r_a46bdafe3baa1fce9bad14c2aad77185f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a46bdafe3baa1fce9bad14c2aad77185f">operator*</a> () <a class="el" href="classsumty_1_1result.html">const</a> &amp;<a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:a46bdafe3baa1fce9bad14c2aad77185f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the ok value contained in the <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a46bdafe3baa1fce9bad14c2aad77185f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5847b7dab416bcb9b4c4b8e7100e90f2" id="r_a5847b7dab416bcb9b4c4b8e7100e90f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">rvalue_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a5847b7dab416bcb9b4c4b8e7100e90f2">operator*</a> () &amp;&amp;</td></tr>
<tr class="memdesc:a5847b7dab416bcb9b4c4b8e7100e90f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the ok value contained in the <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a5847b7dab416bcb9b4c4b8e7100e90f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d326290da75475116ce798c270e8c6c" id="r_a3d326290da75475116ce798c270e8c6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">const_rvalue_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a3d326290da75475116ce798c270e8c6c">operator*</a> () <a class="el" href="classsumty_1_1result.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:a3d326290da75475116ce798c270e8c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the ok value contained in the <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a3d326290da75475116ce798c270e8c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1cac3ec0a2272da9aa57c5358563d1" id="r_a0a1cac3ec0a2272da9aa57c5358563d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a0a1cac3ec0a2272da9aa57c5358563d1">operator-&gt;</a> () <a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:a0a1cac3ec0a2272da9aa57c5358563d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses members of the ok value contained in the <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a0a1cac3ec0a2272da9aa57c5358563d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbeac3f70f41e69d29f2ac3c79e65ba5" id="r_acbeac3f70f41e69d29f2ac3c79e65ba5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#acbeac3f70f41e69d29f2ac3c79e65ba5">operator-&gt;</a> () <a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:acbeac3f70f41e69d29f2ac3c79e65ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses members of the ok value contained in the <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:acbeac3f70f41e69d29f2ac3c79e65ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe474d55f5039d5c97b6b8dd5a25a66" id="r_a0fe474d55f5039d5c97b6b8dd5a25a66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a> () &amp;</td></tr>
<tr class="memdesc:a0fe474d55f5039d5c97b6b8dd5a25a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the ok value contained in the <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a0fe474d55f5039d5c97b6b8dd5a25a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc19624ae3495f0f09862da2df1da44" id="r_a2cc19624ae3495f0f09862da2df1da44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a2cc19624ae3495f0f09862da2df1da44">value</a> () <a class="el" href="classsumty_1_1result.html">const</a> &amp;</td></tr>
<tr class="memdesc:a2cc19624ae3495f0f09862da2df1da44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the ok value contained in the <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a2cc19624ae3495f0f09862da2df1da44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68a284bd8f5cc8f7e089453565a8073" id="r_ae68a284bd8f5cc8f7e089453565a8073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">rvalue_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ae68a284bd8f5cc8f7e089453565a8073">value</a> () &amp;&amp;</td></tr>
<tr class="memdesc:ae68a284bd8f5cc8f7e089453565a8073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the ok value contained in the <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:ae68a284bd8f5cc8f7e089453565a8073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d7f45caa4c2bbe9c7a035e180f1490" id="r_a27d7f45caa4c2bbe9c7a035e180f1490"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">rvalue_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a27d7f45caa4c2bbe9c7a035e180f1490">value</a> () <a class="el" href="classsumty_1_1result.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:a27d7f45caa4c2bbe9c7a035e180f1490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the ok value contained in the <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a27d7f45caa4c2bbe9c7a035e180f1490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc95966d58ae6508accb53ae1617b16" id="r_a1fc95966d58ae6508accb53ae1617b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">error_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a1fc95966d58ae6508accb53ae1617b16">error</a> () &amp;<a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:a1fc95966d58ae6508accb53ae1617b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the error value contained in the <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a1fc95966d58ae6508accb53ae1617b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02be31ae26d729bc73fd58d280bf443e" id="r_a02be31ae26d729bc73fd58d280bf443e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">error_const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a02be31ae26d729bc73fd58d280bf443e">error</a> () <a class="el" href="classsumty_1_1result.html">const</a> &amp;<a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:a02be31ae26d729bc73fd58d280bf443e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the error value contained in the <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a02be31ae26d729bc73fd58d280bf443e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0372cd10958a1e311670ff33afaaa038" id="r_a0372cd10958a1e311670ff33afaaa038"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">error_rvalue_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a0372cd10958a1e311670ff33afaaa038">error</a> () &amp;&amp;</td></tr>
<tr class="memdesc:a0372cd10958a1e311670ff33afaaa038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the error value contained in the <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a0372cd10958a1e311670ff33afaaa038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266793f7977f1b167ae64050a950dc74" id="r_a266793f7977f1b167ae64050a950dc74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">error_const_rvalue_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a266793f7977f1b167ae64050a950dc74">error</a> () <a class="el" href="classsumty_1_1result.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:a266793f7977f1b167ae64050a950dc74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the error value contained in the <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a266793f7977f1b167ae64050a950dc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c86313790b2ed250d0ec34eb315bba1" id="r_a0c86313790b2ed250d0ec34eb315bba1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:a0c86313790b2ed250d0ec34eb315bba1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">value_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a0c86313790b2ed250d0ec34eb315bba1">value_or</a> (<a class="el" href="classsumty_1_1result.html">U</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">default_value</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;</td></tr>
<tr class="memdesc:a0c86313790b2ed250d0ec34eb315bba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ok value, or a default if the <a class="el" href="classsumty_1_1result.html">result</a> is an error.  <br /></td></tr>
<tr class="separator:a0c86313790b2ed250d0ec34eb315bba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ed31aeebf624ff4f015571b58d5ae2" id="r_a85ed31aeebf624ff4f015571b58d5ae2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:a85ed31aeebf624ff4f015571b58d5ae2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">value_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a85ed31aeebf624ff4f015571b58d5ae2">value_or</a> (<a class="el" href="classsumty_1_1result.html">U</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">default_value</a>) &amp;&amp;</td></tr>
<tr class="memdesc:a85ed31aeebf624ff4f015571b58d5ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ok value, or a default if the <a class="el" href="classsumty_1_1result.html">result</a> is an error.  <br /></td></tr>
<tr class="separator:a85ed31aeebf624ff4f015571b58d5ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1d928422c6acbe1dfed8332a2431e2" id="r_add1d928422c6acbe1dfed8332a2431e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#add1d928422c6acbe1dfed8332a2431e2">value_or</a> () <a class="el" href="classsumty_1_1result.html">const</a> &amp;</td></tr>
<tr class="memdesc:add1d928422c6acbe1dfed8332a2431e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ok value, or a default if the <a class="el" href="classsumty_1_1result.html">result</a> is an error.  <br /></td></tr>
<tr class="separator:add1d928422c6acbe1dfed8332a2431e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad65213c97d6954f6ce87a44b5a9400" id="r_a4ad65213c97d6954f6ce87a44b5a9400"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a4ad65213c97d6954f6ce87a44b5a9400">value_or</a> () &amp;&amp;</td></tr>
<tr class="memdesc:a4ad65213c97d6954f6ce87a44b5a9400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ok value, or a default if the <a class="el" href="classsumty_1_1result.html">result</a> is an error.  <br /></td></tr>
<tr class="separator:a4ad65213c97d6954f6ce87a44b5a9400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29aa26d2088d1bb135da8d58009137d" id="r_ac29aa26d2088d1bb135da8d58009137d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:ac29aa26d2088d1bb135da8d58009137d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">value_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ac29aa26d2088d1bb135da8d58009137d">value_or_else</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;</td></tr>
<tr class="memdesc:ac29aa26d2088d1bb135da8d58009137d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ok value, or returns the result of a callable.  <br /></td></tr>
<tr class="separator:ac29aa26d2088d1bb135da8d58009137d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0533aa24f70936e326d5347b8fc0c750" id="r_a0533aa24f70936e326d5347b8fc0c750"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:a0533aa24f70936e326d5347b8fc0c750"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">value_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a0533aa24f70936e326d5347b8fc0c750">value_or_else</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) &amp;&amp;</td></tr>
<tr class="memdesc:a0533aa24f70936e326d5347b8fc0c750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ok value, or returns the result of a callable.  <br /></td></tr>
<tr class="separator:a0533aa24f70936e326d5347b8fc0c750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62819f8ee94f18955aa983370e6f8d57" id="r_a62819f8ee94f18955aa983370e6f8d57"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:a62819f8ee94f18955aa983370e6f8d57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a62819f8ee94f18955aa983370e6f8d57">and_then</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) &amp;</td></tr>
<tr class="memdesc:a62819f8ee94f18955aa983370e6f8d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a callable to the contents of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a62819f8ee94f18955aa983370e6f8d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabc593e326c7a64748c51b9d549f75a" id="r_adabc593e326c7a64748c51b9d549f75a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:adabc593e326c7a64748c51b9d549f75a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#adabc593e326c7a64748c51b9d549f75a">and_then</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;</td></tr>
<tr class="memdesc:adabc593e326c7a64748c51b9d549f75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a callable to the contents of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:adabc593e326c7a64748c51b9d549f75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2146246884225b7a1dd569cb3ecb3491" id="r_a2146246884225b7a1dd569cb3ecb3491"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:a2146246884225b7a1dd569cb3ecb3491"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a2146246884225b7a1dd569cb3ecb3491">and_then</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) &amp;&amp;</td></tr>
<tr class="memdesc:a2146246884225b7a1dd569cb3ecb3491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a callable to the contents of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a2146246884225b7a1dd569cb3ecb3491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d6cb036f0179ae2333a4f469de86b6" id="r_ad8d6cb036f0179ae2333a4f469de86b6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:ad8d6cb036f0179ae2333a4f469de86b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ad8d6cb036f0179ae2333a4f469de86b6">and_then</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:ad8d6cb036f0179ae2333a4f469de86b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a callable to the contents of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:ad8d6cb036f0179ae2333a4f469de86b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b47c4e5b7d606127eca04576b1f657" id="r_a53b47c4e5b7d606127eca04576b1f657"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:a53b47c4e5b7d606127eca04576b1f657"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a53b47c4e5b7d606127eca04576b1f657">transform</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) &amp;</td></tr>
<tr class="memdesc:a53b47c4e5b7d606127eca04576b1f657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perforams a transformation on the ok value of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a53b47c4e5b7d606127eca04576b1f657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab615fc0f0e34cfb71e49a0f5695d5c5b" id="r_ab615fc0f0e34cfb71e49a0f5695d5c5b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:ab615fc0f0e34cfb71e49a0f5695d5c5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ab615fc0f0e34cfb71e49a0f5695d5c5b">transform</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;</td></tr>
<tr class="memdesc:ab615fc0f0e34cfb71e49a0f5695d5c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perforams a transformation on the ok value of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:ab615fc0f0e34cfb71e49a0f5695d5c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77adc2e081bfb5e7605e97ed93c22e72" id="r_a77adc2e081bfb5e7605e97ed93c22e72"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:a77adc2e081bfb5e7605e97ed93c22e72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a77adc2e081bfb5e7605e97ed93c22e72">transform</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) &amp;&amp;</td></tr>
<tr class="memdesc:a77adc2e081bfb5e7605e97ed93c22e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perforams a transformation on the ok value of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a77adc2e081bfb5e7605e97ed93c22e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af687c1f031fc58d3240a81e3d6718c89" id="r_af687c1f031fc58d3240a81e3d6718c89"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:af687c1f031fc58d3240a81e3d6718c89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#af687c1f031fc58d3240a81e3d6718c89">transform</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:af687c1f031fc58d3240a81e3d6718c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perforams a transformation on the ok value of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:af687c1f031fc58d3240a81e3d6718c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78adcf88fdf6b1ddd812fded133e5d27" id="r_a78adcf88fdf6b1ddd812fded133e5d27"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:a78adcf88fdf6b1ddd812fded133e5d27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a78adcf88fdf6b1ddd812fded133e5d27">map</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) &amp;</td></tr>
<tr class="memdesc:a78adcf88fdf6b1ddd812fded133e5d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perforams a transformation on the ok value of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a78adcf88fdf6b1ddd812fded133e5d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8cb9bd568be1d4cc5cd07f6d6f9534" id="r_a8e8cb9bd568be1d4cc5cd07f6d6f9534"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:a8e8cb9bd568be1d4cc5cd07f6d6f9534"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a8e8cb9bd568be1d4cc5cd07f6d6f9534">map</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;</td></tr>
<tr class="memdesc:a8e8cb9bd568be1d4cc5cd07f6d6f9534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perforams a transformation on the ok value of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a8e8cb9bd568be1d4cc5cd07f6d6f9534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171bf3001590e7b4efa26f968ee767a6" id="r_a171bf3001590e7b4efa26f968ee767a6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:a171bf3001590e7b4efa26f968ee767a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a171bf3001590e7b4efa26f968ee767a6">map</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) &amp;&amp;</td></tr>
<tr class="memdesc:a171bf3001590e7b4efa26f968ee767a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perforams a transformation on the ok value of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a171bf3001590e7b4efa26f968ee767a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66252faa0dd3f45045258d86f900b54" id="r_ae66252faa0dd3f45045258d86f900b54"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:ae66252faa0dd3f45045258d86f900b54"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ae66252faa0dd3f45045258d86f900b54">map</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:ae66252faa0dd3f45045258d86f900b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perforams a transformation on the ok value of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:ae66252faa0dd3f45045258d86f900b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cfc81cf51508476d2641d8b086ffb5" id="r_a06cfc81cf51508476d2641d8b086ffb5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:a06cfc81cf51508476d2641d8b086ffb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a06cfc81cf51508476d2641d8b086ffb5">or_else</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;</td></tr>
<tr class="memdesc:a06cfc81cf51508476d2641d8b086ffb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of invoking <code>f</code> if the <a class="el" href="classsumty_1_1result.html">result</a> is an error.  <br /></td></tr>
<tr class="separator:a06cfc81cf51508476d2641d8b086ffb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3990e51c7f8204123bd70cfbd22405ce" id="r_a3990e51c7f8204123bd70cfbd22405ce"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:a3990e51c7f8204123bd70cfbd22405ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a3990e51c7f8204123bd70cfbd22405ce">or_else</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) &amp;&amp;</td></tr>
<tr class="memdesc:a3990e51c7f8204123bd70cfbd22405ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of invoking <code>f</code> if the <a class="el" href="classsumty_1_1result.html">result</a> is an error.  <br /></td></tr>
<tr class="separator:a3990e51c7f8204123bd70cfbd22405ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ca8608fbca4acbef17e6678a2cb158" id="r_a96ca8608fbca4acbef17e6678a2cb158"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a96ca8608fbca4acbef17e6678a2cb158">flatten</a> () <a class="el" href="classsumty_1_1result.html">const</a> &amp;</td></tr>
<tr class="memdesc:a96ca8608fbca4acbef17e6678a2cb158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>result&lt;result&lt;T, E1&gt;, E2&gt;</code> into <code>result&lt;T, E3&gt;</code>  <br /></td></tr>
<tr class="separator:a96ca8608fbca4acbef17e6678a2cb158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f223501a34e06676900e3f27051737" id="r_ad1f223501a34e06676900e3f27051737"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ad1f223501a34e06676900e3f27051737">flatten</a> () &amp;&amp;</td></tr>
<tr class="memdesc:ad1f223501a34e06676900e3f27051737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>result&lt;result&lt;T, E1&gt;, E2&gt;</code> into <code>result&lt;T, E3&gt;</code>  <br /></td></tr>
<tr class="separator:ad1f223501a34e06676900e3f27051737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb73126143d9ed2b1c342e0e8520118f" id="r_afb73126143d9ed2b1c342e0e8520118f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#afb73126143d9ed2b1c342e0e8520118f">flatten_all</a> () <a class="el" href="classsumty_1_1result.html">const</a> &amp;</td></tr>
<tr class="memdesc:afb73126143d9ed2b1c342e0e8520118f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts nested <a class="el" href="classsumty_1_1result.html">result</a> types into a single <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:afb73126143d9ed2b1c342e0e8520118f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3648c08cef0fa9ee01ee69b3f3acf50" id="r_ad3648c08cef0fa9ee01ee69b3f3acf50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ad3648c08cef0fa9ee01ee69b3f3acf50">flatten_all</a> () &amp;&amp;</td></tr>
<tr class="memdesc:ad3648c08cef0fa9ee01ee69b3f3acf50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts nested <a class="el" href="classsumty_1_1result.html">result</a> types into a single <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:ad3648c08cef0fa9ee01ee69b3f3acf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58629470af132787ab0ae0169e8a087" id="r_ae58629470af132787ab0ae0169e8a087"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ae58629470af132787ab0ae0169e8a087">transpose</a> () <a class="el" href="classsumty_1_1result.html">const</a> &amp;</td></tr>
<tr class="memdesc:ae58629470af132787ab0ae0169e8a087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>result&lt;option&lt;T&gt;, E&gt;</code> into <code>option&lt;result&lt;T, E&gt;&gt;</code>  <br /></td></tr>
<tr class="separator:ae58629470af132787ab0ae0169e8a087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cac08061795894102b76c5e5427b50d" id="r_a6cac08061795894102b76c5e5427b50d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a6cac08061795894102b76c5e5427b50d">transpose</a> () &amp;&amp;</td></tr>
<tr class="memdesc:a6cac08061795894102b76c5e5427b50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>result&lt;option&lt;T&gt;, E&gt;</code> into <code>option&lt;result&lt;T, E&gt;&gt;</code>  <br /></td></tr>
<tr class="separator:a6cac08061795894102b76c5e5427b50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805656c75187a25047a75a2f209aee88" id="r_a805656c75187a25047a75a2f209aee88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; <a class="el" href="classsumty_1_1result.html">E</a>, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a805656c75187a25047a75a2f209aee88">invert</a> () <a class="el" href="classsumty_1_1result.html">const</a> &amp;</td></tr>
<tr class="memdesc:a805656c75187a25047a75a2f209aee88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the ok and error types of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a805656c75187a25047a75a2f209aee88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad5979c728856e9d92461551c3e1797" id="r_a3ad5979c728856e9d92461551c3e1797"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; <a class="el" href="classsumty_1_1result.html">E</a>, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a3ad5979c728856e9d92461551c3e1797">invert</a> () &amp;&amp;</td></tr>
<tr class="memdesc:a3ad5979c728856e9d92461551c3e1797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the ok and error types of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a3ad5979c728856e9d92461551c3e1797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610f631536779752a99a9346cd7f1055" id="r_a610f631536779752a99a9346cd7f1055"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:a610f631536779752a99a9346cd7f1055"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a610f631536779752a99a9346cd7f1055">transform_error</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) &amp;</td></tr>
<tr class="memdesc:a610f631536779752a99a9346cd7f1055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perforams a transformation on the error value of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a610f631536779752a99a9346cd7f1055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5862690fd808854bb4af0b7793ce1c72" id="r_a5862690fd808854bb4af0b7793ce1c72"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:a5862690fd808854bb4af0b7793ce1c72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a5862690fd808854bb4af0b7793ce1c72">transform_error</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;</td></tr>
<tr class="memdesc:a5862690fd808854bb4af0b7793ce1c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perforams a transformation on the error value of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a5862690fd808854bb4af0b7793ce1c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed39d0f8e1fc34a33547f4e0a8c4763" id="r_a2ed39d0f8e1fc34a33547f4e0a8c4763"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:a2ed39d0f8e1fc34a33547f4e0a8c4763"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a2ed39d0f8e1fc34a33547f4e0a8c4763">transform_error</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) &amp;&amp;</td></tr>
<tr class="memdesc:a2ed39d0f8e1fc34a33547f4e0a8c4763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perforams a transformation on the error value of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a2ed39d0f8e1fc34a33547f4e0a8c4763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d61c4713e392b4b7dc0d94269520e5" id="r_a77d61c4713e392b4b7dc0d94269520e5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:a77d61c4713e392b4b7dc0d94269520e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a77d61c4713e392b4b7dc0d94269520e5">transform_error</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:a77d61c4713e392b4b7dc0d94269520e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perforams a transformation on the error value of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a77d61c4713e392b4b7dc0d94269520e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c341e98b54b0017bed0e1911edd3ec" id="r_a19c341e98b54b0017bed0e1911edd3ec"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:a19c341e98b54b0017bed0e1911edd3ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a19c341e98b54b0017bed0e1911edd3ec">map_error</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) &amp;</td></tr>
<tr class="memdesc:a19c341e98b54b0017bed0e1911edd3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perforams a transformation on the error value of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a19c341e98b54b0017bed0e1911edd3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe72d0f48f89e77a23bd0e4f8503b595" id="r_afe72d0f48f89e77a23bd0e4f8503b595"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:afe72d0f48f89e77a23bd0e4f8503b595"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#afe72d0f48f89e77a23bd0e4f8503b595">map_error</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;</td></tr>
<tr class="memdesc:afe72d0f48f89e77a23bd0e4f8503b595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perforams a transformation on the error value of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:afe72d0f48f89e77a23bd0e4f8503b595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c844e364e67484cc3baa71b0b5e4199" id="r_a5c844e364e67484cc3baa71b0b5e4199"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:a5c844e364e67484cc3baa71b0b5e4199"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a5c844e364e67484cc3baa71b0b5e4199">map_error</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) &amp;&amp;</td></tr>
<tr class="memdesc:a5c844e364e67484cc3baa71b0b5e4199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perforams a transformation on the error value of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a5c844e364e67484cc3baa71b0b5e4199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf0158267be5cd7c52efbae8b88d690" id="r_a1cf0158267be5cd7c52efbae8b88d690"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </td></tr>
<tr class="memitem:a1cf0158267be5cd7c52efbae8b88d690"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a1cf0158267be5cd7c52efbae8b88d690">map_error</a> (<a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">f</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:a1cf0158267be5cd7c52efbae8b88d690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perforams a transformation on the error value of a <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a1cf0158267be5cd7c52efbae8b88d690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2208991e2042cbd89a22efa8fdace6" id="r_aab2208991e2042cbd89a22efa8fdace6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; <a class="el" href="classsumty_1_1result.html">reference</a>, <a class="el" href="classsumty_1_1result.html">error_reference</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#aab2208991e2042cbd89a22efa8fdace6">ref</a> () <a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:aab2208991e2042cbd89a22efa8fdace6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="classsumty_1_1result.html">result</a> reference into a <a class="el" href="classsumty_1_1result.html">result</a> of references.  <br /></td></tr>
<tr class="separator:aab2208991e2042cbd89a22efa8fdace6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a886492e6e8f5addbe596c77708250e" id="r_a3a886492e6e8f5addbe596c77708250e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; <a class="el" href="classsumty_1_1result.html">const_reference</a>, <a class="el" href="classsumty_1_1result.html">error_const_reference</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a3a886492e6e8f5addbe596c77708250e">ref</a> () <a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:a3a886492e6e8f5addbe596c77708250e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="classsumty_1_1result.html">result</a> reference into a <a class="el" href="classsumty_1_1result.html">result</a> of references.  <br /></td></tr>
<tr class="separator:a3a886492e6e8f5addbe596c77708250e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934c049ad95a5575df040397a1f20387" id="r_a934c049ad95a5575df040397a1f20387"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; <a class="el" href="classsumty_1_1result.html">const_reference</a>, <a class="el" href="classsumty_1_1result.html">error_const_reference</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a934c049ad95a5575df040397a1f20387">cref</a> () <a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:a934c049ad95a5575df040397a1f20387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="classsumty_1_1result.html">result</a> reference into a <a class="el" href="classsumty_1_1result.html">result</a> of references.  <br /></td></tr>
<tr class="separator:a934c049ad95a5575df040397a1f20387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727c305ee903a4a61093e513d865739f" id="r_a727c305ee903a4a61093e513d865739f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1option.html">option</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a727c305ee903a4a61093e513d865739f">or_none</a> () <a class="el" href="classsumty_1_1result.html">const</a> &amp;<a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:a727c305ee903a4a61093e513d865739f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards error values and converts into an <a class="el" href="classsumty_1_1option.html">option</a>.  <br /></td></tr>
<tr class="separator:a727c305ee903a4a61093e513d865739f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0484cd9f647695a31a901632d27d6106" id="r_a0484cd9f647695a31a901632d27d6106"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1option.html">option</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a0484cd9f647695a31a901632d27d6106">or_none</a> () &amp;&amp;</td></tr>
<tr class="memdesc:a0484cd9f647695a31a901632d27d6106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards error values and converts into an <a class="el" href="classsumty_1_1option.html">option</a>.  <br /></td></tr>
<tr class="separator:a0484cd9f647695a31a901632d27d6106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8f599f5c9abe7544dcbbe346166bd2" id="r_afa8f599f5c9abe7544dcbbe346166bd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1option.html">option</a>&lt; <a class="el" href="classsumty_1_1result.html">E</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#afa8f599f5c9abe7544dcbbe346166bd2">error_or_none</a> () <a class="el" href="classsumty_1_1result.html">const</a> &amp;<a class="el" href="classsumty_1_1result.html">noexcept</a></td></tr>
<tr class="memdesc:afa8f599f5c9abe7544dcbbe346166bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards ok value and converts into an <a class="el" href="classsumty_1_1option.html">option</a>.  <br /></td></tr>
<tr class="separator:afa8f599f5c9abe7544dcbbe346166bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed49e6115fef063039acce34e03813e3" id="r_aed49e6115fef063039acce34e03813e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1option.html">option</a>&lt; <a class="el" href="classsumty_1_1result.html">E</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#aed49e6115fef063039acce34e03813e3">error_or_none</a> () &amp;&amp;</td></tr>
<tr class="memdesc:aed49e6115fef063039acce34e03813e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards ok value and converts into an <a class="el" href="classsumty_1_1option.html">option</a>.  <br /></td></tr>
<tr class="separator:aed49e6115fef063039acce34e03813e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54263fe060a2027fef396d47ec9fc7ce" id="r_a54263fe060a2027fef396d47ec9fc7ce"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a54263fe060a2027fef396d47ec9fc7ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a54263fe060a2027fef396d47ec9fc7ce">emplace</a> (<a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;... <a class="el" href="classsumty_1_1result.html">args</a>)</td></tr>
<tr class="memdesc:a54263fe060a2027fef396d47ec9fc7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new ok value in place into the <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a54263fe060a2027fef396d47ec9fc7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0064b897009c327b8d50dbc3c28de76f" id="r_a0064b897009c327b8d50dbc3c28de76f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </td></tr>
<tr class="memitem:a0064b897009c327b8d50dbc3c28de76f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a0064b897009c327b8d50dbc3c28de76f">emplace</a> (std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; <a class="el" href="classsumty_1_1result.html">ilist</a>, <a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;... <a class="el" href="classsumty_1_1result.html">args</a>)</td></tr>
<tr class="memdesc:a0064b897009c327b8d50dbc3c28de76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new ok value in place into the <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a0064b897009c327b8d50dbc3c28de76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1d354814cd785a8d732c3f4645c820" id="r_afa1d354814cd785a8d732c3f4645c820"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:afa1d354814cd785a8d732c3f4645c820"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">error_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#afa1d354814cd785a8d732c3f4645c820">emplace_error</a> (<a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;... <a class="el" href="classsumty_1_1result.html">args</a>)</td></tr>
<tr class="memdesc:afa1d354814cd785a8d732c3f4645c820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new error value in place into the <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:afa1d354814cd785a8d732c3f4645c820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebda0806feccffeb19f85eb484e55ef" id="r_a2ebda0806feccffeb19f85eb484e55ef"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </td></tr>
<tr class="memitem:a2ebda0806feccffeb19f85eb484e55ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">error_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a2ebda0806feccffeb19f85eb484e55ef">emplace_error</a> (std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; <a class="el" href="classsumty_1_1result.html">ilist</a>, <a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;... <a class="el" href="classsumty_1_1result.html">args</a>)</td></tr>
<tr class="memdesc:a2ebda0806feccffeb19f85eb484e55ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new error value in place into the <a class="el" href="classsumty_1_1result.html">result</a>.  <br /></td></tr>
<tr class="separator:a2ebda0806feccffeb19f85eb484e55ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f575e3e78ea2171d1be475f7f9a2d8" id="r_ae2f575e3e78ea2171d1be475f7f9a2d8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:ae2f575e3e78ea2171d1be475f7f9a2d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a> (<a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">visitor</a>) &amp;</td></tr>
<tr class="memdesc:ae2f575e3e78ea2171d1be475f7f9a2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a visitor witht he contained value.  <br /></td></tr>
<tr class="separator:ae2f575e3e78ea2171d1be475f7f9a2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeca86cd9abb551e0c1e52ba81289f29" id="r_aeeca86cd9abb551e0c1e52ba81289f29"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:aeeca86cd9abb551e0c1e52ba81289f29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#aeeca86cd9abb551e0c1e52ba81289f29">visit</a> (<a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">visitor</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;</td></tr>
<tr class="memdesc:aeeca86cd9abb551e0c1e52ba81289f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a visitor witht he contained value.  <br /></td></tr>
<tr class="separator:aeeca86cd9abb551e0c1e52ba81289f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaaf65bdef1581aff9bda2ed4174143d" id="r_adaaf65bdef1581aff9bda2ed4174143d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:adaaf65bdef1581aff9bda2ed4174143d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#adaaf65bdef1581aff9bda2ed4174143d">visit</a> (<a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">visitor</a>) &amp;&amp;</td></tr>
<tr class="memdesc:adaaf65bdef1581aff9bda2ed4174143d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a visitor witht he contained value.  <br /></td></tr>
<tr class="separator:adaaf65bdef1581aff9bda2ed4174143d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b9d6a30c96d7caac920ce264c66de1" id="r_a12b9d6a30c96d7caac920ce264c66de1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:a12b9d6a30c96d7caac920ce264c66de1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a12b9d6a30c96d7caac920ce264c66de1">visit</a> (<a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">visitor</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:a12b9d6a30c96d7caac920ce264c66de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a visitor witht he contained value.  <br /></td></tr>
<tr class="separator:a12b9d6a30c96d7caac920ce264c66de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1656bb14f0a45ec7cfa81bb960acf924" id="r_a1656bb14f0a45ec7cfa81bb960acf924"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:a1656bb14f0a45ec7cfa81bb960acf924"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a1656bb14f0a45ec7cfa81bb960acf924">visit_informed</a> (<a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">visitor</a>) &amp;</td></tr>
<tr class="memdesc:a1656bb14f0a45ec7cfa81bb960acf924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a visitor with the contained value and meta data.  <br /></td></tr>
<tr class="separator:a1656bb14f0a45ec7cfa81bb960acf924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb3a178a071dfb5bdecb8607d446a4b" id="r_aebb3a178a071dfb5bdecb8607d446a4b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:aebb3a178a071dfb5bdecb8607d446a4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#aebb3a178a071dfb5bdecb8607d446a4b">visit_informed</a> (<a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">visitor</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;</td></tr>
<tr class="memdesc:aebb3a178a071dfb5bdecb8607d446a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a visitor with the contained value and meta data.  <br /></td></tr>
<tr class="separator:aebb3a178a071dfb5bdecb8607d446a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b181b22d126a38b86f5a93035b6b7bc" id="r_a2b181b22d126a38b86f5a93035b6b7bc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:a2b181b22d126a38b86f5a93035b6b7bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a2b181b22d126a38b86f5a93035b6b7bc">visit_informed</a> (<a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">visitor</a>) &amp;&amp;</td></tr>
<tr class="memdesc:a2b181b22d126a38b86f5a93035b6b7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a visitor with the contained value and meta data.  <br /></td></tr>
<tr class="separator:a2b181b22d126a38b86f5a93035b6b7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdb84ccc3402ad25040ee85cbffb9a3" id="r_affdb84ccc3402ad25040ee85cbffb9a3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:affdb84ccc3402ad25040ee85cbffb9a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#affdb84ccc3402ad25040ee85cbffb9a3">visit_informed</a> (<a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;<a class="el" href="classsumty_1_1result.html">visitor</a>) <a class="el" href="classsumty_1_1result.html">const</a> &amp;&amp;</td></tr>
<tr class="memdesc:affdb84ccc3402ad25040ee85cbffb9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a visitor with the contained value and meta data.  <br /></td></tr>
<tr class="separator:affdb84ccc3402ad25040ee85cbffb9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3be55eeb914e44478166807b43eef9" id="r_a9a3be55eeb914e44478166807b43eef9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a9a3be55eeb914e44478166807b43eef9">swap</a> (<a class="el" href="classsumty_1_1result.html">result</a> &amp;<a class="el" href="classsumty_1_1result.html">other</a>) <a class="el" href="classsumty_1_1result.html">CONDITIONALLY_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9a3be55eeb914e44478166807b43eef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two <a class="el" href="classsumty_1_1result.html">result</a> instances.  <br /></td></tr>
<tr class="separator:a9a3be55eeb914e44478166807b43eef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:a3bdfc23d3431292af06fb30707025eef" id="r_a3bdfc23d3431292af06fb30707025eef"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> IDX, <a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </td></tr>
<tr class="memitem:a3bdfc23d3431292af06fb30707025eef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a> (<a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;<a class="el" href="classsumty_1_1result.html">res</a>)</td></tr>
<tr class="memdesc:a3bdfc23d3431292af06fb30707025eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classsumty_1_1result.html">result</a> value by index, as if it were a <a class="el" href="classsumty_1_1variant.html">variant</a>.  <br /></td></tr>
<tr class="separator:a3bdfc23d3431292af06fb30707025eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52da98d92f832ae5c248824107af2f3" id="r_ac52da98d92f832ae5c248824107af2f3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> IDX, <a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </td></tr>
<tr class="memitem:ac52da98d92f832ae5c248824107af2f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ac52da98d92f832ae5c248824107af2f3">get</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;<a class="el" href="classsumty_1_1result.html">res</a>)</td></tr>
<tr class="memdesc:ac52da98d92f832ae5c248824107af2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classsumty_1_1result.html">result</a> value by index, as if it were a <a class="el" href="classsumty_1_1variant.html">variant</a>.  <br /></td></tr>
<tr class="separator:ac52da98d92f832ae5c248824107af2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa474b568525391fad783e31ca80d7afe" id="r_aa474b568525391fad783e31ca80d7afe"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> IDX, <a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </td></tr>
<tr class="memitem:aa474b568525391fad783e31ca80d7afe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#aa474b568525391fad783e31ca80d7afe">get</a> (<a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&amp;<a class="el" href="classsumty_1_1result.html">res</a>)</td></tr>
<tr class="memdesc:aa474b568525391fad783e31ca80d7afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classsumty_1_1result.html">result</a> value by index, as if it were a <a class="el" href="classsumty_1_1variant.html">variant</a>.  <br /></td></tr>
<tr class="separator:aa474b568525391fad783e31ca80d7afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b420afaed24b901f34bae122a9b9c1" id="r_a63b420afaed24b901f34bae122a9b9c1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> IDX, <a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </td></tr>
<tr class="memitem:a63b420afaed24b901f34bae122a9b9c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a63b420afaed24b901f34bae122a9b9c1">get</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&amp;<a class="el" href="classsumty_1_1result.html">res</a>)</td></tr>
<tr class="memdesc:a63b420afaed24b901f34bae122a9b9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classsumty_1_1result.html">result</a> value by index, as if it were a <a class="el" href="classsumty_1_1variant.html">variant</a>.  <br /></td></tr>
<tr class="separator:a63b420afaed24b901f34bae122a9b9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdfc23d3431292af06fb30707025eef" id="r_a3bdfc23d3431292af06fb30707025eef"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , <a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </td></tr>
<tr class="memitem:a3bdfc23d3431292af06fb30707025eef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a> (<a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;<a class="el" href="classsumty_1_1result.html">res</a>)</td></tr>
<tr class="memdesc:a3bdfc23d3431292af06fb30707025eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classsumty_1_1result.html">result</a> value by type, as if it were a <a class="el" href="classsumty_1_1variant.html">variant</a>.  <br /></td></tr>
<tr class="separator:a3bdfc23d3431292af06fb30707025eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52da98d92f832ae5c248824107af2f3" id="r_ac52da98d92f832ae5c248824107af2f3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , <a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </td></tr>
<tr class="memitem:ac52da98d92f832ae5c248824107af2f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#ac52da98d92f832ae5c248824107af2f3">get</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;<a class="el" href="classsumty_1_1result.html">res</a>)</td></tr>
<tr class="memdesc:ac52da98d92f832ae5c248824107af2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classsumty_1_1result.html">result</a> value by type, as if it were a <a class="el" href="classsumty_1_1variant.html">variant</a>.  <br /></td></tr>
<tr class="separator:ac52da98d92f832ae5c248824107af2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa474b568525391fad783e31ca80d7afe" id="r_aa474b568525391fad783e31ca80d7afe"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , <a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </td></tr>
<tr class="memitem:aa474b568525391fad783e31ca80d7afe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#aa474b568525391fad783e31ca80d7afe">get</a> (<a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&amp;<a class="el" href="classsumty_1_1result.html">res</a>)</td></tr>
<tr class="memdesc:aa474b568525391fad783e31ca80d7afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classsumty_1_1result.html">result</a> value by type, as if it were a <a class="el" href="classsumty_1_1variant.html">variant</a>.  <br /></td></tr>
<tr class="separator:aa474b568525391fad783e31ca80d7afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b420afaed24b901f34bae122a9b9c1" id="r_a63b420afaed24b901f34bae122a9b9c1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , <a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </td></tr>
<tr class="memitem:a63b420afaed24b901f34bae122a9b9c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a63b420afaed24b901f34bae122a9b9c1">get</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&amp;<a class="el" href="classsumty_1_1result.html">res</a>)</td></tr>
<tr class="memdesc:a63b420afaed24b901f34bae122a9b9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classsumty_1_1result.html">result</a> value by type, as if it were a <a class="el" href="classsumty_1_1variant.html">variant</a>.  <br /></td></tr>
<tr class="separator:a63b420afaed24b901f34bae122a9b9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25758407021987e62273a23cf19772ed" id="r_a25758407021987e62273a23cf19772ed"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:a25758407021987e62273a23cf19772ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a25758407021987e62273a23cf19772ed">operator==</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;<a class="el" href="classsumty_1_1result.html">lhs</a>, <a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a>, <a class="el" href="classsumty_1_1result.html">V</a> &gt; &amp;<a class="el" href="classsumty_1_1result.html">rhs</a>)</td></tr>
<tr class="memdesc:a25758407021987e62273a23cf19772ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classsumty_1_1result.html">result</a> instances for equality.  <br /></td></tr>
<tr class="separator:a25758407021987e62273a23cf19772ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d8538929c7284c15bdb049d28ca7dd" id="r_aa2d8538929c7284c15bdb049d28ca7dd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:aa2d8538929c7284c15bdb049d28ca7dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#aa2d8538929c7284c15bdb049d28ca7dd">operator==</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;<a class="el" href="classsumty_1_1result.html">lhs</a>, <a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">U</a> &amp;<a class="el" href="classsumty_1_1result.html">rhs</a>)</td></tr>
<tr class="memdesc:aa2d8538929c7284c15bdb049d28ca7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="classsumty_1_1result.html">result</a> with a plain value for equality.  <br /></td></tr>
<tr class="separator:aa2d8538929c7284c15bdb049d28ca7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6627edf63b5a5377eb699a75288afc" id="r_a6e6627edf63b5a5377eb699a75288afc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </td></tr>
<tr class="memitem:a6e6627edf63b5a5377eb699a75288afc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a6e6627edf63b5a5377eb699a75288afc">operator==</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">U</a> &amp;<a class="el" href="classsumty_1_1result.html">lhs</a>, <a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;<a class="el" href="classsumty_1_1result.html">rhs</a>)</td></tr>
<tr class="memdesc:a6e6627edf63b5a5377eb699a75288afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="classsumty_1_1result.html">result</a> with a plain value for equality.  <br /></td></tr>
<tr class="separator:a6e6627edf63b5a5377eb699a75288afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fed478f3c0f41a129a746726344d911" id="r_a8fed478f3c0f41a129a746726344d911"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:a8fed478f3c0f41a129a746726344d911"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a8fed478f3c0f41a129a746726344d911">operator==</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;<a class="el" href="classsumty_1_1result.html">lhs</a>, <a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1error__t.html">error_t</a>&lt; <a class="el" href="classsumty_1_1result.html">V</a> &gt; &amp;<a class="el" href="classsumty_1_1result.html">rhs</a>)</td></tr>
<tr class="memdesc:a8fed478f3c0f41a129a746726344d911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="classsumty_1_1result.html">result</a> with an error value for equality.  <br /></td></tr>
<tr class="separator:a8fed478f3c0f41a129a746726344d911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa078c1d74cb5a27e6d6153d17e3a372e" id="r_aa078c1d74cb5a27e6d6153d17e3a372e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </td></tr>
<tr class="memitem:aa078c1d74cb5a27e6d6153d17e3a372e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#aa078c1d74cb5a27e6d6153d17e3a372e">operator==</a> (<a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1error__t.html">error_t</a>&lt; <a class="el" href="classsumty_1_1result.html">V</a> &gt; &amp;<a class="el" href="classsumty_1_1result.html">lhs</a>, <a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;<a class="el" href="classsumty_1_1result.html">rhs</a>)</td></tr>
<tr class="memdesc:aa078c1d74cb5a27e6d6153d17e3a372e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="classsumty_1_1result.html">result</a> with an error value for equality.  <br /></td></tr>
<tr class="separator:aa078c1d74cb5a27e6d6153d17e3a372e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8534d4fb80e4c99b43950f8d4954606c" id="r_a8534d4fb80e4c99b43950f8d4954606c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </td></tr>
<tr class="memitem:a8534d4fb80e4c99b43950f8d4954606c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1result.html#a8534d4fb80e4c99b43950f8d4954606c">swap</a> (<a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;<a class="el" href="classsumty_1_1result.html">a</a>, <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;<a class="el" href="classsumty_1_1result.html">b</a>) <a class="el" href="classsumty_1_1result.html">CONDITIONALLY_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8534d4fb80e4c99b43950f8d4954606c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two <a class="el" href="classsumty_1_1result.html">result</a> instances.  <br /></td></tr>
<tr class="separator:a8534d4fb80e4c99b43950f8d4954606c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename E&gt;<br />
class sumty::result&lt; T, E &gt;</div><p>Type that contains an ok value, or an error. </p>
<p><a class="el" href="classsumty_1_1result.html">result</a> is a reimplementation of <code>std::expected</code> with several improvements. The key difference is that references (lvalue and rvalue) are can be used for both the value type and the error type, and <code>void</code> can be used for the error type (<code>std::expected</code> already allows <code>void</code> for the value type).</p>
<p>Internally, <code>result&lt;T, E&gt;</code> is represented as a <a class="el" href="classsumty_1_1variant.html">variant&lt;T, E&gt;</a>. Thus, <a class="el" href="classsumty_1_1result.html">result</a> benefits from the size optimizations implemented by <a class="el" href="classsumty_1_1variant.html">variant</a> (see <a class="el" href="classsumty_1_1variant.html">variant</a> documentation for details). A couple special case <a class="el" href="classsumty_1_1result.html">result</a> size examples are shown in the example below.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_class" href="classsumty_1_1result.html">my_error</a> {}; <span class="comment">// NOTE: empty type</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">sizeof</span>(<a class="code hl_class" href="classsumty_1_1result.html">result&lt;void, my_error&gt;</a>) == <span class="keyword">sizeof</span>(<span class="keywordtype">bool</span>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">sizeof</span>(<a class="code hl_class" href="classsumty_1_1result.html">result&lt;int&amp;, my_error&gt;</a>) == <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>*));</div>
<div class="ttc" id="aclasssumty_1_1result_html"><div class="ttname"><a href="classsumty_1_1result.html">sumty::result</a></div><div class="ttdoc">Type that contains an ok value, or an error.</div><div class="ttdef"><b>Definition</b> result.hpp:1262</div></div>
</div><!-- fragment --><p>In practice, the benefit of <a class="el" href="classsumty_1_1result.html">result</a> over <code>std::expected</code> is that <a class="el" href="classsumty_1_1result.html">result</a> can be used in more places, especially with generic code. A generic function (function template) that wants to be able to return a value of any type, but also allow that return value to instead communicate an error on failure can simply return a <code>result&lt;T, E&gt;</code>, where <code>T</code> is now allowed to be a reference or even <code>void</code> (and so is <code>E</code>, for that matter).</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_class" href="classsumty_1_1result.html">negative_number_error</a> {};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// If value is negative, returns a negative_number_error. Otherwise,</span></div>
<div class="line"><span class="comment">// invokes func with the value as an argument and returns the result,</span></div>
<div class="line"><span class="comment">// even if the result is void or a reference.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;std::invoke_result_t&lt;F&gt;</a>, <a class="code hl_class" href="classsumty_1_1result.html">negative_number_error</a>&gt;</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">call_if_non_negative</a>(<span class="keywordtype">int</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>, <a class="code hl_class" href="classsumty_1_1result.html">F</a>&amp;&amp; <a class="code hl_class" href="classsumty_1_1result.html">func</a>) {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a> &lt; 0) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_class" href="classsumty_1_1result.html">error&lt;negative_number_error&gt;</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We have to specialize for void because of language limitations</span></div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_void_v&lt;std::invoke_result_t&lt;F&gt;&gt;) {</div>
<div class="line">        std::invoke(std::forward&lt;F&gt;(func), <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">        <span class="keywordflow">return</span> void_v; <span class="comment">// converts to result&lt;void, E&gt;</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> std::invoke(std::forward&lt;F&gt;(func), <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclasssumty_1_1result_html_a0fe474d55f5039d5c97b6b8dd5a25a66"><div class="ttname"><a href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">sumty::result::value</a></div><div class="ttdeci">constexpr reference value() &amp;</div><div class="ttdoc">Accesses the ok value contained in the result.</div><div class="ttdef"><b>Definition</b> result.hpp:2333</div></div>
</div><!-- fragment --><p>The power of <a class="el" href="classsumty_1_1result.html">result</a> is also enhanced when used in combination with <a class="el" href="classsumty_1_1error__set.html">error_set</a>. <a class="el" href="classsumty_1_1error__set.html">error_set</a> makes it easy to represent a set of different error possibilities of different types in a single value, and simplifies error propagation when used with <a class="el" href="classsumty_1_1result.html">result</a>. See the documentation of <a class="el" href="classsumty_1_1error__set.html">error_set</a> for more details and examples. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab840c474538e57fc70384f5edf2d3f28" name="ab840c474538e57fc70384f5edf2d3f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab840c474538e57fc70384f5edf2d3f28">&#9670;&#160;</a></span>result() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Initializes the <a class="el" href="classsumty_1_1result.html">result</a> with a default constructed ok value.</p>
<h2><a class="anchor" id="autotoc_md325"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">res</a>.<a class="code hl_function" href="classsumty_1_1result.html#a6988ba57722f67cbb444b0931468282e">has_value</a>());</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">res</a> == 0);</div>
<div class="ttc" id="aclasssumty_1_1result_html_a6988ba57722f67cbb444b0931468282e"><div class="ttname"><a href="classsumty_1_1result.html#a6988ba57722f67cbb444b0931468282e">sumty::result::has_value</a></div><div class="ttdeci">constexpr bool has_value() const noexcept</div><div class="ttdoc">Returns true if the result contains an ok value.</div><div class="ttdef"><b>Definition</b> result.hpp:2192</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a524fbfb4fe0750f412c05377945468aa" name="a524fbfb4fe0750f412c05377945468aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a524fbfb4fe0750f412c05377945468aa">&#9670;&#160;</a></span>result() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>If the source <a class="el" href="classsumty_1_1result.html">result</a> has an ok value, the new <a class="el" href="classsumty_1_1result.html">result</a> is initialized with a copy constructed ok value. If the source <a class="el" href="classsumty_1_1result.html">result</a> has an error value, the new <a class="el" href="classsumty_1_1result.html">result</a> is initialized with a copy constructed error.</p>
<h2><a class="anchor" id="autotoc_md326"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">result&lt;int, std::string&gt; res1_copy{res1};</div>
<div class="line">result&lt;int, std::string&gt; res2_copy{res2};</div>
<div class="line"> </div>
<div class="line">assert(res1_copy.has_value());</div>
<div class="line">assert(*res1_copy == 42);</div>
<div class="line"> </div>
<div class="line">assert(!res2_copy.has_value());</div>
<div class="line">assert(res2_copy.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="afad84b79e65d7fa259f0e5f52057df33" name="afad84b79e65d7fa259f0e5f52057df33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad84b79e65d7fa259f0e5f52057df33">&#9670;&#160;</a></span>result() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>If the source <a class="el" href="classsumty_1_1result.html">result</a> has an ok value, the new <a class="el" href="classsumty_1_1result.html">result</a> is initialized with a move constructed ok value. If the source <a class="el" href="classsumty_1_1result.html">result</a> has an error value, the new <a class="el" href="classsumty_1_1result.html">result</a> is initialized with a move constructed error.</p>
<h2><a class="anchor" id="autotoc_md327"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">result&lt;int, std::string&gt; res1_copy{std::move(res1)};</div>
<div class="line">result&lt;int, std::string&gt; res2_copy{std::move(res2)};</div>
<div class="line"> </div>
<div class="line">assert(res1_copy.has_value());</div>
<div class="line">assert(*res1_copy == 42);</div>
<div class="line"> </div>
<div class="line">assert(!res2_copy.has_value());</div>
<div class="line">assert(res2_copy.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae46c093d93908baa12792e6294ac6bfc" name="ae46c093d93908baa12792e6294ac6bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46c093d93908baa12792e6294ac6bfc">&#9670;&#160;</a></span>result() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">CONDITONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype">std::in_place_t&#160;</td>
          <td class="paramname"><em>inplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplacement constructor. </p>
<p>The <a class="el" href="classsumty_1_1result.html">result</a> is initialized such that an ok value is constructed in place from the forwarded arguments.</p>
<p>This constructor is <code>explicit</code> if <code>inplace</code> is the only argument.</p>
<h2><a class="anchor" id="autotoc_md328"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;std::string, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{std::in_place, 5, <span class="charliteral">&#39;a&#39;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">res</a>.<a class="code hl_function" href="classsumty_1_1result.html#a6988ba57722f67cbb444b0931468282e">has_value</a>());</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">res</a> == <span class="stringliteral">&quot;aaaaa&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac56a2d881e3e070c1b536d630a94ce6b" name="ac56a2d881e3e070c1b536d630a94ce6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56a2d881e3e070c1b536d630a94ce6b">&#9670;&#160;</a></span>result() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype">std::in_place_t&#160;</td>
          <td class="paramname"><em>inplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplacement constructor with initializer list. </p>
<p>The <a class="el" href="classsumty_1_1result.html">result</a> is initialized such that an ok value is constructed in place from the forwarded arguments.</p>
<h2><a class="anchor" id="autotoc_md329"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;std::vector&lt;int&gt;</a>, std::string&gt; <a class="code hl_class" href="classsumty_1_1result.html">res</a>{</div>
<div class="line">        std::in_place, {1, 2, 3, 4, 5}};</div>
<div class="line"> </div>
<div class="line">assert(res.has_value());</div>
<div class="line"> </div>
<div class="line">assert(res-&gt;size() == 5);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1a767f4097b0deff0139d55b697b76e1" name="a1a767f4097b0deff0139d55b697b76e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a767f4097b0deff0139d55b697b76e1">&#9670;&#160;</a></span>result() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype">std::in_place_index_t&lt; 0 &gt;&#160;</td>
          <td class="paramname"><em>inplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplacement constructor. </p>
<p>The <a class="el" href="classsumty_1_1result.html">result</a> is initialized such that an ok value is constructed in place from the forwarded arguments.</p>
<p>This constructor is <code>explicit</code> if <code>inplace</code> is the only argument.</p>
<h2><a class="anchor" id="autotoc_md330"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;std::string, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{std::in_place_index&lt;0&gt;, 5, <span class="charliteral">&#39;a&#39;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">res</a>.<a class="code hl_function" href="classsumty_1_1result.html#a6988ba57722f67cbb444b0931468282e">has_value</a>());</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">res</a> == <span class="stringliteral">&quot;aaaaa&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a30a69f1cd0ffab673cab649cb44ae0b8" name="a30a69f1cd0ffab673cab649cb44ae0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a69f1cd0ffab673cab649cb44ae0b8">&#9670;&#160;</a></span>result() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype">std::in_place_index_t&lt; 0 &gt;&#160;</td>
          <td class="paramname"><em>inplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplacement constructor with initializer list. </p>
<p>The <a class="el" href="classsumty_1_1result.html">result</a> is initialized such that an ok value is constructed in place from the forwarded arguments.</p>
<h2><a class="anchor" id="autotoc_md331"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;std::vector&lt;int&gt;</a>, std::string&gt; <a class="code hl_class" href="classsumty_1_1result.html">res</a>{</div>
<div class="line">        std::in_place_index&lt;0&gt;, {1, 2, 3, 4, 5}};</div>
<div class="line"> </div>
<div class="line">assert(res.has_value());</div>
<div class="line"> </div>
<div class="line">assert(res-&gt;size() == 5);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad5d2a5c20888c283e99c1ea16121a7f4" name="ad5d2a5c20888c283e99c1ea16121a7f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d2a5c20888c283e99c1ea16121a7f4">&#9670;&#160;</a></span>result() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">CONDITONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">in_place_error_t</a>&#160;</td>
          <td class="paramname"><em>inplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Error emplacement constructor. </p>
<p>The <a class="el" href="classsumty_1_1result.html">result</a> is initialized such that an error value is constructed in place from the forwarded arguments.</p>
<h2><a class="anchor" id="autotoc_md332"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;void, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{in_place_error, 5, <span class="charliteral">&#39;a&#39;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(!<a class="code hl_class" href="classsumty_1_1result.html">res</a>.<a class="code hl_function" href="classsumty_1_1result.html#a6988ba57722f67cbb444b0931468282e">has_value</a>());</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">res</a>.<a class="code hl_function" href="classsumty_1_1result.html#a1fc95966d58ae6508accb53ae1617b16">error</a>() == <span class="stringliteral">&quot;aaaaa&quot;</span>);</div>
<div class="ttc" id="aclasssumty_1_1result_html_a1fc95966d58ae6508accb53ae1617b16"><div class="ttname"><a href="classsumty_1_1result.html#a1fc95966d58ae6508accb53ae1617b16">sumty::result::error</a></div><div class="ttdeci">constexpr error_reference error() &amp;noexcept</div><div class="ttdoc">Accesses the error value contained in the result.</div><div class="ttdef"><b>Definition</b> result.hpp:2435</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae0dc049c0a34739004c5a7706dc02585" name="ae0dc049c0a34739004c5a7706dc02585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0dc049c0a34739004c5a7706dc02585">&#9670;&#160;</a></span>result() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">in_place_error_t</a>&#160;</td>
          <td class="paramname"><em>inplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Error emplacement constructor with initializer list. </p>
<p>The <a class="el" href="classsumty_1_1result.html">result</a> is initialized such that an error value is constructed in place from the forwarded arguments.</p>
<h2><a class="anchor" id="autotoc_md333"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;void, std::vector&lt;int&gt;</a>&gt; <a class="code hl_class" href="classsumty_1_1result.html">res</a>{in_place_error, {1, 2, 3, 4, 5}};</div>
<div class="line"> </div>
<div class="line">assert(!res.has_value());</div>
<div class="line"> </div>
<div class="line">assert(res.error().size() == 5);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae555ba398fae5f24f00722ef632667ec" name="ae555ba398fae5f24f00722ef632667ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae555ba398fae5f24f00722ef632667ec">&#9670;&#160;</a></span>result() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">U</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwarding constructor. </p>
<p>The <a class="el" href="classsumty_1_1result.html">result</a> is initialized such that it contains an ok value that is constructed in place from the forwarded value.</p>
<p>This constructor only participates in overload resolution if the ok value is constructible from the forwarded value, the forwarded value is not of type <code>std::in_place_t</code>, <code>sumty::in_place_t</code>, <code>std::in_place_index_t&lt;0&gt;</code>, <code>sumty::in_place_index_t&lt;0&gt;</code>, <code>std::in_place_index_t&lt;1&gt;</code>, <code>sumty::in_place_index_t&lt;1&gt;</code>, or <code>sumty::in_place_error_t</code>, and either the ok value type is a scalar or the forwarded value is not a <a class="el" href="classsumty_1_1result.html">result</a> instance.</p>
<p>This constructor is <code>explicit</code> if the forwarded value is not implicitly convertible to <code>T</code>.</p>
<h2><a class="anchor" id="autotoc_md334"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a> = 3.14;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">res</a>.<a class="code hl_function" href="classsumty_1_1result.html#a6988ba57722f67cbb444b0931468282e">has_value</a>());</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">res</a> == 3);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2a3b3dcc80ae17306d74bafc683b1080" name="a2a3b3dcc80ae17306d74bafc683b1080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3b3dcc80ae17306d74bafc683b1080">&#9670;&#160;</a></span>result() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">CONDITONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1ok__t.html">ok_t</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>ok</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ok converting constructor. </p>
<p>From an explicit <a class="el" href="classsumty_1_1ok__t.html">ok_t</a> instance, the <a class="el" href="classsumty_1_1result.html">result</a> is constructed such that an ok value is constructed in place from the forwarded value contained in the <a class="el" href="classsumty_1_1ok__t.html">ok_t</a> instance.</p>
<p>This constructor is <code>explicit</code> if <code>U</code> is not implicitly convertible to <code>T</code>.</p>
<h2><a class="anchor" id="autotoc_md335"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a> = <a class="code hl_class" href="classsumty_1_1result.html">ok&lt;float&gt;</a>(3.14);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">res</a>.<a class="code hl_function" href="classsumty_1_1result.html#a6988ba57722f67cbb444b0931468282e">has_value</a>());</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">res</a> == 3);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="afed4a0c5c6bcce05e6ef68439045ea99" name="afed4a0c5c6bcce05e6ef68439045ea99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed4a0c5c6bcce05e6ef68439045ea99">&#9670;&#160;</a></span>result() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1ok__t.html">ok_t</a>&lt; <a class="el" href="classsumty_1_1result.html">void</a> &gt;&#160;</td>
          <td class="paramname"><em>ok</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ok converting constructor for <code>void</code> </p>
<p>From an explicit ok_t&lt;void&gt; instance, the <a class="el" href="classsumty_1_1result.html">result</a> is constructed with an ok value.</p>
<p>This constructor only participates in overload resolution if <code>T</code> is <code>void</code>.</p>
<h2><a class="anchor" id="autotoc_md336"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;void, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a> = <a class="code hl_class" href="classsumty_1_1result.html">ok&lt;void&gt;</a>();</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">res</a>.<a class="code hl_function" href="classsumty_1_1result.html#a6988ba57722f67cbb444b0931468282e">has_value</a>());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac97d5c3019e1853d04518722481711bc" name="ac97d5c3019e1853d04518722481711bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97d5c3019e1853d04518722481711bc">&#9670;&#160;</a></span>result() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">CONDITONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1error__t.html">error_t</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Error converting constructor. </p>
<p>From an explicit <a class="el" href="classsumty_1_1error__t.html">error_t</a> instance, the <a class="el" href="classsumty_1_1result.html">result</a> is constructed such that an error value is constructed in place from the forwarded value contained in the <a class="el" href="classsumty_1_1error__t.html">error_t</a> instance.</p>
<p>This constructor is <code>explicit</code> if <code>U</code> is not implicitly convertible to <code>E</code>.</p>
<h2><a class="anchor" id="autotoc_md337"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a> = <a class="code hl_class" href="classsumty_1_1result.html">error&lt;const char*&gt;</a>(<span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(!<a class="code hl_class" href="classsumty_1_1result.html">res</a>.<a class="code hl_function" href="classsumty_1_1result.html#a6988ba57722f67cbb444b0931468282e">has_value</a>());</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">res</a>.<a class="code hl_function" href="classsumty_1_1result.html#a1fc95966d58ae6508accb53ae1617b16">error</a>() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9fbe72a080bd44a240db44c671aa1ade" name="a9fbe72a080bd44a240db44c671aa1ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fbe72a080bd44a240db44c671aa1ade">&#9670;&#160;</a></span>result() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1error__t.html">error_t</a>&lt; <a class="el" href="classsumty_1_1result.html">void</a> &gt;&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Error converting constructor for <code>void</code> </p>
<p>From an explicit error_t&lt;void&gt; instance, the <a class="el" href="classsumty_1_1result.html">result</a> is constructed with an error value.</p>
<p>This constructor only participates in overload resolution if <code>E</code> is <code>void</code>.</p>
<h2><a class="anchor" id="autotoc_md338"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, void&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a> = <a class="code hl_class" href="classsumty_1_1result.html">error&lt;void&gt;</a>();</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(!<a class="code hl_class" href="classsumty_1_1result.html">res</a>.<a class="code hl_function" href="classsumty_1_1result.html#a6988ba57722f67cbb444b0931468282e">has_value</a>());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="abae7ab1fdf5530ef9867dd2471c6592b" name="abae7ab1fdf5530ef9867dd2471c6592b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae7ab1fdf5530ef9867dd2471c6592b">&#9670;&#160;</a></span>result() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a>, <a class="el" href="classsumty_1_1result.html">V</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting copy constructor. </p>
<p>This constructor converts a <a class="el" href="classsumty_1_1result.html">result</a> with one pair of ok and error types into a </p><dl class="section return"><dt>Returns</dt><dd>of a different pair of ok and error types. This constructor behaves much like the copy constructor, except that a type conversion may occur.</dd></dl>
<p>This constructor only particpates in overload resolution if the ok type <code>T</code> of the destination <a class="el" href="classsumty_1_1result.html">result</a> is constructible from the ok type <code>U</code> of the source <a class="el" href="classsumty_1_1result.html">result</a>, <em>and</em> the error type <code>E</code> of the destiantion <a class="el" href="classsumty_1_1result.html">result</a> is constructible from the error type <code>V</code> of the source <a class="el" href="classsumty_1_1result.html">result</a>.</p>
<p>This constructor is <code>explicit</code> if either <code>U</code> or <code>V</code> is not implicitly convertible to <code>T</code> or <code>E</code>, respectively.</p>
<h2><a class="anchor" id="autotoc_md339"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;float, const char*&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{3.14};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;float, const char*&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">result&lt;int, std::string&gt; res3{res1};</div>
<div class="line">result&lt;int, std::string&gt; res4{res2};</div>
<div class="line"> </div>
<div class="line">assert(res3.has_value());</div>
<div class="line">assert(*res3 == 3);</div>
<div class="line"> </div>
<div class="line">assert(!res4.has_value());</div>
<div class="line">assert(res4.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3d3335f398384b9c609fa8bedfa32545" name="a3d3335f398384b9c609fa8bedfa32545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3335f398384b9c609fa8bedfa32545">&#9670;&#160;</a></span>result() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">result</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a>, <a class="el" href="classsumty_1_1result.html">V</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting move constructor. </p>
<p>This constructor converts a <a class="el" href="classsumty_1_1result.html">result</a> with one pair of ok and error types into a </p><dl class="section return"><dt>Returns</dt><dd>of a different pair of ok and error types. This constructor behaves much like the move constructor, except that a type conversion may occur.</dd></dl>
<p>This constructor only particpates in overload resolution if the ok type <code>T</code> of the destination <a class="el" href="classsumty_1_1result.html">result</a> is constructible from the moved ok type <code>U</code> of the source <a class="el" href="classsumty_1_1result.html">result</a>, <em>and</em> the error type <code>E</code> of the destiantion <a class="el" href="classsumty_1_1result.html">result</a> is constructible from the move error type <code>V</code> of the source <a class="el" href="classsumty_1_1result.html">result</a>.</p>
<p>This constructor is <code>explicit</code> if either <code>U</code> or <code>V</code> is not implicitly convertible to <code>T</code> or <code>E</code>, respectively.</p>
<h2><a class="anchor" id="autotoc_md340"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;float, const char*&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{3.14};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;float, const char*&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">result&lt;int, std::string&gt; res3{std::move(res1)};</div>
<div class="line">result&lt;int, std::string&gt; res4{std::move(res2)};</div>
<div class="line"> </div>
<div class="line">assert(res3.has_value());</div>
<div class="line">assert(*res3 == 3);</div>
<div class="line"> </div>
<div class="line">assert(!res4.has_value());</div>
<div class="line">assert(res4.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8f52676096082d9c53ad3062b76c974e" name="a8f52676096082d9c53ad3062b76c974e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f52676096082d9c53ad3062b76c974e">&#9670;&#160;</a></span>~result()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> ~<a class="el" href="classsumty_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Destroys the contained value in place.</p>
<p>The desctructor is <code>noexcept</code> if both <code>T</code> and <code>E</code> are nothrow destructible. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a62819f8ee94f18955aa983370e6f8d57" name="a62819f8ee94f18955aa983370e6f8d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62819f8ee94f18955aa983370e6f8d57">&#9670;&#160;</a></span>and_then() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> and_then </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a callable to the contents of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, the value is passed into the callable, and the result of invoking the callable is returned from this function. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, the callable is not invoked, and a copy of the error is returned.</p>
<p>This function only participates in overload resultion if the result of invoking the callable is a <a class="el" href="classsumty_1_1result.html">result</a>.</p>
<h2><a class="anchor" id="autotoc_md372"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{-42};</div>
<div class="line">result&lt;int, std::string&gt; res3{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> callable = [](<span class="keywordtype">int</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) -&gt; result&lt;unsigned int, const char*&gt; {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a> &lt; 0) {</div>
<div class="line">        <span class="keywordflow">return</span> error&lt;const char*&gt;(<span class="stringliteral">&quot;negaive value&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_new = res1.and_then(callable);</div>
<div class="line"><span class="keyword">auto</span> res2_new = res2.and_then(callable);</div>
<div class="line"><span class="keyword">auto</span> res3_new = res3.and_then(callable);</div>
<div class="line"> </div>
<div class="line">assert(res1_new.is_ok());</div>
<div class="line">assert(*res1_new == 42);</div>
<div class="line"> </div>
<div class="line">assert(res2_new.is_error());</div>
<div class="line">assert(res2_new.error() == <span class="stringliteral">&quot;negative value&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res3_new.is_error());</div>
<div class="line">assert(res3_new.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2146246884225b7a1dd569cb3ecb3491" name="a2146246884225b7a1dd569cb3ecb3491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2146246884225b7a1dd569cb3ecb3491">&#9670;&#160;</a></span>and_then() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> and_then </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a callable to the contents of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, the value is passed into the callable, and the result of invoking the callable is returned from this function. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, the callable is not invoked, the error is returned.</p>
<p>This function only participates in overload resultion if the result of invoking the callable is a <a class="el" href="classsumty_1_1result.html">result</a>.</p>
<h2><a class="anchor" id="autotoc_md374"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{-42};</div>
<div class="line">result&lt;int, std::string&gt; res3{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> callable = [](<span class="keywordtype">int</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) -&gt; result&lt;unsigned int, const char*&gt; {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a> &lt; 0) {</div>
<div class="line">        <span class="keywordflow">return</span> error&lt;const char*&gt;(<span class="stringliteral">&quot;negaive value&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_new = std::move(res1).and_then(callable);</div>
<div class="line"><span class="keyword">auto</span> res2_new = std::move(res2).and_then(callable);</div>
<div class="line"><span class="keyword">auto</span> res3_new = std::move(res3).and_then(callable);</div>
<div class="line"> </div>
<div class="line">assert(res1_new.is_ok());</div>
<div class="line">assert(*res1_new == 42);</div>
<div class="line"> </div>
<div class="line">assert(res2_new.is_error());</div>
<div class="line">assert(res2_new.error() == <span class="stringliteral">&quot;negative value&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res3_new.is_error());</div>
<div class="line">assert(res3_new.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="adabc593e326c7a64748c51b9d549f75a" name="adabc593e326c7a64748c51b9d549f75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabc593e326c7a64748c51b9d549f75a">&#9670;&#160;</a></span>and_then() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> and_then </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a callable to the contents of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, the value is passed into the callable, and the result of invoking the callable is returned from this function. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, the callable is not invoked, and a copy of the error is returned.</p>
<p>This function only participates in overload resultion if the result of invoking the callable is a <a class="el" href="classsumty_1_1result.html">result</a>.</p>
<h2><a class="anchor" id="autotoc_md373"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{-42};</div>
<div class="line"><span class="keyword">const</span> result&lt;int, std::string&gt; res3{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> callable = [](<span class="keywordtype">int</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) -&gt; result&lt;unsigned int, const char*&gt; {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a> &lt; 0) {</div>
<div class="line">        <span class="keywordflow">return</span> error&lt;const char*&gt;(<span class="stringliteral">&quot;negaive value&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_new = res1.and_then(callable);</div>
<div class="line"><span class="keyword">auto</span> res2_new = res2.and_then(callable);</div>
<div class="line"><span class="keyword">auto</span> res3_new = res3.and_then(callable);</div>
<div class="line"> </div>
<div class="line">assert(res1_new.is_ok());</div>
<div class="line">assert(*res1_new == 42);</div>
<div class="line"> </div>
<div class="line">assert(res2_new.is_error());</div>
<div class="line">assert(res2_new.error() == <span class="stringliteral">&quot;negative value&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res3_new.is_error());</div>
<div class="line">assert(res3_new.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad8d6cb036f0179ae2333a4f469de86b6" name="ad8d6cb036f0179ae2333a4f469de86b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d6cb036f0179ae2333a4f469de86b6">&#9670;&#160;</a></span>and_then() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> and_then </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a callable to the contents of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, the value is passed into the callable, and the result of invoking the callable is returned from this function. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, the callable is not invoked, the error is returned.</p>
<p>This function only participates in overload resultion if the result of invoking the callable is a <a class="el" href="classsumty_1_1result.html">result</a>.</p>
<h2><a class="anchor" id="autotoc_md375"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{-42};</div>
<div class="line"><span class="keyword">const</span> result&lt;int, std::string&gt; res3{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> callable = [](<span class="keywordtype">int</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) -&gt; result&lt;unsigned int, const char*&gt; {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a> &lt; 0) {</div>
<div class="line">        <span class="keywordflow">return</span> error&lt;const char*&gt;(<span class="stringliteral">&quot;negaive value&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_new = std::move(res1).and_then(callable);</div>
<div class="line"><span class="keyword">auto</span> res2_new = std::move(res2).and_then(callable);</div>
<div class="line"><span class="keyword">auto</span> res3_new = std::move(res3).and_then(callable);</div>
<div class="line"> </div>
<div class="line">assert(res1_new.is_ok());</div>
<div class="line">assert(*res1_new == 42);</div>
<div class="line"> </div>
<div class="line">assert(res2_new.is_error());</div>
<div class="line">assert(res2_new.error() == <span class="stringliteral">&quot;negative value&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res3_new.is_error());</div>
<div class="line">assert(res3_new.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a934c049ad95a5575df040397a1f20387" name="a934c049ad95a5575df040397a1f20387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934c049ad95a5575df040397a1f20387">&#9670;&#160;</a></span>cref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; <a class="el" href="classsumty_1_1result.html">const_reference</a>, <a class="el" href="classsumty_1_1result.html">error_const_reference</a> &gt; cref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="classsumty_1_1result.html">result</a> reference into a <a class="el" href="classsumty_1_1result.html">result</a> of references. </p>
<h2><a class="anchor" id="autotoc_md404"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">result&lt;const int&amp;, const std::string&amp;&gt; res1_ref = res1.<a class="code hl_function" href="classsumty_1_1result.html#a934c049ad95a5575df040397a1f20387">cref</a>();</div>
<div class="line">result&lt;const int&amp;, const std::string&amp;&gt; ref2_ref = res2.<a class="code hl_function" href="classsumty_1_1result.html#a934c049ad95a5575df040397a1f20387">cref</a>();</div>
<div class="line"> </div>
<div class="line">assert(res1_ref.is_ok());</div>
<div class="line">assert(&amp;*res1_ref == &amp;*res1);</div>
<div class="line"> </div>
<div class="line">assert(res2_ref.is_error());</div>
<div class="line">assert(&amp;res2_ref.error() == &amp;res2.error());</div>
<div class="ttc" id="aclasssumty_1_1result_html_a934c049ad95a5575df040397a1f20387"><div class="ttname"><a href="classsumty_1_1result.html#a934c049ad95a5575df040397a1f20387">sumty::result::cref</a></div><div class="ttdeci">constexpr result&lt; const_reference, error_const_reference &gt; cref() const noexcept</div><div class="ttdoc">Converts a result reference into a result of references.</div><div class="ttdef"><b>Definition</b> result.hpp:4390</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a54263fe060a2027fef396d47ec9fc7ce" name="a54263fe060a2027fef396d47ec9fc7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54263fe060a2027fef396d47ec9fc7ce">&#9670;&#160;</a></span>emplace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">reference</a> emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new ok value in place into the <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>The value previously contained in the <a class="el" href="classsumty_1_1result.html">result</a>, ok or error, is destroyed in place. The new ok value is then constructed in place as if by placement new.</p>
<h2><a class="anchor" id="autotoc_md409"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;std::string, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{in_place_error, 42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;std::string, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{<span class="stringliteral">&quot;&quot;</span>};</div>
<div class="line"> </div>
<div class="line">res1.<a class="code hl_function" href="classsumty_1_1result.html#a54263fe060a2027fef396d47ec9fc7ce">emplace</a>(5, <span class="charliteral">&#39;a&#39;</span>);</div>
<div class="line">res2.<a class="code hl_function" href="classsumty_1_1result.html#a54263fe060a2027fef396d47ec9fc7ce">emplace</a>(5, <span class="charliteral">&#39;a&#39;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res1.is_ok());</div>
<div class="line">assert(*res1 == <span class="stringliteral">&quot;aaaaa&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res2.is_ok());</div>
<div class="line">assert(*res2 == <span class="stringliteral">&quot;aaaaa&quot;</span>);</div>
<div class="ttc" id="aclasssumty_1_1result_html_a54263fe060a2027fef396d47ec9fc7ce"><div class="ttname"><a href="classsumty_1_1result.html#a54263fe060a2027fef396d47ec9fc7ce">sumty::result::emplace</a></div><div class="ttdeci">constexpr reference emplace(Args &amp;&amp;... args)</div><div class="ttdoc">Constructs a new ok value in place into the result.</div><div class="ttdef"><b>Definition</b> result.hpp:4545</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0064b897009c327b8d50dbc3c28de76f" name="a0064b897009c327b8d50dbc3c28de76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0064b897009c327b8d50dbc3c28de76f">&#9670;&#160;</a></span>emplace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">reference</a> emplace </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new ok value in place into the <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>The value previously contained in the <a class="el" href="classsumty_1_1result.html">result</a>, ok or error, is destroyed in place. The new ok value is then constructed in place as if by placement new.</p>
<h2><a class="anchor" id="autotoc_md410"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;std::vector&lt;int&gt;</a>, <span class="keywordtype">int</span>&gt; <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{in_place_error, 42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;std::vector&lt;int&gt;</a>, <span class="keywordtype">int</span>&gt; <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{};</div>
<div class="line"> </div>
<div class="line">res1.<a class="code hl_function" href="classsumty_1_1result.html#a54263fe060a2027fef396d47ec9fc7ce">emplace</a>({1, 2, 3, 4, 5});</div>
<div class="line">res2.<a class="code hl_function" href="classsumty_1_1result.html#a54263fe060a2027fef396d47ec9fc7ce">emplace</a>({1, 2, 3, 4, 5});</div>
<div class="line"> </div>
<div class="line">assert(res1.is_ok());</div>
<div class="line">assert(res1-&gt;size() == 5);</div>
<div class="line"> </div>
<div class="line">assert(res2.is_ok());</div>
<div class="line">assert(res2-&gt;size() == 5);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="afa1d354814cd785a8d732c3f4645c820" name="afa1d354814cd785a8d732c3f4645c820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1d354814cd785a8d732c3f4645c820">&#9670;&#160;</a></span>emplace_error() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">error_reference</a> emplace_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new error value in place into the <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>The value previously contained in the <a class="el" href="classsumty_1_1result.html">result</a>, ok or error, is destroyed in place. The new error value is then constructed in place as if by placement new.</p>
<h2><a class="anchor" id="autotoc_md411"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;&quot;</span>};</div>
<div class="line"> </div>
<div class="line">res1.<a class="code hl_function" href="classsumty_1_1result.html#afa1d354814cd785a8d732c3f4645c820">emplace_error</a>(5, <span class="charliteral">&#39;a&#39;</span>);</div>
<div class="line">res2.<a class="code hl_function" href="classsumty_1_1result.html#afa1d354814cd785a8d732c3f4645c820">emplace_error</a>(5, <span class="charliteral">&#39;a&#39;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res1.is_error());</div>
<div class="line">assert(res1.error() == <span class="stringliteral">&quot;aaaaa&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res2.is_error());</div>
<div class="line">assert(res2.error() == <span class="stringliteral">&quot;aaaaa&quot;</span>);</div>
<div class="ttc" id="aclasssumty_1_1result_html_afa1d354814cd785a8d732c3f4645c820"><div class="ttname"><a href="classsumty_1_1result.html#afa1d354814cd785a8d732c3f4645c820">sumty::result::emplace_error</a></div><div class="ttdeci">constexpr error_reference emplace_error(Args &amp;&amp;... args)</div><div class="ttdoc">Constructs a new error value in place into the result.</div><div class="ttdef"><b>Definition</b> result.hpp:4597</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2ebda0806feccffeb19f85eb484e55ef" name="a2ebda0806feccffeb19f85eb484e55ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebda0806feccffeb19f85eb484e55ef">&#9670;&#160;</a></span>emplace_error() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">error_reference</a> emplace_error </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new error value in place into the <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>The value previously contained in the <a class="el" href="classsumty_1_1result.html">result</a>, ok or error, is destroyed in place. The new error value is then constructed in place as if by placement new.</p>
<h2><a class="anchor" id="autotoc_md412"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::vector&lt;int&gt;</a>&gt; <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::vector&lt;int&gt;</a>&gt; <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error};</div>
<div class="line"> </div>
<div class="line">res1.<a class="code hl_function" href="classsumty_1_1result.html#afa1d354814cd785a8d732c3f4645c820">emplace_error</a>({1, 2, 3, 4, 5});</div>
<div class="line">res2.<a class="code hl_function" href="classsumty_1_1result.html#afa1d354814cd785a8d732c3f4645c820">emplace_error</a>({1, 2, 3, 4, 5});</div>
<div class="line"> </div>
<div class="line">assert(res1.is_error());</div>
<div class="line">assert(res1.error().size() == 5);</div>
<div class="line"> </div>
<div class="line">assert(res2.is_error());</div>
<div class="line">assert(res2.error().size() == 5);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0372cd10958a1e311670ff33afaaa038" name="a0372cd10958a1e311670ff33afaaa038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0372cd10958a1e311670ff33afaaa038">&#9670;&#160;</a></span>error() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">error_rvalue_reference</a> error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the error value contained in the <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>This function does not check if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value. Use of this function when the <a class="el" href="classsumty_1_1result.html">result</a> contains and error results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md364"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(std::move(<a class="code hl_class" href="classsumty_1_1result.html">res</a>).<a class="code hl_function" href="classsumty_1_1result.html#a1fc95966d58ae6508accb53ae1617b16">error</a>() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1fc95966d58ae6508accb53ae1617b16" name="a1fc95966d58ae6508accb53ae1617b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc95966d58ae6508accb53ae1617b16">&#9670;&#160;</a></span>error() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">error_reference</a> error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the error value contained in the <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>This function does not check if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value. Use of this function when the <a class="el" href="classsumty_1_1result.html">result</a> contains and error results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md362"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">res</a>.<a class="code hl_function" href="classsumty_1_1result.html#a1fc95966d58ae6508accb53ae1617b16">error</a>() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a266793f7977f1b167ae64050a950dc74" name="a266793f7977f1b167ae64050a950dc74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266793f7977f1b167ae64050a950dc74">&#9670;&#160;</a></span>error() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">error_const_rvalue_reference</a> error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the error value contained in the <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>This function does not check if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value. Use of this function when the <a class="el" href="classsumty_1_1result.html">result</a> contains and error results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md365"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(std::move(<a class="code hl_class" href="classsumty_1_1result.html">res</a>).<a class="code hl_function" href="classsumty_1_1result.html#a1fc95966d58ae6508accb53ae1617b16">error</a>() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a02be31ae26d729bc73fd58d280bf443e" name="a02be31ae26d729bc73fd58d280bf443e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02be31ae26d729bc73fd58d280bf443e">&#9670;&#160;</a></span>error() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">error_const_reference</a> error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the error value contained in the <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>This function does not check if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value. Use of this function when the <a class="el" href="classsumty_1_1result.html">result</a> contains and error results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md363"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">res</a>.<a class="code hl_function" href="classsumty_1_1result.html#a1fc95966d58ae6508accb53ae1617b16">error</a>() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aed49e6115fef063039acce34e03813e3" name="aed49e6115fef063039acce34e03813e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed49e6115fef063039acce34e03813e3">&#9670;&#160;</a></span>error_or_none() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1option.html">option</a>&lt; <a class="el" href="classsumty_1_1result.html">E</a> &gt; error_or_none </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discards ok value and converts into an <a class="el" href="classsumty_1_1option.html">option</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, that value is returned wrapped in an <a class="el" href="classsumty_1_1option.html">option</a>. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, <code>none</code> is returned.</p>
<h2><a class="anchor" id="autotoc_md408"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">option&lt;std::string&gt; opt1 = res1.<a class="code hl_function" href="classsumty_1_1result.html#afa8f599f5c9abe7544dcbbe346166bd2">error_or_none</a>();</div>
<div class="line">option&lt;std::string&gt; opt2 = res2.<a class="code hl_function" href="classsumty_1_1result.html#afa8f599f5c9abe7544dcbbe346166bd2">error_or_none</a>();</div>
<div class="line"> </div>
<div class="line">assert(opt1.is_none());</div>
<div class="line"> </div>
<div class="line">assert(opt2.is_some());</div>
<div class="line">assert(*opt2 == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="ttc" id="aclasssumty_1_1result_html_afa8f599f5c9abe7544dcbbe346166bd2"><div class="ttname"><a href="classsumty_1_1result.html#afa8f599f5c9abe7544dcbbe346166bd2">sumty::result::error_or_none</a></div><div class="ttdeci">constexpr option&lt; E &gt; error_or_none() const &amp;noexcept</div><div class="ttdoc">Discards ok value and converts into an option.</div><div class="ttdef"><b>Definition</b> result.hpp:4479</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="afa8f599f5c9abe7544dcbbe346166bd2" name="afa8f599f5c9abe7544dcbbe346166bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8f599f5c9abe7544dcbbe346166bd2">&#9670;&#160;</a></span>error_or_none() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1option.html">option</a>&lt; <a class="el" href="classsumty_1_1result.html">E</a> &gt; error_or_none </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discards ok value and converts into an <a class="el" href="classsumty_1_1option.html">option</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, a copy of that value is returned wrapped in an <a class="el" href="classsumty_1_1option.html">option</a>. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, <code>none</code> is returned.</p>
<h2><a class="anchor" id="autotoc_md407"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">option&lt;std::string&gt; opt1 = res1.<a class="code hl_function" href="classsumty_1_1result.html#afa8f599f5c9abe7544dcbbe346166bd2">error_or_none</a>();</div>
<div class="line">option&lt;std::string&gt; opt2 = res2.<a class="code hl_function" href="classsumty_1_1result.html#afa8f599f5c9abe7544dcbbe346166bd2">error_or_none</a>();</div>
<div class="line"> </div>
<div class="line">assert(opt1.is_none());</div>
<div class="line"> </div>
<div class="line">assert(opt2.is_some());</div>
<div class="line">assert(*opt2 == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad1f223501a34e06676900e3f27051737" name="ad1f223501a34e06676900e3f27051737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f223501a34e06676900e3f27051737">&#9670;&#160;</a></span>flatten() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> flatten </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <code>result&lt;result&lt;T, E1&gt;, E2&gt;</code> into <code>result&lt;T, E3&gt;</code> </p>
<p>If the outer <a class="el" href="classsumty_1_1result.html">result</a> contains an error, that error is returned. If the outer <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, and the inner <a class="el" href="classsumty_1_1result.html">result</a> contains an error, that inner error is returned. If the outer <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value and the inner <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, that inner ok value is returned.</p>
<p>If the outer <a class="el" href="classsumty_1_1result.html">result</a> and the inner <a class="el" href="classsumty_1_1result.html">result</a> have different error types, the returned <a class="el" href="classsumty_1_1result.html">result</a> will be one of these two types based on the following priority rules:</p>
<ol type="1">
<li>If the outer error type is <code>void</code>, use the inner error type</li>
<li>Else, if the inner error type is <code>void</code>, use the outer error type</li>
<li>Else, if the outer error type is constructible from the inner error type, use the outer error type.</li>
<li>Else, if the inner error type is constructible from the outer error type, use the inner error type.</li>
</ol>
<p>Note that only one level of <a class="el" href="classsumty_1_1result.html">result</a> is removed. For example, a <code>result&lt;result&lt;result&lt;T, E&gt;, E&gt;, E&gt;</code> will flatten to a <code>result&lt;result&lt;T, E&gt;, E&gt;</code>.</p>
<h2><a class="anchor" id="autotoc_md387"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;result&lt;int, const char*&gt;</a>, std::string&gt; <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{in_place, 42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;result&lt;int, const char*&gt;</a>, std::string&gt; <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{</div>
<div class="line">        in_place, in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line">result&lt;result&lt;int, const char*&gt;, std::string&gt; res3{</div>
<div class="line">        in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">result&lt;int, std::string&gt; res1_flat = std::move(res1).<a class="code hl_function" href="classsumty_1_1result.html#a96ca8608fbca4acbef17e6678a2cb158">flatten</a>();</div>
<div class="line">result&lt;int, std::string&gt; res2_flat = std::move(res2).<a class="code hl_function" href="classsumty_1_1result.html#a96ca8608fbca4acbef17e6678a2cb158">flatten</a>();</div>
<div class="line">result&lt;int, std::string&gt; res3_flat = std::move(res3).<a class="code hl_function" href="classsumty_1_1result.html#a96ca8608fbca4acbef17e6678a2cb158">flatten</a>();</div>
<div class="line"> </div>
<div class="line">assert(res1_flat.is_ok());</div>
<div class="line">assert(*res1_flat == 42);</div>
<div class="line"> </div>
<div class="line">assert(res2_flat.is_error());</div>
<div class="line">assert(res2_flat.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res3_flat.is_error());</div>
<div class="line">assert(res3_flat.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="ttc" id="aclasssumty_1_1result_html_a96ca8608fbca4acbef17e6678a2cb158"><div class="ttname"><a href="classsumty_1_1result.html#a96ca8608fbca4acbef17e6678a2cb158">sumty::result::flatten</a></div><div class="ttdeci">constexpr auto flatten() const &amp;</div><div class="ttdoc">Converts result&lt;result&lt;T, E1&gt;, E2&gt; into result&lt;T, E3&gt;</div><div class="ttdef"><b>Definition</b> result.hpp:3495</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a96ca8608fbca4acbef17e6678a2cb158" name="a96ca8608fbca4acbef17e6678a2cb158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ca8608fbca4acbef17e6678a2cb158">&#9670;&#160;</a></span>flatten() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> flatten </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <code>result&lt;result&lt;T, E1&gt;, E2&gt;</code> into <code>result&lt;T, E3&gt;</code> </p>
<p>If the outer <a class="el" href="classsumty_1_1result.html">result</a> contains an error, a copy of that error is returned. If the outer <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, and the inner <a class="el" href="classsumty_1_1result.html">result</a> contains an error, a copy of that inner error is returned. If the outer <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value and the inner <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, a copy of that inner ok value is returned.</p>
<p>If the outer <a class="el" href="classsumty_1_1result.html">result</a> and the inner <a class="el" href="classsumty_1_1result.html">result</a> have different error types, the returned <a class="el" href="classsumty_1_1result.html">result</a> will be one of these two types based on the following priority rules:</p>
<ol type="1">
<li>If the outer error type is <code>void</code>, use the inner error type</li>
<li>Else, if the inner error type is <code>void</code>, use the outer error type</li>
<li>Else, if the outer error type is constructible from the inner error type, use the outer error type.</li>
<li>Else, if the inner error type is constructible from the outer error type, use the inner error type.</li>
</ol>
<p>Note that only one level of <a class="el" href="classsumty_1_1result.html">result</a> is removed. For example, a <code>result&lt;result&lt;result&lt;T, E&gt;, E&gt;, E&gt;</code> will flatten to a <code>result&lt;result&lt;T, E&gt;, E&gt;</code>.</p>
<h2><a class="anchor" id="autotoc_md386"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;result&lt;int, const char*&gt;</a>, std::string&gt; <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{in_place, 42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;result&lt;int, const char*&gt;</a>, std::string&gt; <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{</div>
<div class="line">        in_place, in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line">result&lt;result&lt;int, const char*&gt;, std::string&gt; res3{</div>
<div class="line">        in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">result&lt;int, std::string&gt; res1_flat = res1.<a class="code hl_function" href="classsumty_1_1result.html#a96ca8608fbca4acbef17e6678a2cb158">flatten</a>();</div>
<div class="line">result&lt;int, std::string&gt; res2_flat = res2.<a class="code hl_function" href="classsumty_1_1result.html#a96ca8608fbca4acbef17e6678a2cb158">flatten</a>();</div>
<div class="line">result&lt;int, std::string&gt; res3_flat = res3.<a class="code hl_function" href="classsumty_1_1result.html#a96ca8608fbca4acbef17e6678a2cb158">flatten</a>();</div>
<div class="line"> </div>
<div class="line">assert(res1_flat.is_ok());</div>
<div class="line">assert(*res1_flat == 42);</div>
<div class="line"> </div>
<div class="line">assert(res2_flat.is_error());</div>
<div class="line">assert(res2_flat.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res3_flat.is_error());</div>
<div class="line">assert(res3_flat.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad3648c08cef0fa9ee01ee69b3f3acf50" name="ad3648c08cef0fa9ee01ee69b3f3acf50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3648c08cef0fa9ee01ee69b3f3acf50">&#9670;&#160;</a></span>flatten_all() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> flatten_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts nested <a class="el" href="classsumty_1_1result.html">result</a> types into a single <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>Like <a class="el" href="classsumty_1_1result.html#a96ca8608fbca4acbef17e6678a2cb158">flatten</a>, this function removes nested layers of <a class="el" href="classsumty_1_1result.html">result</a>, such as converting <code>result&lt;result&lt;T, E&gt;, E&gt;</code> into <code>result&lt;T, E&gt;</code>. However, unlike <a class="el" href="classsumty_1_1result.html#a96ca8608fbca4acbef17e6678a2cb158">flatten</a>, this function removes all layers of nesting and works for unnested <a class="el" href="classsumty_1_1result.html">result</a> types. For example, <code>result&lt;result&lt;result&lt;T, E&gt;, E, E&gt;</code> is converted directly to <code>result&lt;T, E&gt;</code>, and for <code>result&lt;T, E&gt;</code>, where <code>T</code> is not a <a class="el" href="classsumty_1_1result.html">result</a> type, no layers of <a class="el" href="classsumty_1_1result.html">result</a> are removed.</p>
<h2><a class="anchor" id="autotoc_md389"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_class" href="classsumty_1_1result.html">nested_result_t</a> =</div>
<div class="line">    <a class="code hl_class" href="classsumty_1_1result.html">result&lt;result&lt;result&lt;int, std::string&gt;</a>, std::string, std::string&gt;;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">nested_result_t</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{in_place, in_place, in_place, 42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">nested_result_t</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line">nested_result_t res3{in_place, in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line">nested_result_t res4{in_place, in_place, in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">result&lt;int, std::string&gt; res1_flat = std::move(res1).<a class="code hl_function" href="classsumty_1_1result.html#afb73126143d9ed2b1c342e0e8520118f">flatten_all</a>();</div>
<div class="line">result&lt;int, std::string&gt; res2_flat = std::move(res2).<a class="code hl_function" href="classsumty_1_1result.html#afb73126143d9ed2b1c342e0e8520118f">flatten_all</a>();</div>
<div class="line">result&lt;int, std::string&gt; res3_flat = std::move(res3).<a class="code hl_function" href="classsumty_1_1result.html#afb73126143d9ed2b1c342e0e8520118f">flatten_all</a>();</div>
<div class="line">result&lt;int, std::string&gt; res4_flat = std::move(res4).<a class="code hl_function" href="classsumty_1_1result.html#afb73126143d9ed2b1c342e0e8520118f">flatten_all</a>();</div>
<div class="line"> </div>
<div class="line">assert(res1_flat.is_ok());</div>
<div class="line">assert(*res1_flat == 42);</div>
<div class="line"> </div>
<div class="line">assert(res2_flat.is_error());</div>
<div class="line">assert(res2_flat.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res3_flat.is_error());</div>
<div class="line">assert(res3_flat.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res3_flat.is_error());</div>
<div class="line">assert(res3_flat.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="ttc" id="aclasssumty_1_1result_html_afb73126143d9ed2b1c342e0e8520118f"><div class="ttname"><a href="classsumty_1_1result.html#afb73126143d9ed2b1c342e0e8520118f">sumty::result::flatten_all</a></div><div class="ttdeci">constexpr auto flatten_all() const &amp;</div><div class="ttdoc">Converts nested result types into a single result.</div><div class="ttdef"><b>Definition</b> result.hpp:3662</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="afb73126143d9ed2b1c342e0e8520118f" name="afb73126143d9ed2b1c342e0e8520118f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb73126143d9ed2b1c342e0e8520118f">&#9670;&#160;</a></span>flatten_all() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> flatten_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts nested <a class="el" href="classsumty_1_1result.html">result</a> types into a single <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>Like <a class="el" href="classsumty_1_1result.html#a96ca8608fbca4acbef17e6678a2cb158">flatten</a>, this function removes nested layers of <a class="el" href="classsumty_1_1result.html">result</a>, such as converting <code>result&lt;result&lt;T, E&gt;, E&gt;</code> into <code>result&lt;T, E&gt;</code>. However, unlike <a class="el" href="classsumty_1_1result.html#a96ca8608fbca4acbef17e6678a2cb158">flatten</a>, this function removes all layers of nesting and works for unnested <a class="el" href="classsumty_1_1result.html">result</a> types. For example, <code>result&lt;result&lt;result&lt;T, E&gt;, E, E&gt;</code> is converted directly to <code>result&lt;T, E&gt;</code>, and for <code>result&lt;T, E&gt;</code>, where <code>T</code> is not a <a class="el" href="classsumty_1_1result.html">result</a> type, no layers of <a class="el" href="classsumty_1_1result.html">result</a> are removed.</p>
<h2><a class="anchor" id="autotoc_md388"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_class" href="classsumty_1_1result.html">nested_result_t</a> =</div>
<div class="line">    <a class="code hl_class" href="classsumty_1_1result.html">result&lt;result&lt;result&lt;int, std::string&gt;</a>, std::string, std::string&gt;;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">nested_result_t</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{in_place, in_place, in_place, 42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">nested_result_t</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line">nested_result_t res3{in_place, in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line">nested_result_t res4{in_place, in_place, in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">result&lt;int, std::string&gt; res1_flat = res1.<a class="code hl_function" href="classsumty_1_1result.html#afb73126143d9ed2b1c342e0e8520118f">flatten_all</a>();</div>
<div class="line">result&lt;int, std::string&gt; res2_flat = res2.<a class="code hl_function" href="classsumty_1_1result.html#afb73126143d9ed2b1c342e0e8520118f">flatten_all</a>();</div>
<div class="line">result&lt;int, std::string&gt; res3_flat = res3.<a class="code hl_function" href="classsumty_1_1result.html#afb73126143d9ed2b1c342e0e8520118f">flatten_all</a>();</div>
<div class="line">result&lt;int, std::string&gt; res4_flat = res4.<a class="code hl_function" href="classsumty_1_1result.html#afb73126143d9ed2b1c342e0e8520118f">flatten_all</a>();</div>
<div class="line"> </div>
<div class="line">assert(res1_flat.is_ok());</div>
<div class="line">assert(*res1_flat == 42);</div>
<div class="line"> </div>
<div class="line">assert(res2_flat.is_error());</div>
<div class="line">assert(res2_flat.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res3_flat.is_error());</div>
<div class="line">assert(res3_flat.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res3_flat.is_error());</div>
<div class="line">assert(res3_flat.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6988ba57722f67cbb444b0931468282e" name="a6988ba57722f67cbb444b0931468282e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6988ba57722f67cbb444b0931468282e">&#9670;&#160;</a></span>has_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a> has_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value. </p>
<h2><a class="anchor" id="autotoc_md349"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{<a class="code hl_class" href="classsumty_1_1result.html">error&lt;std::string&gt;</a>(<span class="stringliteral">&quot;oh no&quot;</span>)};</div>
<div class="line"> </div>
<div class="line">assert(res1.has_value());</div>
<div class="line">assert(!res1.has_value());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3ad5979c728856e9d92461551c3e1797" name="a3ad5979c728856e9d92461551c3e1797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad5979c728856e9d92461551c3e1797">&#9670;&#160;</a></span>invert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; <a class="el" href="classsumty_1_1result.html">E</a>, T &gt; invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the ok and error types of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, a copy of the ok value will be returned as an error. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, the error value will be returned as an ok value.</p>
<h2><a class="anchor" id="autotoc_md393"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">result&lt;std::string, int&gt; res1_inv = std::move(res1).<a class="code hl_function" href="classsumty_1_1result.html#a805656c75187a25047a75a2f209aee88">invert</a>();</div>
<div class="line">result&lt;std::string, int&gt; res2_inv = std::move(res2).<a class="code hl_function" href="classsumty_1_1result.html#a805656c75187a25047a75a2f209aee88">invert</a>();</div>
<div class="line"> </div>
<div class="line">assert(res1_inv.is_error());</div>
<div class="line">assert(res1_inv.error() == 42);</div>
<div class="line"> </div>
<div class="line">assert(res2_inv.is_ok());</div>
<div class="line">assert(*res2_inv == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="ttc" id="aclasssumty_1_1result_html_a805656c75187a25047a75a2f209aee88"><div class="ttname"><a href="classsumty_1_1result.html#a805656c75187a25047a75a2f209aee88">sumty::result::invert</a></div><div class="ttdeci">constexpr result&lt; E, T &gt; invert() const &amp;</div><div class="ttdoc">Swaps the ok and error types of a result.</div><div class="ttdef"><b>Definition</b> result.hpp:3837</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a805656c75187a25047a75a2f209aee88" name="a805656c75187a25047a75a2f209aee88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805656c75187a25047a75a2f209aee88">&#9670;&#160;</a></span>invert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; <a class="el" href="classsumty_1_1result.html">E</a>, T &gt; invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the ok and error types of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, a copy of the ok value will be returned as an error. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, the error value will be returned as an ok value.</p>
<h2><a class="anchor" id="autotoc_md392"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">result&lt;std::string, int&gt; res1_inv = res1.<a class="code hl_function" href="classsumty_1_1result.html#a805656c75187a25047a75a2f209aee88">invert</a>();</div>
<div class="line">result&lt;std::string, int&gt; res2_inv = res2.<a class="code hl_function" href="classsumty_1_1result.html#a805656c75187a25047a75a2f209aee88">invert</a>();</div>
<div class="line"> </div>
<div class="line">assert(res1_inv.is_error());</div>
<div class="line">assert(res1_inv.error() == 42);</div>
<div class="line"> </div>
<div class="line">assert(res2_inv.is_ok());</div>
<div class="line">assert(*res2_inv == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a78ae07e6fffe4be53e3de41c01786d99" name="a78ae07e6fffe4be53e3de41c01786d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ae07e6fffe4be53e3de41c01786d99">&#9670;&#160;</a></span>is_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a> is_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value. </p>
<h2><a class="anchor" id="autotoc_md351"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{<a class="code hl_class" href="classsumty_1_1result.html">error&lt;std::string&gt;</a>(<span class="stringliteral">&quot;oh no&quot;</span>)};</div>
<div class="line"> </div>
<div class="line">assert(!res1.is_error());</div>
<div class="line">assert(res1.is_error());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aecdb1f9707ee1f7b6b49ff2b0dea34a9" name="aecdb1f9707ee1f7b6b49ff2b0dea34a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdb1f9707ee1f7b6b49ff2b0dea34a9">&#9670;&#160;</a></span>is_ok()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a> is_ok </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value. </p>
<h2><a class="anchor" id="autotoc_md350"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{<a class="code hl_class" href="classsumty_1_1result.html">error&lt;std::string&gt;</a>(<span class="stringliteral">&quot;oh no&quot;</span>)};</div>
<div class="line"> </div>
<div class="line">assert(res1.is_ok());</div>
<div class="line">assert(!res1.is_ok());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a78adcf88fdf6b1ddd812fded133e5d27" name="a78adcf88fdf6b1ddd812fded133e5d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78adcf88fdf6b1ddd812fded133e5d27">&#9670;&#160;</a></span>map() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perforams a transformation on the ok value of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, that value is passed to the transformation callable provided. The value returned from the callable is then returned from this function as the ok value of a new <a class="el" href="classsumty_1_1result.html">result</a>, where ok type of the new result is the exact type returned from the callable. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, a copy of the error is returned.</p>
<p>Note that this function is idential to <a class="el" href="classsumty_1_1result.html#a53b47c4e5b7d606127eca04576b1f657">transform</a>, but the name <code>map</code> is the more typical name of this monadic operation outside of C++.</p>
<h2><a class="anchor" id="autotoc_md380"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_mapped = res1.<a class="code hl_function" href="classsumty_1_1result.html#a78adcf88fdf6b1ddd812fded133e5d27">map</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> res2_mapped = res2.<a class="code hl_function" href="classsumty_1_1result.html#a78adcf88fdf6b1ddd812fded133e5d27">map</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">assert(res1_mapped.is_error());</div>
<div class="line">assert(res1_mapped.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res2_mapped.is_ok());</div>
<div class="line">assert(*res2_mapped == <span class="stringliteral">&quot;42&quot;</span>);</div>
<div class="ttc" id="aclasssumty_1_1result_html_a78adcf88fdf6b1ddd812fded133e5d27"><div class="ttname"><a href="classsumty_1_1result.html#a78adcf88fdf6b1ddd812fded133e5d27">sumty::result::map</a></div><div class="ttdeci">constexpr auto map(F &amp;&amp;f) &amp;</div><div class="ttdoc">Perforams a transformation on the ok value of a result.</div><div class="ttdef"><b>Definition</b> result.hpp:3255</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a171bf3001590e7b4efa26f968ee767a6" name="a171bf3001590e7b4efa26f968ee767a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171bf3001590e7b4efa26f968ee767a6">&#9670;&#160;</a></span>map() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perforams a transformation on the ok value of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, that value is passed to the transformation callable provided. The value returned from the callable is then returned from this function as the ok value of a new <a class="el" href="classsumty_1_1result.html">result</a>, where ok type of the new result is the exact type returned from the callable. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, the error is returned.</p>
<p>Note that this function is idential to <a class="el" href="classsumty_1_1result.html#a53b47c4e5b7d606127eca04576b1f657">transform</a>, but the name <code>map</code> is the more typical name of this monadic operation outside of C++.</p>
<h2><a class="anchor" id="autotoc_md382"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_mapped = std::move(res1).<a class="code hl_function" href="classsumty_1_1result.html#a78adcf88fdf6b1ddd812fded133e5d27">map</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> res2_mapped = std::move(res2).<a class="code hl_function" href="classsumty_1_1result.html#a78adcf88fdf6b1ddd812fded133e5d27">map</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">assert(res1_mapped.is_error());</div>
<div class="line">assert(res1_mapped.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res2_mapped.is_ok());</div>
<div class="line">assert(*res2_mapped == <span class="stringliteral">&quot;42&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8e8cb9bd568be1d4cc5cd07f6d6f9534" name="a8e8cb9bd568be1d4cc5cd07f6d6f9534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8cb9bd568be1d4cc5cd07f6d6f9534">&#9670;&#160;</a></span>map() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perforams a transformation on the ok value of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, that value is passed to the transformation callable provided. The value returned from the callable is then returned from this function as the ok value of a new <a class="el" href="classsumty_1_1result.html">result</a>, where ok type of the new result is the exact type returned from the callable. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, a copy of the error is returned.</p>
<p>Note that this function is idential to <a class="el" href="classsumty_1_1result.html#a53b47c4e5b7d606127eca04576b1f657">transform</a>, but the name <code>map</code> is the more typical name of this monadic operation outside of C++.</p>
<h2><a class="anchor" id="autotoc_md381"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_mapped = res1.<a class="code hl_function" href="classsumty_1_1result.html#a78adcf88fdf6b1ddd812fded133e5d27">map</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> res2_mapped = res2.<a class="code hl_function" href="classsumty_1_1result.html#a78adcf88fdf6b1ddd812fded133e5d27">map</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">assert(res1_mapped.is_error());</div>
<div class="line">assert(res1_mapped.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res2_mapped.is_ok());</div>
<div class="line">assert(*res2_mapped == <span class="stringliteral">&quot;42&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae66252faa0dd3f45045258d86f900b54" name="ae66252faa0dd3f45045258d86f900b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66252faa0dd3f45045258d86f900b54">&#9670;&#160;</a></span>map() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perforams a transformation on the ok value of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, that value is passed to the transformation callable provided. The value returned from the callable is then returned from this function as the ok value of a new <a class="el" href="classsumty_1_1result.html">result</a>, where ok type of the new result is the exact type returned from the callable. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, the error is returned.</p>
<p>Note that this function is idential to <a class="el" href="classsumty_1_1result.html#a53b47c4e5b7d606127eca04576b1f657">transform</a>, but the name <code>map</code> is the more typical name of this monadic operation outside of C++.</p>
<h2><a class="anchor" id="autotoc_md383"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_mapped = std::move(res1).<a class="code hl_function" href="classsumty_1_1result.html#a78adcf88fdf6b1ddd812fded133e5d27">map</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> res2_mapped = std::move(res2).<a class="code hl_function" href="classsumty_1_1result.html#a78adcf88fdf6b1ddd812fded133e5d27">map</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">assert(res1_mapped.is_error());</div>
<div class="line">assert(res1_mapped.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res2_mapped.is_ok());</div>
<div class="line">assert(*res2_mapped == <span class="stringliteral">&quot;42&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a19c341e98b54b0017bed0e1911edd3ec" name="a19c341e98b54b0017bed0e1911edd3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c341e98b54b0017bed0e1911edd3ec">&#9670;&#160;</a></span>map_error() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> map_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perforams a transformation on the error value of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, that value is passed to the transformation callable provided. The value returned from the callable is then returned from this function as the error value of a new <a class="el" href="classsumty_1_1result.html">result</a>, where the error type of the new result is the exact type returned from the callable. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, a copy of the ok value is returned.</p>
<p>Note that this function is identical to <a class="el" href="classsumty_1_1result.html#a610f631536779752a99a9346cd7f1055">transform_error</a>, but the name <code>map_error</code> is more typical for this sort of monadic operation outside of C++.</p>
<h2><a class="anchor" id="autotoc_md398"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;void, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;void, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, 42};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_mapped = res1.<a class="code hl_function" href="classsumty_1_1result.html#a19c341e98b54b0017bed0e1911edd3ec">map_error</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> res2_mapped = res2.<a class="code hl_function" href="classsumty_1_1result.html#a19c341e98b54b0017bed0e1911edd3ec">map_error</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">assert(res1_mapped.is_ok());</div>
<div class="line"> </div>
<div class="line">assert(res2_mapped.is_error());</div>
<div class="line">assert(*res2_mapped == <span class="stringliteral">&quot;42&quot;</span>);</div>
<div class="ttc" id="aclasssumty_1_1result_html_a19c341e98b54b0017bed0e1911edd3ec"><div class="ttname"><a href="classsumty_1_1result.html#a19c341e98b54b0017bed0e1911edd3ec">sumty::result::map_error</a></div><div class="ttdeci">constexpr auto map_error(F &amp;&amp;f) &amp;</div><div class="ttdoc">Perforams a transformation on the error value of a result.</div><div class="ttdef"><b>Definition</b> result.hpp:4192</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5c844e364e67484cc3baa71b0b5e4199" name="a5c844e364e67484cc3baa71b0b5e4199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c844e364e67484cc3baa71b0b5e4199">&#9670;&#160;</a></span>map_error() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> map_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perforams a transformation on the error value of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, that value is passed to the transformation callable provided. The value returned from the callable is then returned from this function as the error value of a new <a class="el" href="classsumty_1_1result.html">result</a>, where the error type of the new result is the exact type returned from the callable. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, the ok value is returned.</p>
<p>Note that this function is identical to <a class="el" href="classsumty_1_1result.html#a610f631536779752a99a9346cd7f1055">transform_error</a>, but the name <code>map_error</code> is more typical for this sort of monadic operation outside of C++.</p>
<h2><a class="anchor" id="autotoc_md400"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;void, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;void, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, 42};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_mapped = std::move(res1).<a class="code hl_function" href="classsumty_1_1result.html#a19c341e98b54b0017bed0e1911edd3ec">map_error</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> res2_mapped = std::move(res2).<a class="code hl_function" href="classsumty_1_1result.html#a19c341e98b54b0017bed0e1911edd3ec">map_error</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">assert(res1_mapped.is_ok());</div>
<div class="line"> </div>
<div class="line">assert(res2_mapped.is_error());</div>
<div class="line">assert(*res2_mapped == <span class="stringliteral">&quot;42&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="afe72d0f48f89e77a23bd0e4f8503b595" name="afe72d0f48f89e77a23bd0e4f8503b595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe72d0f48f89e77a23bd0e4f8503b595">&#9670;&#160;</a></span>map_error() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> map_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perforams a transformation on the error value of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, that value is passed to the transformation callable provided. The value returned from the callable is then returned from this function as the error value of a new <a class="el" href="classsumty_1_1result.html">result</a>, where the error type of the new result is the exact type returned from the callable. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, a copy of the ok value is returned.</p>
<p>Note that this function is identical to <a class="el" href="classsumty_1_1result.html#a610f631536779752a99a9346cd7f1055">transform_error</a>, but the name <code>map_error</code> is more typical for this sort of monadic operation outside of C++.</p>
<h2><a class="anchor" id="autotoc_md399"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;void, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;void, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, 42};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_mapped = res1.<a class="code hl_function" href="classsumty_1_1result.html#a19c341e98b54b0017bed0e1911edd3ec">map_error</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> res2_mapped = res2.<a class="code hl_function" href="classsumty_1_1result.html#a19c341e98b54b0017bed0e1911edd3ec">map_error</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">assert(res1_mapped.is_ok());</div>
<div class="line"> </div>
<div class="line">assert(res2_mapped.is_error());</div>
<div class="line">assert(*res2_mapped == <span class="stringliteral">&quot;42&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1cf0158267be5cd7c52efbae8b88d690" name="a1cf0158267be5cd7c52efbae8b88d690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf0158267be5cd7c52efbae8b88d690">&#9670;&#160;</a></span>map_error() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> map_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perforams a transformation on the error value of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, that value is passed to the transformation callable provided. The value returned from the callable is then returned from this function as the error value of a new <a class="el" href="classsumty_1_1result.html">result</a>, where the error type of the new result is the exact type returned from the callable. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, the ok value is returned.</p>
<p>Note that this function is identical to <a class="el" href="classsumty_1_1result.html#a610f631536779752a99a9346cd7f1055">transform_error</a>, but the name <code>map_error</code> is more typical for this sort of monadic operation outside of C++.</p>
<h2><a class="anchor" id="autotoc_md401"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;void, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;void, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, 42};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_mapped = std::move(res1).<a class="code hl_function" href="classsumty_1_1result.html#a19c341e98b54b0017bed0e1911edd3ec">map_error</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> res2_mapped = std::move(res2).<a class="code hl_function" href="classsumty_1_1result.html#a19c341e98b54b0017bed0e1911edd3ec">map_error</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">assert(res1_mapped.is_ok());</div>
<div class="line"> </div>
<div class="line">assert(res2_mapped.is_error());</div>
<div class="line">assert(*res2_mapped == <span class="stringliteral">&quot;42&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7990d8e87d9eab2383f94c88c23a6488" name="a7990d8e87d9eab2383f94c88c23a6488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7990d8e87d9eab2383f94c88c23a6488">&#9670;&#160;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> operator <a class="el" href="classsumty_1_1result.html">bool</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit conversion to <code>bool</code>. </p>
<p>This implicit conversion allows a <a class="el" href="classsumty_1_1result.html">result</a> to be used directly in a condition to check if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value.</p>
<h2><a class="anchor" id="autotoc_md348"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a> = <a class="code hl_class" href="classsumty_1_1result.html">error&lt;std::string&gt;</a>(<span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_class" href="classsumty_1_1result.html">res1</a>) {</div>
<div class="line">    <a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">res1</a> == 42);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    assert(<span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (res2) {</div>
<div class="line">    assert(<span class="keyword">false</span>);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    assert(res2.<a class="code hl_function" href="classsumty_1_1result.html#a1fc95966d58ae6508accb53ae1617b16">error</a>() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5847b7dab416bcb9b4c4b8e7100e90f2" name="a5847b7dab416bcb9b4c4b8e7100e90f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5847b7dab416bcb9b4c4b8e7100e90f2">&#9670;&#160;</a></span>operator*() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">rvalue_reference</a> operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the ok value contained in the <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>This operator does not check if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value. Use of this operator when the <a class="el" href="classsumty_1_1result.html">result</a> contains an error results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md354"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*std::move(<a class="code hl_class" href="classsumty_1_1result.html">res</a>) == 42);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af223249c6ba720462d09b5cea77ae573" name="af223249c6ba720462d09b5cea77ae573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af223249c6ba720462d09b5cea77ae573">&#9670;&#160;</a></span>operator*() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">reference</a> operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the ok value contained in the <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>This operator does not check if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value. Use of this operator when the <a class="el" href="classsumty_1_1result.html">result</a> contains and error results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md352"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">res</a> == 42);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3d326290da75475116ce798c270e8c6c" name="a3d326290da75475116ce798c270e8c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d326290da75475116ce798c270e8c6c">&#9670;&#160;</a></span>operator*() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">const_rvalue_reference</a> operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the ok value contained in the <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>This operator does not check if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value. Use of this operator when the <a class="el" href="classsumty_1_1result.html">result</a> contains an error results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md355"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*std::move(<a class="code hl_class" href="classsumty_1_1result.html">res</a>) == 42);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a46bdafe3baa1fce9bad14c2aad77185f" name="a46bdafe3baa1fce9bad14c2aad77185f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46bdafe3baa1fce9bad14c2aad77185f">&#9670;&#160;</a></span>operator*() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">const_reference</a> operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the ok value contained in the <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>This operator does not check if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value. Use of this operator when the <a class="el" href="classsumty_1_1result.html">result</a> contains an error results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md353"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">res</a> == 42);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="acbeac3f70f41e69d29f2ac3c79e65ba5" name="acbeac3f70f41e69d29f2ac3c79e65ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbeac3f70f41e69d29f2ac3c79e65ba5">&#9670;&#160;</a></span>operator-&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">const_pointer</a> operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses members of the ok value contained in the <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>This operator does not check if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value. Use of this operator when the <a class="el" href="classsumty_1_1result.html">result</a> contains an error results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md357"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;std::string, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{<span class="stringliteral">&quot;hello&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">res</a>-&gt;size() == 5);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0a1cac3ec0a2272da9aa57c5358563d1" name="a0a1cac3ec0a2272da9aa57c5358563d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1cac3ec0a2272da9aa57c5358563d1">&#9670;&#160;</a></span>operator-&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">pointer</a> operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses members of the ok value contained in the <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>This operator does not check if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value. Use of this operator when the <a class="el" href="classsumty_1_1result.html">result</a> contains an error results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md356"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;std::string, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{<span class="stringliteral">&quot;hello&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">res</a>-&gt;size() == 5);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac651f94f43334108c005abc0865c6f93" name="ac651f94f43334108c005abc0865c6f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac651f94f43334108c005abc0865c6f93">&#9670;&#160;</a></span>operator=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1error__t.html">error_t</a>&lt; <a class="el" href="classsumty_1_1result.html">V</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment from <a class="el" href="classsumty_1_1error__t.html">error_t</a>. </p>
<p>Sets the <a class="el" href="classsumty_1_1result.html">result</a> to contain a copy of the error value contained in the <a class="el" href="classsumty_1_1error__t.html">error_t</a>, converted to <code>E</code>. If the <a class="el" href="classsumty_1_1result.html">result</a> already contains an error value, the new value is copy assigned directly to the contained value. Otherwise, the ok type is destroyed and the new error value is copy constructed from the contained value of the <a class="el" href="classsumty_1_1error__t.html">error_t</a>.</p>
<p>This function only participates in overload resolution if <code>E</code> is constructible and assignable from value contained in the <a class="el" href="classsumty_1_1error__t.html">error_t</a>.</p>
<h2><a class="anchor" id="autotoc_md346"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{};</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> <a class="code hl_class" href="classsumty_1_1result.html">err_val</a> = <a class="code hl_class" href="classsumty_1_1result.html">ok&lt;const char*&gt;</a>(<span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">res</a> = <a class="code hl_class" href="classsumty_1_1result.html">err_val</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(!<a class="code hl_class" href="classsumty_1_1result.html">res</a>.<a class="code hl_function" href="classsumty_1_1result.html#a6988ba57722f67cbb444b0931468282e">has_value</a>());</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">res</a>.<a class="code hl_function" href="classsumty_1_1result.html#a1fc95966d58ae6508accb53ae1617b16">error</a>() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad041a28277cb1af5d16b1f40174738b5" name="ad041a28277cb1af5d16b1f40174738b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad041a28277cb1af5d16b1f40174738b5">&#9670;&#160;</a></span>operator=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1ok__t.html">ok_t</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment from <a class="el" href="classsumty_1_1ok__t.html">ok_t</a>. </p>
<p>Sets the <a class="el" href="classsumty_1_1result.html">result</a> to contain a copy of the ok value contained in the <a class="el" href="classsumty_1_1ok__t.html">ok_t</a>, converted to <code>T</code>. If the <a class="el" href="classsumty_1_1result.html">result</a> already contains an ok value, the new value is copy assigned directly to the contained value. Otherwise, the error type is destroyed and the new ok value is copy constructed from the contained value of the <a class="el" href="classsumty_1_1ok__t.html">ok_t</a>.</p>
<p>This function only participates in overload resolution if <code>T</code> is constructible and assignable from value contained in the <a class="el" href="classsumty_1_1ok__t.html">ok_t</a>.</p>
<h2><a class="anchor" id="autotoc_md344"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{};</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> <a class="code hl_class" href="classsumty_1_1result.html">ok_val</a> = <a class="code hl_class" href="classsumty_1_1result.html">ok&lt;float&gt;</a>(3.14);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">res</a> = <a class="code hl_class" href="classsumty_1_1result.html">ok_val</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">res</a>.<a class="code hl_function" href="classsumty_1_1result.html#a6988ba57722f67cbb444b0931468282e">has_value</a>());</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">res</a> == 3);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa090126fd8f5f80c8d60ce3bd95b89b1" name="aa090126fd8f5f80c8d60ce3bd95b89b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa090126fd8f5f80c8d60ce3bd95b89b1">&#9670;&#160;</a></span>operator=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>The destination <a class="el" href="classsumty_1_1result.html">result</a> is reassigned such that it will now contain a copy of the contained value of the source <a class="el" href="classsumty_1_1result.html">result</a>, which may be either the ok type or the error type.</p>
<p>If both the source and destination contain the ok type, or both contain the error type, the values are copy assigned directly. Otherwise, the old value in the destination is destroyed and the new value is copy constructed.</p>
<p>This function is <code>noexcept</code> if both <code>T</code> and <code>E</code> are all of the following:</p><ul>
<li>Nothrow copy assignable</li>
<li>Nothrow copy constructible</li>
<li>Nothrow destructible</li>
</ul>
<h2><a class="anchor" id="autotoc_md341"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;float, const char*&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{3.14};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;float, const char*&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">result&lt;int, std::string&gt; res3{};</div>
<div class="line">result&lt;int, std::string&gt; res4{};</div>
<div class="line"> </div>
<div class="line">res3 = res1;</div>
<div class="line">res4 = res2;</div>
<div class="line"> </div>
<div class="line">assert(res3.has_value());</div>
<div class="line">assert(*res3 == 3);</div>
<div class="line"> </div>
<div class="line">assert(!res4.has_value());</div>
<div class="line">assert(res4.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa8cdb324cf406ba97202a4add5b61c82" name="aa8cdb324cf406ba97202a4add5b61c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cdb324cf406ba97202a4add5b61c82">&#9670;&#160;</a></span>operator=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1error__t.html">error_t</a>&lt; <a class="el" href="classsumty_1_1result.html">V</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment from <a class="el" href="classsumty_1_1error__t.html">error_t</a>. </p>
<p>Sets the <a class="el" href="classsumty_1_1result.html">result</a> to contain the moved error value contained in the <a class="el" href="classsumty_1_1error__t.html">error_t</a>, converted to <code>E</code>. If the <a class="el" href="classsumty_1_1result.html">result</a> already contains an error value, the new value is move assigned directly to the contained value. Otherwise, the ok type is destroyed and the new error value is move constructed from the contained value of the <a class="el" href="classsumty_1_1error__t.html">error_t</a>.</p>
<p>This function only participates in overload resolution if <code>E</code> is constructible and assignable from value contained in the <a class="el" href="classsumty_1_1error__t.html">error_t</a>.</p>
<h2><a class="anchor" id="autotoc_md347"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">res</a> = <a class="code hl_class" href="classsumty_1_1result.html">error&lt;const char*&gt;</a>(<span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(!<a class="code hl_class" href="classsumty_1_1result.html">res</a>.<a class="code hl_function" href="classsumty_1_1result.html#a6988ba57722f67cbb444b0931468282e">has_value</a>());</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">res</a>.<a class="code hl_function" href="classsumty_1_1result.html#a1fc95966d58ae6508accb53ae1617b16">error</a>() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af697bd3286ff5dd2783e0856a4964c64" name="af697bd3286ff5dd2783e0856a4964c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af697bd3286ff5dd2783e0856a4964c64">&#9670;&#160;</a></span>operator=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1ok__t.html">ok_t</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment from <a class="el" href="classsumty_1_1ok__t.html">ok_t</a>. </p>
<p>Sets the <a class="el" href="classsumty_1_1result.html">result</a> to contain moved ok value contained in the <a class="el" href="classsumty_1_1ok__t.html">ok_t</a>, converted to <code>T</code>. If the <a class="el" href="classsumty_1_1result.html">result</a> already contains an ok value, the new value is move assigned directly to the contained value. Otherwise, the error type is destroyed and the new ok value is move constructed from the contained value of the <a class="el" href="classsumty_1_1ok__t.html">ok_t</a>.</p>
<p>This function only participates in overload resolution if <code>T</code> is constructible and assignable from the moved contained value from the <a class="el" href="classsumty_1_1ok__t.html">ok_t</a>.</p>
<h2><a class="anchor" id="autotoc_md345"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">res</a> = <a class="code hl_class" href="classsumty_1_1result.html">ok&lt;float&gt;</a>(3.14);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">res</a>.<a class="code hl_function" href="classsumty_1_1result.html#a6988ba57722f67cbb444b0931468282e">has_value</a>());</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">res</a> == 3);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab9cd1b26b7960cc6dd921ee372146b9f" name="ab9cd1b26b7960cc6dd921ee372146b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9cd1b26b7960cc6dd921ee372146b9f">&#9670;&#160;</a></span>operator=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<p>The destination <a class="el" href="classsumty_1_1result.html">result</a> is reassigned such that it will now contain the moved contained value of the source <a class="el" href="classsumty_1_1result.html">result</a>, which may be either the ok type or the error type.</p>
<p>If both the source and destination contain the ok type, or both contain the error type, the values are move assigned directly. Otherwise, the old value in the destination is destroyed and the new value is move constructed.</p>
<p>This function is <code>noexcept</code> if both <code>T</code> and <code>E</code> are all of the following:</p><ul>
<li>Nothrow move assignable</li>
<li>Nothrow move constructible</li>
<li>Nothrow destructible</li>
</ul>
<h2><a class="anchor" id="autotoc_md342"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;float, const char*&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{3.14};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;float, const char*&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">result&lt;int, std::string&gt; res3{};</div>
<div class="line">result&lt;int, std::string&gt; res4{};</div>
<div class="line"> </div>
<div class="line">res3 = std::move(res1);</div>
<div class="line">res4 = std::move(res2);</div>
<div class="line"> </div>
<div class="line">assert(res3.has_value());</div>
<div class="line">assert(*res3 == 3);</div>
<div class="line"> </div>
<div class="line">assert(!res4.has_value());</div>
<div class="line">assert(res4.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="acd498b6eddbc95ce9557c9eb5ebb60de" name="acd498b6eddbc95ce9557c9eb5ebb60de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd498b6eddbc95ce9557c9eb5ebb60de">&#9670;&#160;</a></span>operator=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">U</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value assignment operator. </p>
<p>Sets the <a class="el" href="classsumty_1_1result.html">result</a> to contain the forwarded ok value, converted to <code>T</code>. If the <a class="el" href="classsumty_1_1result.html">result</a> already contains an ok value, the forwarded value is assigned directly to the contained value. Otherwise, the error type is destroyed, and the ok type is constructed from the forwarded value.</p>
<p>This function only participates in overload resolution if:</p><ul>
<li>The source value is not a <a class="el" href="classsumty_1_1result.html">result</a></li>
<li>The source value is not a <a class="el" href="classsumty_1_1ok__t.html">ok_t</a></li>
<li>The source value is not a <a class="el" href="classsumty_1_1error__t.html">error_t</a></li>
<li><code>T</code> is constructible from <code>U</code></li>
<li><code>T</code> is assignable from <code>U</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md343"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">res</a> = 3.14;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">res</a>.<a class="code hl_function" href="classsumty_1_1result.html#a6988ba57722f67cbb444b0931468282e">has_value</a>());</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">res</a> == 3);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3990e51c7f8204123bd70cfbd22405ce" name="a3990e51c7f8204123bd70cfbd22405ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3990e51c7f8204123bd70cfbd22405ce">&#9670;&#160;</a></span>or_else() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> or_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of invoking <code>f</code> if the <a class="el" href="classsumty_1_1result.html">result</a> is an error. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, the entire <a class="el" href="classsumty_1_1result.html">result</a> is returned. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, <code>f</code> is invoked with the error value as an argument, and the returned value from invoking <code>f</code> is returned from this function, converting to <code>result&lt;T, E&gt;</code> if necessary.</p>
<h2><a class="anchor" id="autotoc_md385"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_new = std::move(res1).<a class="code hl_function" href="classsumty_1_1result.html#a06cfc81cf51508476d2641d8b086ffb5">or_else</a>([]([[maybe_unused]] <span class="keyword">auto</span> err) {</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> res2_new = std::move(res2).<a class="code hl_function" href="classsumty_1_1result.html#a06cfc81cf51508476d2641d8b086ffb5">or_else</a>([]([[maybe_unused]] <span class="keyword">auto</span> err) {</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">assert(res1_new.is_ok());</div>
<div class="line">assert(*res1_new == 42);</div>
<div class="line"> </div>
<div class="line">assert(res2_new.is_ok());</div>
<div class="line">assert(*res2_new == 0);</div>
<div class="ttc" id="aclasssumty_1_1result_html_a06cfc81cf51508476d2641d8b086ffb5"><div class="ttname"><a href="classsumty_1_1result.html#a06cfc81cf51508476d2641d8b086ffb5">sumty::result::or_else</a></div><div class="ttdeci">constexpr result or_else(F &amp;&amp;f) const &amp;</div><div class="ttdoc">Returns the result of invoking f if the result is an error.</div><div class="ttdef"><b>Definition</b> result.hpp:3398</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a06cfc81cf51508476d2641d8b086ffb5" name="a06cfc81cf51508476d2641d8b086ffb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06cfc81cf51508476d2641d8b086ffb5">&#9670;&#160;</a></span>or_else() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a> or_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of invoking <code>f</code> if the <a class="el" href="classsumty_1_1result.html">result</a> is an error. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, a copy of the entire <a class="el" href="classsumty_1_1result.html">result</a> is returned. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, <code>f</code> is invoked with the error value as an argument, and the returned value from invoking <code>f</code> is returned from this function, converting to <code>result&lt;T, E&gt;</code> if necessary.</p>
<h2><a class="anchor" id="autotoc_md384"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_new = res1.<a class="code hl_function" href="classsumty_1_1result.html#a06cfc81cf51508476d2641d8b086ffb5">or_else</a>([]([[maybe_unused]] <span class="keyword">const</span> <span class="keyword">auto</span>&amp; err) {</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> res2_new = res2.<a class="code hl_function" href="classsumty_1_1result.html#a06cfc81cf51508476d2641d8b086ffb5">or_else</a>([]([[maybe_unused]] <span class="keyword">const</span> <span class="keyword">auto</span>&amp; err) {</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">assert(res1_new.is_ok());</div>
<div class="line">assert(*res1_new == 42);</div>
<div class="line"> </div>
<div class="line">assert(res2_new.is_ok());</div>
<div class="line">assert(*res2_new == 0);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0484cd9f647695a31a901632d27d6106" name="a0484cd9f647695a31a901632d27d6106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0484cd9f647695a31a901632d27d6106">&#9670;&#160;</a></span>or_none() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1option.html">option</a>&lt; T &gt; or_none </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discards error values and converts into an <a class="el" href="classsumty_1_1option.html">option</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, that value is returned wrapped in an <a class="el" href="classsumty_1_1option.html">option</a>. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, <code>none</code> is returned.</p>
<h2><a class="anchor" id="autotoc_md406"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">option&lt;int&gt; opt1 = std::move(res1).<a class="code hl_function" href="classsumty_1_1result.html#a727c305ee903a4a61093e513d865739f">or_none</a>();</div>
<div class="line">option&lt;int&gt; opt2 = std::move(res2).<a class="code hl_function" href="classsumty_1_1result.html#a727c305ee903a4a61093e513d865739f">or_none</a>();</div>
<div class="line"> </div>
<div class="line">assert(opt1.is_some());</div>
<div class="line">assert(*opt1 == 42);</div>
<div class="line"> </div>
<div class="line">assert(opt2.is_none());</div>
<div class="ttc" id="aclasssumty_1_1result_html_a727c305ee903a4a61093e513d865739f"><div class="ttname"><a href="classsumty_1_1result.html#a727c305ee903a4a61093e513d865739f">sumty::result::or_none</a></div><div class="ttdeci">constexpr option&lt; T &gt; or_none() const &amp;noexcept</div><div class="ttdoc">Discards error values and converts into an option.</div><div class="ttdef"><b>Definition</b> result.hpp:4415</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a727c305ee903a4a61093e513d865739f" name="a727c305ee903a4a61093e513d865739f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727c305ee903a4a61093e513d865739f">&#9670;&#160;</a></span>or_none() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1option.html">option</a>&lt; T &gt; or_none </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discards error values and converts into an <a class="el" href="classsumty_1_1option.html">option</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, a copy of that value is returned wrapped in an <a class="el" href="classsumty_1_1option.html">option</a>. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, <code>none</code> is returned.</p>
<h2><a class="anchor" id="autotoc_md405"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">option&lt;int&gt; opt1 = res1.<a class="code hl_function" href="classsumty_1_1result.html#a727c305ee903a4a61093e513d865739f">or_none</a>();</div>
<div class="line">option&lt;int&gt; opt2 = res2.<a class="code hl_function" href="classsumty_1_1result.html#a727c305ee903a4a61093e513d865739f">or_none</a>();</div>
<div class="line"> </div>
<div class="line">assert(opt1.is_some());</div>
<div class="line">assert(*opt1 == 42);</div>
<div class="line"> </div>
<div class="line">assert(opt2.is_none());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3a886492e6e8f5addbe596c77708250e" name="a3a886492e6e8f5addbe596c77708250e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a886492e6e8f5addbe596c77708250e">&#9670;&#160;</a></span>ref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; <a class="el" href="classsumty_1_1result.html">const_reference</a>, <a class="el" href="classsumty_1_1result.html">error_const_reference</a> &gt; ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="classsumty_1_1result.html">result</a> reference into a <a class="el" href="classsumty_1_1result.html">result</a> of references. </p>
<h2><a class="anchor" id="autotoc_md403"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">result&lt;const int&amp;, const std::string&amp;&gt; res1_ref = res1.<a class="code hl_function" href="classsumty_1_1result.html#aab2208991e2042cbd89a22efa8fdace6">ref</a>();</div>
<div class="line">result&lt;const int&amp;, const std::string&amp;&gt; ref2_ref = res2.<a class="code hl_function" href="classsumty_1_1result.html#aab2208991e2042cbd89a22efa8fdace6">ref</a>();</div>
<div class="line"> </div>
<div class="line">assert(res1_ref.is_ok());</div>
<div class="line">assert(&amp;*res1_ref == &amp;*res1);</div>
<div class="line"> </div>
<div class="line">assert(res2_ref.is_error());</div>
<div class="line">assert(&amp;res2_ref.error() == &amp;res2.error());</div>
<div class="ttc" id="aclasssumty_1_1result_html_aab2208991e2042cbd89a22efa8fdace6"><div class="ttname"><a href="classsumty_1_1result.html#aab2208991e2042cbd89a22efa8fdace6">sumty::result::ref</a></div><div class="ttdeci">constexpr result&lt; reference, error_reference &gt; ref() noexcept</div><div class="ttdoc">Converts a result reference into a result of references.</div><div class="ttdef"><b>Definition</b> result.hpp:4321</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aab2208991e2042cbd89a22efa8fdace6" name="aab2208991e2042cbd89a22efa8fdace6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2208991e2042cbd89a22efa8fdace6">&#9670;&#160;</a></span>ref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; <a class="el" href="classsumty_1_1result.html">reference</a>, <a class="el" href="classsumty_1_1result.html">error_reference</a> &gt; ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="classsumty_1_1result.html">result</a> reference into a <a class="el" href="classsumty_1_1result.html">result</a> of references. </p>
<h2><a class="anchor" id="autotoc_md402"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">result&lt;int&amp;, std::string&amp;&gt; res1_ref = res1.<a class="code hl_function" href="classsumty_1_1result.html#aab2208991e2042cbd89a22efa8fdace6">ref</a>();</div>
<div class="line">result&lt;int&amp;, std::string&amp;&gt; ref2_ref = res2.<a class="code hl_function" href="classsumty_1_1result.html#aab2208991e2042cbd89a22efa8fdace6">ref</a>();</div>
<div class="line"> </div>
<div class="line">assert(res1_ref.is_ok());</div>
<div class="line">assert(&amp;*res1_ref == &amp;*res1);</div>
<div class="line"> </div>
<div class="line">assert(res2_ref.is_error());</div>
<div class="line">assert(&amp;res2_ref.error() == &amp;res2.error());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9a3be55eeb914e44478166807b43eef9" name="a9a3be55eeb914e44478166807b43eef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3be55eeb914e44478166807b43eef9">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">void</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two <a class="el" href="classsumty_1_1result.html">result</a> instances. </p>
<p>If both <a class="el" href="classsumty_1_1result.html">result</a> instances contain an ok value or both contain an error value, the values are swapped directly. If the two <a class="el" href="classsumty_1_1result.html">result</a> instances do not contain the same kind of value, the values are moved out of the results temporarily, the old values are destroyed, and new values a move constructed in to the opposite <a class="el" href="classsumty_1_1result.html">result</a>.</p>
<h2><a class="anchor" id="autotoc_md421"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">res1.<a class="code hl_function" href="classsumty_1_1result.html#a9a3be55eeb914e44478166807b43eef9">swap</a>(res2);</div>
<div class="line"> </div>
<div class="line">assert(res1.is_error());</div>
<div class="line">assert(res1.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res2.is_ok());</div>
<div class="line">assert(*res2 == 42);</div>
<div class="ttc" id="aclasssumty_1_1result_html_a9a3be55eeb914e44478166807b43eef9"><div class="ttname"><a href="classsumty_1_1result.html#a9a3be55eeb914e44478166807b43eef9">sumty::result::swap</a></div><div class="ttdeci">constexpr void swap(result &amp;other) CONDITIONALLY_NOEXCEPT</div><div class="ttdoc">Swaps two result instances.</div><div class="ttdef"><b>Definition</b> result.hpp:5066</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a53b47c4e5b7d606127eca04576b1f657" name="a53b47c4e5b7d606127eca04576b1f657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b47c4e5b7d606127eca04576b1f657">&#9670;&#160;</a></span>transform() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perforams a transformation on the ok value of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, that value is passed to the transformation callable provided. The value returned from the callable is then returned from this function as the ok value of a new <a class="el" href="classsumty_1_1result.html">result</a>, where ok type of the new result is the exact type returned from the callable. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, a copy of the error is returned.</p>
<p>Note that this function is identical to <a class="el" href="classsumty_1_1result.html#a78adcf88fdf6b1ddd812fded133e5d27">map</a>, but the name <code>transform</code> makes <a class="el" href="classsumty_1_1result.html">result</a> able to be a drop in replacement for <code>std::expected</code>. <code>map</code> is the more typical name of this monadic operation outside of C++.</p>
<h2><a class="anchor" id="autotoc_md376"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_mapped = res1.<a class="code hl_function" href="classsumty_1_1result.html#a53b47c4e5b7d606127eca04576b1f657">transform</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> res2_mapped = res2.<a class="code hl_function" href="classsumty_1_1result.html#a53b47c4e5b7d606127eca04576b1f657">transform</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">assert(res1_mapped.is_error());</div>
<div class="line">assert(res1_mapped.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res2_mapped.is_ok());</div>
<div class="line">assert(*res2_mapped == <span class="stringliteral">&quot;42&quot;</span>);</div>
<div class="ttc" id="aclasssumty_1_1result_html_a53b47c4e5b7d606127eca04576b1f657"><div class="ttname"><a href="classsumty_1_1result.html#a53b47c4e5b7d606127eca04576b1f657">sumty::result::transform</a></div><div class="ttdeci">constexpr auto transform(F &amp;&amp;f) &amp;</div><div class="ttdoc">Perforams a transformation on the ok value of a result.</div><div class="ttdef"><b>Definition</b> result.hpp:2966</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a77adc2e081bfb5e7605e97ed93c22e72" name="a77adc2e081bfb5e7605e97ed93c22e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77adc2e081bfb5e7605e97ed93c22e72">&#9670;&#160;</a></span>transform() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perforams a transformation on the ok value of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, that value is passed to the transformation callable provided. The value returned from the callable is then returned from this function as the ok value of a new <a class="el" href="classsumty_1_1result.html">result</a>, where ok type of the new result is the exact type returned from the callable. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, the error is returned.</p>
<p>Note that this function is identical to <a class="el" href="classsumty_1_1result.html#a78adcf88fdf6b1ddd812fded133e5d27">map</a>, but the name <code>transform</code> makes <a class="el" href="classsumty_1_1result.html">result</a> able to be a drop in replacement for <code>std::expected</code>. <code>map</code> is the more typical name of this monadic operation outside of C++.</p>
<h2><a class="anchor" id="autotoc_md378"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_mapped = std::move(res1).<a class="code hl_function" href="classsumty_1_1result.html#a53b47c4e5b7d606127eca04576b1f657">transform</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> res2_mapped = std::move(res2).<a class="code hl_function" href="classsumty_1_1result.html#a53b47c4e5b7d606127eca04576b1f657">transform</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">assert(res1_mapped.is_error());</div>
<div class="line">assert(res1_mapped.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res2_mapped.is_ok());</div>
<div class="line">assert(*res2_mapped == <span class="stringliteral">&quot;42&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab615fc0f0e34cfb71e49a0f5695d5c5b" name="ab615fc0f0e34cfb71e49a0f5695d5c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab615fc0f0e34cfb71e49a0f5695d5c5b">&#9670;&#160;</a></span>transform() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perforams a transformation on the ok value of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, that value is passed to the transformation callable provided. The value returned from the callable is then returned from this function as the ok value of a new <a class="el" href="classsumty_1_1result.html">result</a>, where ok type of the new result is the exact type returned from the callable. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, a copy of the error is returned.</p>
<p>Note that this function is identical to <a class="el" href="classsumty_1_1result.html#a78adcf88fdf6b1ddd812fded133e5d27">map</a>, but the name <code>transform</code> makes <a class="el" href="classsumty_1_1result.html">result</a> able to be a drop in replacement for <code>std::expected</code>. <code>map</code> is the more typical name of this monadic operation outside of C++.</p>
<h2><a class="anchor" id="autotoc_md377"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_mapped = res1.<a class="code hl_function" href="classsumty_1_1result.html#a53b47c4e5b7d606127eca04576b1f657">transform</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> res2_mapped = res2.<a class="code hl_function" href="classsumty_1_1result.html#a53b47c4e5b7d606127eca04576b1f657">transform</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">assert(res1_mapped.is_error());</div>
<div class="line">assert(res1_mapped.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res2_mapped.is_ok());</div>
<div class="line">assert(*res2_mapped == <span class="stringliteral">&quot;42&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af687c1f031fc58d3240a81e3d6718c89" name="af687c1f031fc58d3240a81e3d6718c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af687c1f031fc58d3240a81e3d6718c89">&#9670;&#160;</a></span>transform() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perforams a transformation on the ok value of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, that value is passed to the transformation callable provided. The value returned from the callable is then returned from this function as the ok value of a new <a class="el" href="classsumty_1_1result.html">result</a>, where ok type of the new result is the exact type returned from the callable. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, the error is returned.</p>
<p>Note that this function is identical to <a class="el" href="classsumty_1_1result.html#a78adcf88fdf6b1ddd812fded133e5d27">map</a>, but the name <code>transform</code> makes <a class="el" href="classsumty_1_1result.html">result</a> able to be a drop in replacement for <code>std::expected</code>. <code>map</code> is the more typical name of this monadic operation outside of C++.</p>
<h2><a class="anchor" id="autotoc_md379"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_mapped = std::move(res1).<a class="code hl_function" href="classsumty_1_1result.html#a53b47c4e5b7d606127eca04576b1f657">transform</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> res2_mapped = std::move(res2).<a class="code hl_function" href="classsumty_1_1result.html#a53b47c4e5b7d606127eca04576b1f657">transform</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">assert(res1_mapped.is_error());</div>
<div class="line">assert(res1_mapped.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res2_mapped.is_ok());</div>
<div class="line">assert(*res2_mapped == <span class="stringliteral">&quot;42&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a610f631536779752a99a9346cd7f1055" name="a610f631536779752a99a9346cd7f1055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610f631536779752a99a9346cd7f1055">&#9670;&#160;</a></span>transform_error() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> transform_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perforams a transformation on the error value of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, that value is passed to the transformation callable provided. The value returned from the callable is then returned from this function as the error value of a new <a class="el" href="classsumty_1_1result.html">result</a>, where the error type of the new result is the exact type returned from the callable. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, a copy of the ok value is returned.</p>
<p>Note that this function is identical to <a class="el" href="classsumty_1_1result.html#a19c341e98b54b0017bed0e1911edd3ec">map_error</a>, but the name <code>transform_error</code> makes <a class="el" href="classsumty_1_1result.html">result</a> able to be a drop in replacement for <code>std::expected</code>. <code>map_error</code> would be the more typical name of this monadic operation outside of C++.</p>
<h2><a class="anchor" id="autotoc_md394"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;void, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;void, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, 42};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_mapped = res1.<a class="code hl_function" href="classsumty_1_1result.html#a610f631536779752a99a9346cd7f1055">transform_error</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> res2_mapped = res2.<a class="code hl_function" href="classsumty_1_1result.html#a610f631536779752a99a9346cd7f1055">transform_error</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">assert(res1_mapped.is_ok());</div>
<div class="line"> </div>
<div class="line">assert(res2_mapped.is_error());</div>
<div class="line">assert(*res2_mapped == <span class="stringliteral">&quot;42&quot;</span>);</div>
<div class="ttc" id="aclasssumty_1_1result_html_a610f631536779752a99a9346cd7f1055"><div class="ttname"><a href="classsumty_1_1result.html#a610f631536779752a99a9346cd7f1055">sumty::result::transform_error</a></div><div class="ttdeci">constexpr auto transform_error(F &amp;&amp;f) &amp;</div><div class="ttdoc">Perforams a transformation on the error value of a result.</div><div class="ttdef"><b>Definition</b> result.hpp:3907</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2ed39d0f8e1fc34a33547f4e0a8c4763" name="a2ed39d0f8e1fc34a33547f4e0a8c4763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed39d0f8e1fc34a33547f4e0a8c4763">&#9670;&#160;</a></span>transform_error() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> transform_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perforams a transformation on the error value of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, that value is passed to the transformation callable provided. The value returned from the callable is then returned from this function as the error value of a new <a class="el" href="classsumty_1_1result.html">result</a>, where the error type of the new result is the exact type returned from the callable. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, the ok value is returned.</p>
<p>Note that this function is identical to <a class="el" href="classsumty_1_1result.html#a19c341e98b54b0017bed0e1911edd3ec">map_error</a>, but the name <code>transform_error</code> makes <a class="el" href="classsumty_1_1result.html">result</a> able to be a drop in replacement for <code>std::expected</code>. <code>map_error</code> would be the more typical name of this monadic operation outside of C++.</p>
<h2><a class="anchor" id="autotoc_md396"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;void, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;void, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, 42};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_mapped = std::move(res1).<a class="code hl_function" href="classsumty_1_1result.html#a610f631536779752a99a9346cd7f1055">transform_error</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> res2_mapped = std::move(res2).<a class="code hl_function" href="classsumty_1_1result.html#a610f631536779752a99a9346cd7f1055">transform_error</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">assert(res1_mapped.is_ok());</div>
<div class="line"> </div>
<div class="line">assert(res2_mapped.is_error());</div>
<div class="line">assert(*res2_mapped == <span class="stringliteral">&quot;42&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5862690fd808854bb4af0b7793ce1c72" name="a5862690fd808854bb4af0b7793ce1c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5862690fd808854bb4af0b7793ce1c72">&#9670;&#160;</a></span>transform_error() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> transform_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perforams a transformation on the error value of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, that value is passed to the transformation callable provided. The value returned from the callable is then returned from this function as the error value of a new <a class="el" href="classsumty_1_1result.html">result</a>, where the error type of the new result is the exact type returned from the callable. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, a copy of the ok value is returned.</p>
<p>Note that this function is identical to <a class="el" href="classsumty_1_1result.html#a19c341e98b54b0017bed0e1911edd3ec">map_error</a>, but the name <code>transform_error</code> makes <a class="el" href="classsumty_1_1result.html">result</a> able to be a drop in replacement for <code>std::expected</code>. <code>map_error</code> would be the more typical name of this monadic operation outside of C++.</p>
<h2><a class="anchor" id="autotoc_md395"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;void, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;void, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, 42};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_mapped = res1.<a class="code hl_function" href="classsumty_1_1result.html#a610f631536779752a99a9346cd7f1055">transform_error</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> res2_mapped = res2.<a class="code hl_function" href="classsumty_1_1result.html#a610f631536779752a99a9346cd7f1055">transform_error</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">assert(res1_mapped.is_ok());</div>
<div class="line"> </div>
<div class="line">assert(res2_mapped.is_error());</div>
<div class="line">assert(*res2_mapped == <span class="stringliteral">&quot;42&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a77d61c4713e392b4b7dc0d94269520e5" name="a77d61c4713e392b4b7dc0d94269520e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d61c4713e392b4b7dc0d94269520e5">&#9670;&#160;</a></span>transform_error() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> transform_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perforams a transformation on the error value of a <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, that value is passed to the transformation callable provided. The value returned from the callable is then returned from this function as the error value of a new <a class="el" href="classsumty_1_1result.html">result</a>, where the error type of the new result is the exact type returned from the callable. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, the ok value is returned.</p>
<p>Note that this function is identical to <a class="el" href="classsumty_1_1result.html#a19c341e98b54b0017bed0e1911edd3ec">map_error</a>, but the name <code>transform_error</code> makes <a class="el" href="classsumty_1_1result.html">result</a> able to be a drop in replacement for <code>std::expected</code>. <code>map_error</code> would be the more typical name of this monadic operation outside of C++.</p>
<h2><a class="anchor" id="autotoc_md397"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;void, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;void, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, 42};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1_mapped = std::move(res1).<a class="code hl_function" href="classsumty_1_1result.html#a610f631536779752a99a9346cd7f1055">transform_error</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> res2_mapped = std::move(res2).<a class="code hl_function" href="classsumty_1_1result.html#a610f631536779752a99a9346cd7f1055">transform_error</a>([](<span class="keyword">auto</span> <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">assert(res1_mapped.is_ok());</div>
<div class="line"> </div>
<div class="line">assert(res2_mapped.is_error());</div>
<div class="line">assert(*res2_mapped == <span class="stringliteral">&quot;42&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6cac08061795894102b76c5e5427b50d" name="a6cac08061795894102b76c5e5427b50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cac08061795894102b76c5e5427b50d">&#9670;&#160;</a></span>transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <code>result&lt;option&lt;T&gt;, E&gt;</code> into <code>option&lt;result&lt;T, E&gt;&gt;</code> </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, the return value will be a <a class="el" href="classsumty_1_1option.html">option</a> that contains a <a class="el" href="classsumty_1_1result.html">result</a> that contains an error. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an <a class="el" href="classsumty_1_1option.html">option</a> that contains a value, the return value will be a <a class="el" href="classsumty_1_1option.html">option</a> that contains <a class="el" href="classsumty_1_1result.html">result</a> that contains an ok value. If the <a class="el" href="classsumty_1_1result.html">result</a> contains a <a class="el" href="classsumty_1_1option.html">option</a> that is <code>none</code>, the return value will be an <a class="el" href="classsumty_1_1option.html">option</a> that is <code>none</code>.</p>
<p>This function only participates in overload resolution of <code>T</code> is an <a class="el" href="classsumty_1_1option.html">option</a>.</p>
<h2><a class="anchor" id="autotoc_md391"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;option&lt;int&gt;</a>, std::string&gt; <a class="code hl_class" href="classsumty_1_1result.html">val1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;option&lt;int&gt;</a>, std::string&gt; <a class="code hl_class" href="classsumty_1_1result.html">val2</a>{none};</div>
<div class="line">result&lt;option&lt;int&gt;, std::string&gt; val3{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> val1_trans = std::move(val1).<a class="code hl_function" href="classsumty_1_1result.html#ae58629470af132787ab0ae0169e8a087">transpose</a>();</div>
<div class="line"><span class="keyword">auto</span> val2_trans = std::move(val2).<a class="code hl_function" href="classsumty_1_1result.html#ae58629470af132787ab0ae0169e8a087">transpose</a>();</div>
<div class="line"><span class="keyword">auto</span> val3_trans = std::move(val3).<a class="code hl_function" href="classsumty_1_1result.html#ae58629470af132787ab0ae0169e8a087">transpose</a>();</div>
<div class="line"> </div>
<div class="line">assert(val1_trans.is_some());</div>
<div class="line">assert(val1_trans-&gt;is_ok());</div>
<div class="line">assert(**val1_trans == 42);</div>
<div class="line"> </div>
<div class="line">assert(val2_trans.is_none());</div>
<div class="line"> </div>
<div class="line">assert(val3_trans.is_some());</div>
<div class="line">assert(val3_trans-&gt;is_error());</div>
<div class="line">assert(val3_trans-&gt;error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="ttc" id="aclasssumty_1_1result_html_ae58629470af132787ab0ae0169e8a087"><div class="ttname"><a href="classsumty_1_1result.html#ae58629470af132787ab0ae0169e8a087">sumty::result::transpose</a></div><div class="ttdeci">constexpr auto transpose() const &amp;</div><div class="ttdoc">Converts result&lt;option&lt;T&gt;, E&gt; into option&lt;result&lt;T, E&gt;&gt;</div><div class="ttdef"><b>Definition</b> result.hpp:3749</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae58629470af132787ab0ae0169e8a087" name="ae58629470af132787ab0ae0169e8a087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58629470af132787ab0ae0169e8a087">&#9670;&#160;</a></span>transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">auto</a> transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <code>result&lt;option&lt;T&gt;, E&gt;</code> into <code>option&lt;result&lt;T, E&gt;&gt;</code> </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, the return value will be a <a class="el" href="classsumty_1_1option.html">option</a> that contains a <a class="el" href="classsumty_1_1result.html">result</a> that contains an error. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an <a class="el" href="classsumty_1_1option.html">option</a> that contains a value, the return value will be a <a class="el" href="classsumty_1_1option.html">option</a> that contains <a class="el" href="classsumty_1_1result.html">result</a> that contains an ok value. If the <a class="el" href="classsumty_1_1result.html">result</a> contains a <a class="el" href="classsumty_1_1option.html">option</a> that is <code>none</code>, the return value will be an <a class="el" href="classsumty_1_1option.html">option</a> that is <code>none</code>.</p>
<p>This function only participates in overload resolution of <code>T</code> is an <a class="el" href="classsumty_1_1option.html">option</a>.</p>
<h2><a class="anchor" id="autotoc_md390"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;option&lt;int&gt;</a>, std::string&gt; <a class="code hl_class" href="classsumty_1_1result.html">val1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;option&lt;int&gt;</a>, std::string&gt; <a class="code hl_class" href="classsumty_1_1result.html">val2</a>{none};</div>
<div class="line">result&lt;option&lt;int&gt;, std::string&gt; val3{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> val1_trans = val1.<a class="code hl_function" href="classsumty_1_1result.html#ae58629470af132787ab0ae0169e8a087">transpose</a>();</div>
<div class="line"><span class="keyword">auto</span> val2_trans = val2.<a class="code hl_function" href="classsumty_1_1result.html#ae58629470af132787ab0ae0169e8a087">transpose</a>();</div>
<div class="line"><span class="keyword">auto</span> val3_trans = val3.<a class="code hl_function" href="classsumty_1_1result.html#ae58629470af132787ab0ae0169e8a087">transpose</a>();</div>
<div class="line"> </div>
<div class="line">assert(val1_trans.is_some());</div>
<div class="line">assert(val1_trans-&gt;is_ok());</div>
<div class="line">assert(**val1_trans == 42);</div>
<div class="line"> </div>
<div class="line">assert(val2_trans.is_none());</div>
<div class="line"> </div>
<div class="line">assert(val3_trans.is_some());</div>
<div class="line">assert(val3_trans-&gt;is_error());</div>
<div class="line">assert(val3_trans-&gt;error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0fe474d55f5039d5c97b6b8dd5a25a66" name="a0fe474d55f5039d5c97b6b8dd5a25a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe474d55f5039d5c97b6b8dd5a25a66">&#9670;&#160;</a></span>value() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">reference</a> value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the ok value contained in the <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>This function first checks if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value before attempting to access the value. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, then this function throws an exception.</p>
<h2><a class="anchor" id="autotoc_md358"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">res</a> == 42);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__result__access.html">bad_result_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1result.html">result</a> contains an error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae68a284bd8f5cc8f7e089453565a8073" name="ae68a284bd8f5cc8f7e089453565a8073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68a284bd8f5cc8f7e089453565a8073">&#9670;&#160;</a></span>value() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">rvalue_reference</a> value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the ok value contained in the <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>This function first checks if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value before attempting to access the value. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, then this function throws an exception.</p>
<h2><a class="anchor" id="autotoc_md360"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*std::move(<a class="code hl_class" href="classsumty_1_1result.html">res</a>) == 42);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__result__access.html">bad_result_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1result.html">result</a> contains an error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cc19624ae3495f0f09862da2df1da44" name="a2cc19624ae3495f0f09862da2df1da44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc19624ae3495f0f09862da2df1da44">&#9670;&#160;</a></span>value() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">const_reference</a> value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the ok value contained in the <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>This function first checks if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value before attempting to access the value. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, then this function throws an exception.</p>
<h2><a class="anchor" id="autotoc_md359"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*<a class="code hl_class" href="classsumty_1_1result.html">res</a> == 42);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__result__access.html">bad_result_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1result.html">result</a> contains an error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27d7f45caa4c2bbe9c7a035e180f1490" name="a27d7f45caa4c2bbe9c7a035e180f1490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d7f45caa4c2bbe9c7a035e180f1490">&#9670;&#160;</a></span>value() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">rvalue_reference</a> value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the ok value contained in the <a class="el" href="classsumty_1_1result.html">result</a>. </p>
<p>This function first checks if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value before attempting to access the value. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, then this function throws an exception.</p>
<h2><a class="anchor" id="autotoc_md361"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res</a>{42};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(*std::move(<a class="code hl_class" href="classsumty_1_1result.html">res</a>) == 42);</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__result__access.html">bad_result_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1result.html">result</a> contains an error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ad65213c97d6954f6ce87a44b5a9400" name="a4ad65213c97d6954f6ce87a44b5a9400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad65213c97d6954f6ce87a44b5a9400">&#9670;&#160;</a></span>value_or() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">value_type</a> value_or </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the ok value, or a default if the <a class="el" href="classsumty_1_1result.html">result</a> is an error. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, that ok value is returned. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, a newly default constructed instance of the ok type is returned.</p>
<h2><a class="anchor" id="autotoc_md369"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;std::string, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{<span class="stringliteral">&quot;hello&quot;</span>};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;std::string, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, 42};</div>
<div class="line"> </div>
<div class="line">assert(std::move(res1).<a class="code hl_function" href="classsumty_1_1result.html#a0c86313790b2ed250d0ec34eb315bba1">value_or</a>() == <span class="stringliteral">&quot;hello&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(std::move(res2).<a class="code hl_function" href="classsumty_1_1result.html#a0c86313790b2ed250d0ec34eb315bba1">value_or</a>() == std::string());</div>
<div class="ttc" id="aclasssumty_1_1result_html_a0c86313790b2ed250d0ec34eb315bba1"><div class="ttname"><a href="classsumty_1_1result.html#a0c86313790b2ed250d0ec34eb315bba1">sumty::result::value_or</a></div><div class="ttdeci">constexpr value_type value_or(U &amp;&amp;default_value) const &amp;</div><div class="ttdoc">Gets the ok value, or a default if the result is an error.</div><div class="ttdef"><b>Definition</b> result.hpp:2506</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="add1d928422c6acbe1dfed8332a2431e2" name="add1d928422c6acbe1dfed8332a2431e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1d928422c6acbe1dfed8332a2431e2">&#9670;&#160;</a></span>value_or() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">value_type</a> value_or </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the ok value, or a default if the <a class="el" href="classsumty_1_1result.html">result</a> is an error. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, a copy of that ok value is returned. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, a newly default constructed instance of the ok type is returned.</p>
<h2><a class="anchor" id="autotoc_md368"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;std::string, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{<span class="stringliteral">&quot;hello&quot;</span>};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;std::string, int&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, 42};</div>
<div class="line"> </div>
<div class="line">assert(res1.value_or() == <span class="stringliteral">&quot;hello&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res2.value_or() == std::string());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a85ed31aeebf624ff4f015571b58d5ae2" name="a85ed31aeebf624ff4f015571b58d5ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ed31aeebf624ff4f015571b58d5ae2">&#9670;&#160;</a></span>value_or() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">value_type</a> value_or </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">U</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the ok value, or a default if the <a class="el" href="classsumty_1_1result.html">result</a> is an error. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, that ok value is returned. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, the provided default value is forwarded, cast, and returned as by the following: <code>static_cast&lt;T&gt;(std::forward&lt;U&gt;(default_value))</code>.</p>
<h2><a class="anchor" id="autotoc_md367"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">assert(std::move(res1).<a class="code hl_function" href="classsumty_1_1result.html#a0c86313790b2ed250d0ec34eb315bba1">value_or</a>(0) == 42);</div>
<div class="line"> </div>
<div class="line">assert(std::move(res2).<a class="code hl_function" href="classsumty_1_1result.html#a0c86313790b2ed250d0ec34eb315bba1">value_or</a>(0) == 0);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0c86313790b2ed250d0ec34eb315bba1" name="a0c86313790b2ed250d0ec34eb315bba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c86313790b2ed250d0ec34eb315bba1">&#9670;&#160;</a></span>value_or() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">value_type</a> value_or </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">U</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the ok value, or a default if the <a class="el" href="classsumty_1_1result.html">result</a> is an error. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, a copy of that ok value is returned. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error value, the provided default value is forwarded, cast, and returned as by the following: <code>static_cast&lt;T&gt;(std::forward&lt;U&gt;(default_value))</code>.</p>
<h2><a class="anchor" id="autotoc_md366"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">assert(res1.value_or(0) == 42);</div>
<div class="line"> </div>
<div class="line">assert(res2.value_or(0) == 0);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0533aa24f70936e326d5347b8fc0c750" name="a0533aa24f70936e326d5347b8fc0c750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0533aa24f70936e326d5347b8fc0c750">&#9670;&#160;</a></span>value_or_else() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">value_type</a> value_or_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the ok value, or returns the result of a callable. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, a copy of that ok value is returned. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, the provided callable is invoked and the result is cast and returned, as if by: <code>static_cast&lt;T&gt;(std::invoke(std::forward&lt;F&gt;(f)))</code>.</p>
<h2><a class="anchor" id="autotoc_md371"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">assert(std::move(res1).<a class="code hl_function" href="classsumty_1_1result.html#ac29aa26d2088d1bb135da8d58009137d">value_or_else</a>([] { <span class="keywordflow">return</span> 0; }) == 42);</div>
<div class="line"> </div>
<div class="line">assert(std::move(res2).<a class="code hl_function" href="classsumty_1_1result.html#ac29aa26d2088d1bb135da8d58009137d">value_or_else</a>({] { <span class="keywordflow">return</span> 0; }) == 0);</div>
<div class="ttc" id="aclasssumty_1_1result_html_ac29aa26d2088d1bb135da8d58009137d"><div class="ttname"><a href="classsumty_1_1result.html#ac29aa26d2088d1bb135da8d58009137d">sumty::result::value_or_else</a></div><div class="ttdeci">constexpr value_type value_or_else(F &amp;&amp;f) const &amp;</div><div class="ttdoc">Gets the ok value, or returns the result of a callable.</div><div class="ttdef"><b>Definition</b> result.hpp:2614</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac29aa26d2088d1bb135da8d58009137d" name="ac29aa26d2088d1bb135da8d58009137d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29aa26d2088d1bb135da8d58009137d">&#9670;&#160;</a></span>value_or_else() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">F</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">value_type</a> value_or_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the ok value, or returns the result of a callable. </p>
<p>If the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value, a copy of that ok value is returned. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, the provided callable is invoked and the result is cast and returned, as if by: <code>static_cast&lt;T&gt;(std::invoke(std::forward&lt;F&gt;(f)))</code>.</p>
<h2><a class="anchor" id="autotoc_md370"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">assert(res1.value_or_else([] { return 0; }) == 42);</div>
<div class="line"> </div>
<div class="line">assert(res2.value_or_else({] { return 0; }) == 0);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae2f575e3e78ea2171d1be475f7f9a2d8" name="ae2f575e3e78ea2171d1be475f7f9a2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f575e3e78ea2171d1be475f7f9a2d8">&#9670;&#160;</a></span>visit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes a visitor witht he contained value. </p>
<p>This function treats a <a class="el" href="classsumty_1_1result.html">result</a> as if it was a <a class="el" href="classsumty_1_1variant.html">variant</a> of <code>T</code> and <code>E</code> (i.e. <code>variant&lt;T, E&gt;</code>). If the <a class="el" href="classsumty_1_1result.html">result</a> contians an ok value, that value is passed to the visitor. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, the error is passed to the visitor. When either <code>T</code> or <code>E</code> are <code>void</code>, an instance of <a class="el" href="structsumty_1_1void__t.html">void_t</a> is passed instead.</p>
<p>Note that the overload function can be helpful for defining a visiotr inline.</p>
<h2><a class="anchor" id="autotoc_md413"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">res1.<a class="code hl_function" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>(overload([](<span class="keywordtype">int</span> ok_val) {</div>
<div class="line">    assert(ok_val == 42);</div>
<div class="line">}, [](std::string&amp; err_val) {</div>
<div class="line">    assert(<span class="keyword">false</span>);</div>
<div class="line">}));</div>
<div class="line"> </div>
<div class="line">res2.<a class="code hl_function" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>(overload([](<span class="keywordtype">int</span> ok_val) {</div>
<div class="line">    assert(<span class="keyword">false</span>);</div>
<div class="line">}, [](std::string&amp; err_val) {</div>
<div class="line">    assert(err_val == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line">}));</div>
<div class="ttc" id="aclasssumty_1_1result_html_ae2f575e3e78ea2171d1be475f7f9a2d8"><div class="ttname"><a href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">sumty::result::visit</a></div><div class="ttdeci">constexpr DEDUCED visit(V &amp;&amp;visitor) &amp;</div><div class="ttdoc">Invokes a visitor witht he contained value.</div><div class="ttdef"><b>Definition</b> result.hpp:4664</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="adaaf65bdef1581aff9bda2ed4174143d" name="adaaf65bdef1581aff9bda2ed4174143d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaaf65bdef1581aff9bda2ed4174143d">&#9670;&#160;</a></span>visit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes a visitor witht he contained value. </p>
<p>This function treats a <a class="el" href="classsumty_1_1result.html">result</a> as if it was a <a class="el" href="classsumty_1_1variant.html">variant</a> of <code>T</code> and <code>E</code> (i.e. <code>variant&lt;T, E&gt;</code>). If the <a class="el" href="classsumty_1_1result.html">result</a> contians an ok value, that value is passed to the visitor. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, the error is passed to the visitor. When either <code>T</code> or <code>E</code> are <code>void</code>, an instance of <a class="el" href="structsumty_1_1void__t.html">void_t</a> is passed instead.</p>
<p>Note that the overload function can be helpful for defining a visiotr inline.</p>
<h2><a class="anchor" id="autotoc_md415"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">std::move(res1).<a class="code hl_function" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>(overload([](<span class="keywordtype">int</span> ok_val) {</div>
<div class="line">    assert(ok_val == 42);</div>
<div class="line">}, [](std::string err_val) {</div>
<div class="line">    assert(<span class="keyword">false</span>);</div>
<div class="line">}));</div>
<div class="line"> </div>
<div class="line">std::move(res2).<a class="code hl_function" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>(overload([](<span class="keywordtype">int</span> ok_val) {</div>
<div class="line">    assert(<span class="keyword">false</span>);</div>
<div class="line">}, [](std::string err_val) {</div>
<div class="line">    assert(err_val == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line">}));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aeeca86cd9abb551e0c1e52ba81289f29" name="aeeca86cd9abb551e0c1e52ba81289f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeca86cd9abb551e0c1e52ba81289f29">&#9670;&#160;</a></span>visit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes a visitor witht he contained value. </p>
<p>This function treats a <a class="el" href="classsumty_1_1result.html">result</a> as if it was a <a class="el" href="classsumty_1_1variant.html">variant</a> of <code>T</code> and <code>E</code> (i.e. <code>variant&lt;T, E&gt;</code>). If the <a class="el" href="classsumty_1_1result.html">result</a> contians an ok value, that value is passed to the visitor. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, the error is passed to the visitor. When either <code>T</code> or <code>E</code> are <code>void</code>, an instance of <a class="el" href="structsumty_1_1void__t.html">void_t</a> is passed instead.</p>
<p>Note that the overload function can be helpful for defining a visiotr inline.</p>
<h2><a class="anchor" id="autotoc_md414"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">res1.<a class="code hl_function" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>(overload([](<span class="keywordtype">int</span> ok_val) {</div>
<div class="line">    assert(ok_val == 42);</div>
<div class="line">}, [](<span class="keyword">const</span> std::string&amp; err_val) {</div>
<div class="line">    assert(<span class="keyword">false</span>);</div>
<div class="line">}));</div>
<div class="line"> </div>
<div class="line">res2.<a class="code hl_function" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>(overload([](<span class="keywordtype">int</span> ok_val) {</div>
<div class="line">    assert(<span class="keyword">false</span>);</div>
<div class="line">}, [](<span class="keyword">const</span> std::string&amp; err_val) {</div>
<div class="line">    assert(err_val == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line">}));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a12b9d6a30c96d7caac920ce264c66de1" name="a12b9d6a30c96d7caac920ce264c66de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b9d6a30c96d7caac920ce264c66de1">&#9670;&#160;</a></span>visit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes a visitor witht he contained value. </p>
<p>This function treats a <a class="el" href="classsumty_1_1result.html">result</a> as if it was a <a class="el" href="classsumty_1_1variant.html">variant</a> of <code>T</code> and <code>E</code> (i.e. <code>variant&lt;T, E&gt;</code>). If the <a class="el" href="classsumty_1_1result.html">result</a> contians an ok value, that value is passed to the visitor. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, the error is passed to the visitor. When either <code>T</code> or <code>E</code> are <code>void</code>, an instance of <a class="el" href="structsumty_1_1void__t.html">void_t</a> is passed instead.</p>
<p>Note that the overload function can be helpful for defining a visiotr inline.</p>
<h2><a class="anchor" id="autotoc_md416"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">std::move(res1).<a class="code hl_function" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>(overload([](<span class="keywordtype">int</span> ok_val) {</div>
<div class="line">    assert(ok_val == 42);</div>
<div class="line">}, [](std::string err_val) {</div>
<div class="line">    assert(<span class="keyword">false</span>);</div>
<div class="line">}));</div>
<div class="line"> </div>
<div class="line">std::move(res2).<a class="code hl_function" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>(overload([](<span class="keywordtype">int</span> ok_val) {</div>
<div class="line">    assert(<span class="keyword">false</span>);</div>
<div class="line">}, [](std::string err_val) {</div>
<div class="line">    assert(err_val == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line">}));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1656bb14f0a45ec7cfa81bb960acf924" name="a1656bb14f0a45ec7cfa81bb960acf924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1656bb14f0a45ec7cfa81bb960acf924">&#9670;&#160;</a></span>visit_informed() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit_informed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes a visitor with the contained value and meta data. </p>
<p>This function treats a <a class="el" href="classsumty_1_1result.html">result</a> as if it was a <a class="el" href="classsumty_1_1variant.html">variant</a> of <code>T</code> and <code>E</code> (i.e. <code>variant&lt;T, E&gt;</code>). If the <a class="el" href="classsumty_1_1result.html">result</a> contians an ok value, that value is passed to the visitor. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, the error is passed to the visitor. When either <code>T</code> or <code>E</code> are <code>void</code>, an instance of <a class="el" href="structsumty_1_1void__t.html">void_t</a> is passed instead.</p>
<p>Unlike <a class="el" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>, this function also passes an extra meta data value when invoking the visitor. This meta data object provides <code>constexpr</code> information about the type and index of the value being visited. The ok value has index 0 and the error value has index 1. This object has the the API shown below.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>alternative_info {</div>
<div class="line">    <span class="comment">// index of the alternative (ok == 0, error == 1)</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> index = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// type of the alternative (ok == T, error == E)</span></div>
<div class="line">    <span class="keyword">using </span>type = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// helper function for forwarding non-const alternative values</span></div>
<div class="line">    <span class="comment">// without needing to provide a template argument.</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) forward(...);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that the overload function can be helpful for defining a visitor inline.</p>
<h2><a class="anchor" id="autotoc_md417"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">res1.<a class="code hl_function" href="classsumty_1_1result.html#a1656bb14f0a45ec7cfa81bb960acf924">visit_informed</a>([](<span class="keyword">auto</span>&amp;&amp; <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>, <span class="keyword">auto</span> info) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 0) { <span class="comment">// ok</span></div>
<div class="line">        assert(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a> == 42);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 1) { <span class="comment">// error</span></div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">res2.<a class="code hl_function" href="classsumty_1_1result.html#a1656bb14f0a45ec7cfa81bb960acf924">visit_informed</a>([](<span class="keyword">auto</span>&amp;&amp; <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>, <span class="keyword">auto</span> info) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 0) { <span class="comment">// ok</span></div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 1) { <span class="comment">// error</span></div>
<div class="line">        assert(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a> == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="ttc" id="aclasssumty_1_1result_html_a1656bb14f0a45ec7cfa81bb960acf924"><div class="ttname"><a href="classsumty_1_1result.html#a1656bb14f0a45ec7cfa81bb960acf924">sumty::result::visit_informed</a></div><div class="ttdeci">constexpr DEDUCED visit_informed(V &amp;&amp;visitor) &amp;</div><div class="ttdoc">Invokes a visitor with the contained value and meta data.</div><div class="ttdef"><b>Definition</b> result.hpp:4848</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2b181b22d126a38b86f5a93035b6b7bc" name="a2b181b22d126a38b86f5a93035b6b7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b181b22d126a38b86f5a93035b6b7bc">&#9670;&#160;</a></span>visit_informed() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit_informed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes a visitor with the contained value and meta data. </p>
<p>This function treats a <a class="el" href="classsumty_1_1result.html">result</a> as if it was a <a class="el" href="classsumty_1_1variant.html">variant</a> of <code>T</code> and <code>E</code> (i.e. <code>variant&lt;T, E&gt;</code>). If the <a class="el" href="classsumty_1_1result.html">result</a> contians an ok value, that value is passed to the visitor. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, the error is passed to the visitor. When either <code>T</code> or <code>E</code> are <code>void</code>, an instance of <a class="el" href="structsumty_1_1void__t.html">void_t</a> is passed instead.</p>
<p>Unlike <a class="el" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>, this function also passes an extra meta data value when invoking the visitor. This meta data object provides <code>constexpr</code> information about the type and index of the value being visited. The ok value has index 0 and the error value has index 1. This object has the the API shown below.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>alternative_info {</div>
<div class="line">    <span class="comment">// index of the alternative (ok == 0, error == 1)</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> index = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// type of the alternative (ok == T, error == E)</span></div>
<div class="line">    <span class="keyword">using </span>type = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// helper function for forwarding non-const alternative values</span></div>
<div class="line">    <span class="comment">// without needing to provide a template argument.</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) forward(...);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that the overload function can be helpful for defining a visitor inline.</p>
<h2><a class="anchor" id="autotoc_md419"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">std::move(res1).<a class="code hl_function" href="classsumty_1_1result.html#a1656bb14f0a45ec7cfa81bb960acf924">visit_informed</a>([](<span class="keyword">auto</span>&amp;&amp; <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>, <span class="keyword">auto</span> info) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 0) { <span class="comment">// ok</span></div>
<div class="line">        assert(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a> == 42);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 1) { <span class="comment">// error</span></div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">std::move(res2).<a class="code hl_function" href="classsumty_1_1result.html#a1656bb14f0a45ec7cfa81bb960acf924">visit_informed</a>([](<span class="keyword">auto</span>&amp;&amp; <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>, <span class="keyword">auto</span> info) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 0) { <span class="comment">// ok</span></div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 1) { <span class="comment">// error</span></div>
<div class="line">        assert(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a> == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aebb3a178a071dfb5bdecb8607d446a4b" name="aebb3a178a071dfb5bdecb8607d446a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb3a178a071dfb5bdecb8607d446a4b">&#9670;&#160;</a></span>visit_informed() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit_informed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes a visitor with the contained value and meta data. </p>
<p>This function treats a <a class="el" href="classsumty_1_1result.html">result</a> as if it was a <a class="el" href="classsumty_1_1variant.html">variant</a> of <code>T</code> and <code>E</code> (i.e. <code>variant&lt;T, E&gt;</code>). If the <a class="el" href="classsumty_1_1result.html">result</a> contians an ok value, that value is passed to the visitor. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, the error is passed to the visitor. When either <code>T</code> or <code>E</code> are <code>void</code>, an instance of <a class="el" href="structsumty_1_1void__t.html">void_t</a> is passed instead.</p>
<p>Unlike <a class="el" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>, this function also passes an extra meta data value when invoking the visitor. This meta data object provides <code>constexpr</code> information about the type and index of the value being visited. The ok value has index 0 and the error value has index 1. This object has the the API shown below.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>alternative_info {</div>
<div class="line">    <span class="comment">// index of the alternative (ok == 0, error == 1)</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> index = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// type of the alternative (ok == T, error == E)</span></div>
<div class="line">    <span class="keyword">using </span>type = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// helper function for forwarding non-const alternative values</span></div>
<div class="line">    <span class="comment">// without needing to provide a template argument.</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) forward(...);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that the overload function can be helpful for defining a visitor inline.</p>
<h2><a class="anchor" id="autotoc_md418"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">res1.<a class="code hl_function" href="classsumty_1_1result.html#a1656bb14f0a45ec7cfa81bb960acf924">visit_informed</a>([](<span class="keyword">auto</span>&amp;&amp; <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>, <span class="keyword">auto</span> info) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 0) { <span class="comment">// ok</span></div>
<div class="line">        assert(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a> == 42);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 1) { <span class="comment">// error</span></div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">res2.<a class="code hl_function" href="classsumty_1_1result.html#a1656bb14f0a45ec7cfa81bb960acf924">visit_informed</a>([](<span class="keyword">auto</span>&amp;&amp; <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>, <span class="keyword">auto</span> info) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 0) { <span class="comment">// ok</span></div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 1) { <span class="comment">// error</span></div>
<div class="line">        assert(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a> == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --> 
</div>
</div>
<a id="affdb84ccc3402ad25040ee85cbffb9a3" name="affdb84ccc3402ad25040ee85cbffb9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdb84ccc3402ad25040ee85cbffb9a3">&#9670;&#160;</a></span>visit_informed() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit_informed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes a visitor with the contained value and meta data. </p>
<p>This function treats a <a class="el" href="classsumty_1_1result.html">result</a> as if it was a <a class="el" href="classsumty_1_1variant.html">variant</a> of <code>T</code> and <code>E</code> (i.e. <code>variant&lt;T, E&gt;</code>). If the <a class="el" href="classsumty_1_1result.html">result</a> contians an ok value, that value is passed to the visitor. If the <a class="el" href="classsumty_1_1result.html">result</a> contains an error, the error is passed to the visitor. When either <code>T</code> or <code>E</code> are <code>void</code>, an instance of <a class="el" href="structsumty_1_1void__t.html">void_t</a> is passed instead.</p>
<p>Unlike <a class="el" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>, this function also passes an extra meta data value when invoking the visitor. This meta data object provides <code>constexpr</code> information about the type and index of the value being visited. The ok value has index 0 and the error value has index 1. This object has the the API shown below.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>alternative_info {</div>
<div class="line">    <span class="comment">// index of the alternative (ok == 0, error == 1)</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> index = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// type of the alternative (ok == T, error == E)</span></div>
<div class="line">    <span class="keyword">using </span>type = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// helper function for forwarding non-const alternative values</span></div>
<div class="line">    <span class="comment">// without needing to provide a template argument.</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) forward(...);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that the overload function can be helpful for defining a visitor inline.</p>
<h2><a class="anchor" id="autotoc_md420"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">std::move(res1).<a class="code hl_function" href="classsumty_1_1result.html#a1656bb14f0a45ec7cfa81bb960acf924">visit_informed</a>([](<span class="keyword">auto</span>&amp;&amp; <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>, <span class="keyword">auto</span> info) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 0) { <span class="comment">// ok</span></div>
<div class="line">        assert(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a> == 42);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 1) { <span class="comment">// error</span></div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">std::move(res2).<a class="code hl_function" href="classsumty_1_1result.html#a1656bb14f0a45ec7cfa81bb960acf924">visit_informed</a>([](<span class="keyword">auto</span>&amp;&amp; <a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a>, <span class="keyword">auto</span> info) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 0) { <span class="comment">// ok</span></div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 1) { <span class="comment">// error</span></div>
<div class="line">        assert(<a class="code hl_function" href="classsumty_1_1result.html#a0fe474d55f5039d5c97b6b8dd5a25a66">value</a> == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a63b420afaed24b901f34bae122a9b9c1" name="a63b420afaed24b901f34bae122a9b9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b420afaed24b901f34bae122a9b9c1">&#9670;&#160;</a></span>get() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> IDX, <a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classsumty_1_1result.html">result</a> value by index, as if it were a <a class="el" href="classsumty_1_1variant.html">variant</a>. </p>
<p>This function is provided to make <a class="el" href="classsumty_1_1result.html">result</a> generically compatible with <a class="el" href="classsumty_1_1variant.html">variant</a>. This function treats <code>result&lt;T, E&gt;</code> as if it were <code>variant&lt;T, E&gt;</code>, where index 0 is <code>T</code> and index 1 is <code>E</code>.</p>
<h2><a class="anchor" id="autotoc_md272"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">assert(get&lt;0&gt;(std::move(res1)) == 42);</div>
<div class="line">assert(get&lt;1&gt;(std::move(res2)) == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IDX</td><td>The "alternative" index</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The <a class="el" href="classsumty_1_1result.html">result</a> to access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const rvalue of the accessed "alternative"</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__result__access.html">bad_result_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1result.html">result</a> does not contain the matching index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63b420afaed24b901f34bae122a9b9c1" name="a63b420afaed24b901f34bae122a9b9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b420afaed24b901f34bae122a9b9c1">&#9670;&#160;</a></span>get() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , <a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classsumty_1_1result.html">result</a> value by type, as if it were a <a class="el" href="classsumty_1_1variant.html">variant</a>. </p>
<p>This fucntion is provided to make <a class="el" href="classsumty_1_1result.html">result</a> generically compatible with <a class="el" href="classsumty_1_1variant.html">variant</a>. This function treats <code>result&lt;T, E&gt;</code> as if it were <code>variant&lt;T, E&gt;</code>.</p>
<p>This function only participates in overload resolution if <code>T</code> and <code>E</code> are distinct types, in order to avoid ambiguity.</p>
<h2><a class="anchor" id="autotoc_md276"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">assert(get&lt;int&gt;(std::move(res1)) == 42);</div>
<div class="line">assert(get&lt;std::string&gt;(std::move(res2)) == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The "alternative" type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The <a class="el" href="classsumty_1_1result.html">result</a> to access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const rvalue of the accessed "alternative"</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__result__access.html">bad_result_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1result.html">result</a> does not contain the matching index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac52da98d92f832ae5c248824107af2f3" name="ac52da98d92f832ae5c248824107af2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52da98d92f832ae5c248824107af2f3">&#9670;&#160;</a></span>get() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> IDX, <a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classsumty_1_1result.html">result</a> value by index, as if it were a <a class="el" href="classsumty_1_1variant.html">variant</a>. </p>
<p>This function is provided to make <a class="el" href="classsumty_1_1result.html">result</a> generically compatible with <a class="el" href="classsumty_1_1variant.html">variant</a>. This function treats <code>result&lt;T, E&gt;</code> as if it were <code>variant&lt;T, E&gt;</code>, where index 0 is <code>T</code> and index 1 is <code>E</code>.</p>
<h2><a class="anchor" id="autotoc_md270"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">assert(get&lt;0&gt;(res1) == 42);</div>
<div class="line">assert(get&lt;1&gt;(res2) == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IDX</td><td>The "alternative" index</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The <a class="el" href="classsumty_1_1result.html">result</a> to access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the accessed "alternative"</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__result__access.html">bad_result_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1result.html">result</a> does not contain the matching index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac52da98d92f832ae5c248824107af2f3" name="ac52da98d92f832ae5c248824107af2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52da98d92f832ae5c248824107af2f3">&#9670;&#160;</a></span>get() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , <a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classsumty_1_1result.html">result</a> value by type, as if it were a <a class="el" href="classsumty_1_1variant.html">variant</a>. </p>
<p>This fucntion is provided to make <a class="el" href="classsumty_1_1result.html">result</a> generically compatible with <a class="el" href="classsumty_1_1variant.html">variant</a>. This function treats <code>result&lt;T, E&gt;</code> as if it were <code>variant&lt;T, E&gt;</code>.</p>
<p>This function only participates in overload resolution if <code>T</code> and <code>E</code> are distinct types, in order to avoid ambiguity.</p>
<h2><a class="anchor" id="autotoc_md274"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">assert(get&lt;int&gt;(res1) == 42);</div>
<div class="line">assert(get&lt;std::string&gt;(res2) == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The "alternative" type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The <a class="el" href="classsumty_1_1result.html">result</a> to access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the accessed "alternative"</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__result__access.html">bad_result_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1result.html">result</a> does not contain the matching index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa474b568525391fad783e31ca80d7afe" name="aa474b568525391fad783e31ca80d7afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa474b568525391fad783e31ca80d7afe">&#9670;&#160;</a></span>get() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> IDX, <a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classsumty_1_1result.html">result</a> value by index, as if it were a <a class="el" href="classsumty_1_1variant.html">variant</a>. </p>
<p>This function is provided to make <a class="el" href="classsumty_1_1result.html">result</a> generically compatible with <a class="el" href="classsumty_1_1variant.html">variant</a>. This function treats <code>result&lt;T, E&gt;</code> as if it were <code>variant&lt;T, E&gt;</code>, where index 0 is <code>T</code> and index 1 is <code>E</code>.</p>
<h2><a class="anchor" id="autotoc_md271"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">assert(get&lt;0&gt;(std::move(res1)) == 42);</div>
<div class="line">assert(get&lt;1&gt;(std::move(res2)) == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IDX</td><td>The "alternative" index</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The <a class="el" href="classsumty_1_1result.html">result</a> to access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An rvalue of the accessed "alternative"</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__result__access.html">bad_result_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1result.html">result</a> does not contain the matching index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa474b568525391fad783e31ca80d7afe" name="aa474b568525391fad783e31ca80d7afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa474b568525391fad783e31ca80d7afe">&#9670;&#160;</a></span>get() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , <a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classsumty_1_1result.html">result</a> value by type, as if it were a <a class="el" href="classsumty_1_1variant.html">variant</a>. </p>
<p>This fucntion is provided to make <a class="el" href="classsumty_1_1result.html">result</a> generically compatible with <a class="el" href="classsumty_1_1variant.html">variant</a>. This function treats <code>result&lt;T, E&gt;</code> as if it were <code>variant&lt;T, E&gt;</code>.</p>
<p>This function only participates in overload resolution if <code>T</code> and <code>E</code> are distinct types, in order to avoid ambiguity.</p>
<h2><a class="anchor" id="autotoc_md275"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">assert(get&lt;int&gt;(std::move(res1)) == 42);</div>
<div class="line">assert(get&lt;std::string&gt;(std::move(res2)) == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The "alternative" type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The <a class="el" href="classsumty_1_1result.html">result</a> to access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An rvalue of the accessed "alternative"</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__result__access.html">bad_result_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1result.html">result</a> does not contain the matching index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bdfc23d3431292af06fb30707025eef" name="a3bdfc23d3431292af06fb30707025eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bdfc23d3431292af06fb30707025eef">&#9670;&#160;</a></span>get() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> IDX, <a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classsumty_1_1result.html">result</a> value by index, as if it were a <a class="el" href="classsumty_1_1variant.html">variant</a>. </p>
<p>This function is provided to make <a class="el" href="classsumty_1_1result.html">result</a> generically compatible with <a class="el" href="classsumty_1_1variant.html">variant</a>. This function treats <code>result&lt;T, E&gt;</code> as if it were <code>variant&lt;T, E&gt;</code>, where index 0 is <code>T</code> and index 1 is <code>E</code>.</p>
<h2><a class="anchor" id="autotoc_md269"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">assert(get&lt;0&gt;(res1) == 42);</div>
<div class="line">assert(get&lt;1&gt;(res2) == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IDX</td><td>The "alternative" index</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The <a class="el" href="classsumty_1_1result.html">result</a> to access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed "alternative"</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__result__access.html">bad_result_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1result.html">result</a> does not contain the matching index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bdfc23d3431292af06fb30707025eef" name="a3bdfc23d3431292af06fb30707025eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bdfc23d3431292af06fb30707025eef">&#9670;&#160;</a></span>get() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , <a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classsumty_1_1result.html">result</a> value by type, as if it were a <a class="el" href="classsumty_1_1variant.html">variant</a>. </p>
<p>This fucntion is provided to make <a class="el" href="classsumty_1_1result.html">result</a> generically compatible with <a class="el" href="classsumty_1_1variant.html">variant</a>. This function treats <code>result&lt;T, E&gt;</code> as if it were <code>variant&lt;T, E&gt;</code>.</p>
<p>This function only participates in overload resolution if <code>T</code> and <code>E</code> are distinct types, in order to avoid ambiguity.</p>
<h2><a class="anchor" id="autotoc_md273"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">assert(get&lt;int&gt;(res1) == 42);</div>
<div class="line">assert(get&lt;std::string&gt;(res2) == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The "alternative" type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The <a class="el" href="classsumty_1_1result.html">result</a> to access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed "alternative"</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__result__access.html">bad_result_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1result.html">result</a> does not contain the matching index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa078c1d74cb5a27e6d6153d17e3a372e" name="aa078c1d74cb5a27e6d6153d17e3a372e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa078c1d74cb5a27e6d6153d17e3a372e">&#9670;&#160;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a> operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1error__t.html">error_t</a>&lt; <a class="el" href="classsumty_1_1result.html">V</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="classsumty_1_1result.html">result</a> with an error value for equality. </p>
<p>This function returns true if the <a class="el" href="classsumty_1_1result.html">result</a> contains an errro value and the contained error value compares equal with the other error value.</p>
<h2><a class="anchor" id="autotoc_md281"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">assert(error&lt;const char*&gt;(<span class="stringliteral">&quot;oh no&quot;</span>) != res1);</div>
<div class="line">assert(error&lt;const char*&gt;(<span class="stringliteral">&quot;oh no&quot;</span>) == res2);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8fed478f3c0f41a129a746726344d911" name="a8fed478f3c0f41a129a746726344d911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fed478f3c0f41a129a746726344d911">&#9670;&#160;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a> operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1error__t.html">error_t</a>&lt; <a class="el" href="classsumty_1_1result.html">V</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="classsumty_1_1result.html">result</a> with an error value for equality. </p>
<p>This function returns true if the <a class="el" href="classsumty_1_1result.html">result</a> contains an errro value and the contained error value compares equal with the other error value.</p>
<h2><a class="anchor" id="autotoc_md280"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">assert(res1 != error&lt;const char*&gt;(<span class="stringliteral">&quot;oh no&quot;</span>));</div>
<div class="line">assert(res2 == error&lt;const char*&gt;(<span class="stringliteral">&quot;oh no&quot;</span>));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a25758407021987e62273a23cf19772ed" name="a25758407021987e62273a23cf19772ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25758407021987e62273a23cf19772ed">&#9670;&#160;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a> operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a>, <a class="el" href="classsumty_1_1result.html">V</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classsumty_1_1result.html">result</a> instances for equality. </p>
<p>Returns true if both <a class="el" href="classsumty_1_1result.html">result</a> instances either both contain ok values or both contain error values, and the values compare equal.</p>
<h2><a class="anchor" id="autotoc_md277"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;unsigned int, const char*&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{42};</div>
<div class="line"> </div>
<div class="line">assert(res1 == res2);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa2d8538929c7284c15bdb049d28ca7dd" name="aa2d8538929c7284c15bdb049d28ca7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d8538929c7284c15bdb049d28ca7dd">&#9670;&#160;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a> operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">U</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="classsumty_1_1result.html">result</a> with a plain value for equality. </p>
<p>This function return true if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value and the ok value compares equal with the plain value.</p>
<h2><a class="anchor" id="autotoc_md278"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">assert(res1 == 42);</div>
<div class="line">assert(res2 != 42);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6e6627edf63b5a5377eb699a75288afc" name="a6e6627edf63b5a5377eb699a75288afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6627edf63b5a5377eb699a75288afc">&#9670;&#160;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a> operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">U</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="classsumty_1_1result.html">result</a> with a plain value for equality. </p>
<p>This function return true if the <a class="el" href="classsumty_1_1result.html">result</a> contains an ok value and the ok value compares equal with the plain value.</p>
<h2><a class="anchor" id="autotoc_md279"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line">assert(42 == res1);</div>
<div class="line">assert(42 != res2);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8534d4fb80e4c99b43950f8d4954606c" name="a8534d4fb80e4c99b43950f8d4954606c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8534d4fb80e4c99b43950f8d4954606c">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">E</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">void</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">result</a>&lt; T, <a class="el" href="classsumty_1_1result.html">E</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two <a class="el" href="classsumty_1_1result.html">result</a> instances. </p>
<p>If both <a class="el" href="classsumty_1_1result.html">result</a> instances contain an ok value or both contain an error value, the values are swapped directly. If the two <a class="el" href="classsumty_1_1result.html">result</a> instances do not contain the same kind of value, the values are moved out of the results temporarily, the old values are destroyed, and new values a move constructed in to the opposite <a class="el" href="classsumty_1_1result.html">result</a>.</p>
<h2><a class="anchor" id="autotoc_md282"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res1</a>{42};</div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">result&lt;int, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">res2</a>{in_place_error, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="classsumty_1_1result.html#a9a3be55eeb914e44478166807b43eef9">swap</a>(res1, res2);</div>
<div class="line"> </div>
<div class="line">assert(res1.is_error());</div>
<div class="line">assert(res1.error() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line">assert(res2.is_ok());</div>
<div class="line">assert(*res2 == 42);</div>
</div><!-- fragment --> 
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sumty/detail/<a class="el" href="fwd_8hpp_source.html">fwd.hpp</a></li>
<li>sumty/<a class="el" href="result_8hpp_source.html">result.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>sumty</b></li><li class="navelem"><a class="el" href="classsumty_1_1result.html">result</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
