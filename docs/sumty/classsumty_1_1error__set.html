<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sumty: error_set&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">sumty<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Better sum types for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classsumty_1_1error__set.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classsumty_1_1error__set-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">error_set&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A discriminated union of unique error types.  
 <a href="classsumty_1_1error__set.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="error__set_8hpp_source.html">sumty/error_set.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:addff7a842486786bb2d73f5c7920f051" id="r_addff7a842486786bb2d73f5c7920f051"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#addff7a842486786bb2d73f5c7920f051">error_set</a> () CONDITIONALLY_NOEXCEPT</td></tr>
<tr class="memdesc:addff7a842486786bb2d73f5c7920f051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:addff7a842486786bb2d73f5c7920f051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ab1726f393d524bca46bf28c10761b" id="r_a90ab1726f393d524bca46bf28c10761b"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a90ab1726f393d524bca46bf28c10761b">error_set</a> (const <a class="el" href="classsumty_1_1error__set.html">error_set</a> &amp;) CONDITIONALLY_NOEXCEPT</td></tr>
<tr class="memdesc:a90ab1726f393d524bca46bf28c10761b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a90ab1726f393d524bca46bf28c10761b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d9a51f6dbdd64b09cf6dd4720bf39e" id="r_a04d9a51f6dbdd64b09cf6dd4720bf39e"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a04d9a51f6dbdd64b09cf6dd4720bf39e">error_set</a> (<a class="el" href="classsumty_1_1error__set.html">error_set</a> &amp;&amp;) CONDITIONALLY_NOEXCEPT</td></tr>
<tr class="memdesc:a04d9a51f6dbdd64b09cf6dd4720bf39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:a04d9a51f6dbdd64b09cf6dd4720bf39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35063d5af416dedee7c7c00e8cb19b80" id="r_a35063d5af416dedee7c7c00e8cb19b80"><td class="memTemplParams" colspan="2">template&lt;size_t IDX, typename... Args&gt; </td></tr>
<tr class="memitem:a35063d5af416dedee7c7c00e8cb19b80"><td class="memTemplItemLeft" align="right" valign="top">CONDITIONALLY_EXPLICIT constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a35063d5af416dedee7c7c00e8cb19b80">error_set</a> (std::in_place_index_t&lt; IDX &gt; inplace, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a35063d5af416dedee7c7c00e8cb19b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index emplacement constructor.  <br /></td></tr>
<tr class="separator:a35063d5af416dedee7c7c00e8cb19b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84cbee9be08c0da054b1558ce2991e04" id="r_a84cbee9be08c0da054b1558ce2991e04"><td class="memTemplParams" colspan="2">template&lt;size_t IDX, typename U , typename... Args&gt; </td></tr>
<tr class="memitem:a84cbee9be08c0da054b1558ce2991e04"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a84cbee9be08c0da054b1558ce2991e04">error_set</a> (std::in_place_index_t&lt; IDX &gt; inplace, std::initializer_list&lt; U &gt; init, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a84cbee9be08c0da054b1558ce2991e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index emplacement constructor with <code>std::initializer_list</code>  <br /></td></tr>
<tr class="separator:a84cbee9be08c0da054b1558ce2991e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cd6f9c493e233bd4328a21e33d7af3" id="r_a07cd6f9c493e233bd4328a21e33d7af3"><td class="memTemplParams" colspan="2">template&lt;typename U , typename... Args&gt; </td></tr>
<tr class="memitem:a07cd6f9c493e233bd4328a21e33d7af3"><td class="memTemplItemLeft" align="right" valign="top">CONDITIONALLY_EXPLICIT constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a07cd6f9c493e233bd4328a21e33d7af3">error_set</a> (std::in_place_type_t&lt; U &gt; inplace, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a07cd6f9c493e233bd4328a21e33d7af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type emplacement constructor.  <br /></td></tr>
<tr class="separator:a07cd6f9c493e233bd4328a21e33d7af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307869b77e40fa40b1f48537bb296625" id="r_a307869b77e40fa40b1f48537bb296625"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , typename... Args&gt; </td></tr>
<tr class="memitem:a307869b77e40fa40b1f48537bb296625"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a307869b77e40fa40b1f48537bb296625">error_set</a> (std::in_place_type_t&lt; U &gt; inplace, std::initializer_list&lt; V &gt; init, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a307869b77e40fa40b1f48537bb296625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type emplacement constructor with <code>std::initializer_list</code>  <br /></td></tr>
<tr class="separator:a307869b77e40fa40b1f48537bb296625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51ae4373d68b8a4b3b5ed161d346760" id="r_ae51ae4373d68b8a4b3b5ed161d346760"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ae51ae4373d68b8a4b3b5ed161d346760"><td class="memTemplItemLeft" align="right" valign="top">CONDITIONALLY_EXPLICIT constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#ae51ae4373d68b8a4b3b5ed161d346760">error_set</a> (U &amp;&amp;value)</td></tr>
<tr class="memdesc:ae51ae4373d68b8a4b3b5ed161d346760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwarding constructor.  <br /></td></tr>
<tr class="separator:ae51ae4373d68b8a4b3b5ed161d346760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2739845be27347e0a1f312d5c4f5a7" id="r_a2b2739845be27347e0a1f312d5c4f5a7"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a2b2739845be27347e0a1f312d5c4f5a7"><td class="memTemplItemLeft" align="right" valign="top">CONDITIONALLY_EXPLICIT constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a2b2739845be27347e0a1f312d5c4f5a7">error_set</a> (std::initializer_list&lt; U &gt; init)</td></tr>
<tr class="memdesc:a2b2739845be27347e0a1f312d5c4f5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwarding constructor with initializer list.  <br /></td></tr>
<tr class="separator:a2b2739845be27347e0a1f312d5c4f5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98f18f5edbaa0b530fd391fa4e7a285" id="r_ad98f18f5edbaa0b530fd391fa4e7a285"><td class="memTemplParams" colspan="2">template&lt;typename... U&gt; </td></tr>
<tr class="memitem:ad98f18f5edbaa0b530fd391fa4e7a285"><td class="memTemplItemLeft" align="right" valign="top">CONDITIONALLY_EXPLICIT constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#ad98f18f5edbaa0b530fd391fa4e7a285">error_set</a> (const <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;other)</td></tr>
<tr class="memdesc:ad98f18f5edbaa0b530fd391fa4e7a285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy conversion constructor.  <br /></td></tr>
<tr class="separator:ad98f18f5edbaa0b530fd391fa4e7a285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bf1fd41beb68334eb3ab9e9e48faad" id="r_a03bf1fd41beb68334eb3ab9e9e48faad"><td class="memTemplParams" colspan="2">template&lt;typename... U&gt; </td></tr>
<tr class="memitem:a03bf1fd41beb68334eb3ab9e9e48faad"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a03bf1fd41beb68334eb3ab9e9e48faad">error_set</a> (<a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a03bf1fd41beb68334eb3ab9e9e48faad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move conversion constructor.  <br /></td></tr>
<tr class="separator:a03bf1fd41beb68334eb3ab9e9e48faad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5171ad3dd15a5dfc8eda67896f1e1844" id="r_a5171ad3dd15a5dfc8eda67896f1e1844"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a5171ad3dd15a5dfc8eda67896f1e1844">~error_set</a> () CONDITIONALLY_NOEXCEPT</td></tr>
<tr class="memdesc:a5171ad3dd15a5dfc8eda67896f1e1844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a5171ad3dd15a5dfc8eda67896f1e1844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9914b7590e4cf82a5c595f93f7e0a4a9" id="r_a9914b7590e4cf82a5c595f93f7e0a4a9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsumty_1_1error__set.html">error_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a9914b7590e4cf82a5c595f93f7e0a4a9">operator=</a> (const <a class="el" href="classsumty_1_1error__set.html">error_set</a> &amp;) CONDITIONALLY_NOEXCEPT</td></tr>
<tr class="memdesc:a9914b7590e4cf82a5c595f93f7e0a4a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <br /></td></tr>
<tr class="separator:a9914b7590e4cf82a5c595f93f7e0a4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01c6c74db9db385eb66e13d5feea66f" id="r_af01c6c74db9db385eb66e13d5feea66f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classsumty_1_1error__set.html">error_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#af01c6c74db9db385eb66e13d5feea66f">operator=</a> (<a class="el" href="classsumty_1_1error__set.html">error_set</a> &amp;&amp;) CONDITIONALLY_NOEXCEPT</td></tr>
<tr class="memdesc:af01c6c74db9db385eb66e13d5feea66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <br /></td></tr>
<tr class="separator:af01c6c74db9db385eb66e13d5feea66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ee06fef43ce99cc62166cac7311159" id="r_ac4ee06fef43ce99cc62166cac7311159"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ac4ee06fef43ce99cc62166cac7311159"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsumty_1_1error__set.html">error_set</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#ac4ee06fef43ce99cc62166cac7311159">operator=</a> (U &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ac4ee06fef43ce99cc62166cac7311159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwarding assignment operator.  <br /></td></tr>
<tr class="separator:ac4ee06fef43ce99cc62166cac7311159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6047a0cca2d735ae4e7ef8922e6aa25" id="r_aa6047a0cca2d735ae4e7ef8922e6aa25"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aa6047a0cca2d735ae4e7ef8922e6aa25"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsumty_1_1error__set.html">error_set</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#aa6047a0cca2d735ae4e7ef8922e6aa25">operator=</a> (std::initializer_list&lt; U &gt; rhs)</td></tr>
<tr class="memdesc:aa6047a0cca2d735ae4e7ef8922e6aa25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwarding assignment operator with initializer list.  <br /></td></tr>
<tr class="separator:aa6047a0cca2d735ae4e7ef8922e6aa25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9ddc6a1c6269702b84cdeb0a255589" id="r_afd9ddc6a1c6269702b84cdeb0a255589"><td class="memTemplParams" colspan="2">template&lt;typename... U&gt; </td></tr>
<tr class="memitem:afd9ddc6a1c6269702b84cdeb0a255589"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsumty_1_1error__set.html">error_set</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#afd9ddc6a1c6269702b84cdeb0a255589">operator=</a> (const <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;rhs)</td></tr>
<tr class="memdesc:afd9ddc6a1c6269702b84cdeb0a255589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy conversion assignment operator.  <br /></td></tr>
<tr class="separator:afd9ddc6a1c6269702b84cdeb0a255589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaba45b9fee017793bf1d7d9c0cd41d6" id="r_aaaba45b9fee017793bf1d7d9c0cd41d6"><td class="memTemplParams" colspan="2">template&lt;typename... U&gt; </td></tr>
<tr class="memitem:aaaba45b9fee017793bf1d7d9c0cd41d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classsumty_1_1error__set.html">error_set</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#aaaba45b9fee017793bf1d7d9c0cd41d6">operator=</a> (<a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;&amp;rhs)</td></tr>
<tr class="memdesc:aaaba45b9fee017793bf1d7d9c0cd41d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move conversion assignment operator.  <br /></td></tr>
<tr class="separator:aaaba45b9fee017793bf1d7d9c0cd41d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16ab6b77ec8c07ce9c5e558de5cd82b" id="r_ae16ab6b77ec8c07ce9c5e558de5cd82b"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#ae16ab6b77ec8c07ce9c5e558de5cd82b">index</a> () const noexcept</td></tr>
<tr class="memdesc:ae16ab6b77ec8c07ce9c5e558de5cd82b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index of the contained alternative.  <br /></td></tr>
<tr class="separator:ae16ab6b77ec8c07ce9c5e558de5cd82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51aa9c79ed9d904626ad89616ee4990f" id="r_a51aa9c79ed9d904626ad89616ee4990f"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename... Args&gt; </td></tr>
<tr class="memitem:a51aa9c79ed9d904626ad89616ee4990f"><td class="memTemplItemLeft" align="right" valign="top">constexpr REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a51aa9c79ed9d904626ad89616ee4990f">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a51aa9c79ed9d904626ad89616ee4990f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new alternative in place by index.  <br /></td></tr>
<tr class="separator:a51aa9c79ed9d904626ad89616ee4990f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d75a701faaf7cda03a358a84acfe3ac" id="r_a4d75a701faaf7cda03a358a84acfe3ac"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename U , typename... Args&gt; </td></tr>
<tr class="memitem:a4d75a701faaf7cda03a358a84acfe3ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a4d75a701faaf7cda03a358a84acfe3ac">emplace</a> (std::initializer_list&lt; U &gt; ilist, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a4d75a701faaf7cda03a358a84acfe3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new alternative in place by index.  <br /></td></tr>
<tr class="separator:a4d75a701faaf7cda03a358a84acfe3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51aa9c79ed9d904626ad89616ee4990f" id="r_a51aa9c79ed9d904626ad89616ee4990f"><td class="memTemplParams" colspan="2">template&lt;typename U , typename... Args&gt; </td></tr>
<tr class="memitem:a51aa9c79ed9d904626ad89616ee4990f"><td class="memTemplItemLeft" align="right" valign="top">constexpr REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a51aa9c79ed9d904626ad89616ee4990f">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a51aa9c79ed9d904626ad89616ee4990f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new alternative in place by type.  <br /></td></tr>
<tr class="separator:a51aa9c79ed9d904626ad89616ee4990f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9de1c1c1f667f57155919abb7e79d6" id="r_abe9de1c1c1f667f57155919abb7e79d6"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , typename... Args&gt; </td></tr>
<tr class="memitem:abe9de1c1c1f667f57155919abb7e79d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#abe9de1c1c1f667f57155919abb7e79d6">emplace</a> (std::initializer_list&lt; V &gt; ilist, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:abe9de1c1c1f667f57155919abb7e79d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new alternative in place by type.  <br /></td></tr>
<tr class="separator:abe9de1c1c1f667f57155919abb7e79d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2d2b17eb46b78620e923b1b58a1899" id="r_aff2d2b17eb46b78620e923b1b58a1899"><td class="memTemplParams" colspan="2">template&lt;size_t I&gt; </td></tr>
<tr class="memitem:aff2d2b17eb46b78620e923b1b58a1899"><td class="memTemplItemLeft" align="right" valign="top">constexpr REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#aff2d2b17eb46b78620e923b1b58a1899">operator[]</a> (<a class="el" href="structsumty_1_1index__t.html">index_t</a>&lt; I &gt; <a class="el" href="classsumty_1_1error__set.html#ae16ab6b77ec8c07ce9c5e558de5cd82b">index</a>) &amp;noexcept</td></tr>
<tr class="memdesc:aff2d2b17eb46b78620e923b1b58a1899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative access operator by index.  <br /></td></tr>
<tr class="separator:aff2d2b17eb46b78620e923b1b58a1899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acc04a3c20910caf473d04e3df96dac" id="r_a4acc04a3c20910caf473d04e3df96dac"><td class="memTemplParams" colspan="2">template&lt;size_t I&gt; </td></tr>
<tr class="memitem:a4acc04a3c20910caf473d04e3df96dac"><td class="memTemplItemLeft" align="right" valign="top">constexpr CONST_REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a4acc04a3c20910caf473d04e3df96dac">operator[]</a> (<a class="el" href="structsumty_1_1index__t.html">index_t</a>&lt; I &gt; <a class="el" href="classsumty_1_1error__set.html#ae16ab6b77ec8c07ce9c5e558de5cd82b">index</a>) const &amp;noexcept</td></tr>
<tr class="memdesc:a4acc04a3c20910caf473d04e3df96dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative access operator by index.  <br /></td></tr>
<tr class="separator:a4acc04a3c20910caf473d04e3df96dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d78cf19fadfc52be6fc46b972746912" id="r_a7d78cf19fadfc52be6fc46b972746912"><td class="memTemplParams" colspan="2">template&lt;size_t I&gt; </td></tr>
<tr class="memitem:a7d78cf19fadfc52be6fc46b972746912"><td class="memTemplItemLeft" align="right" valign="top">constexpr RVALUE_REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a7d78cf19fadfc52be6fc46b972746912">operator[]</a> (<a class="el" href="structsumty_1_1index__t.html">index_t</a>&lt; I &gt; <a class="el" href="classsumty_1_1error__set.html#ae16ab6b77ec8c07ce9c5e558de5cd82b">index</a>) &amp;&amp;</td></tr>
<tr class="memdesc:a7d78cf19fadfc52be6fc46b972746912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative access operator by index.  <br /></td></tr>
<tr class="separator:a7d78cf19fadfc52be6fc46b972746912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015017e598c8340b3be3481a5ef7d1f8" id="r_a015017e598c8340b3be3481a5ef7d1f8"><td class="memTemplParams" colspan="2">template&lt;size_t I&gt; </td></tr>
<tr class="memitem:a015017e598c8340b3be3481a5ef7d1f8"><td class="memTemplItemLeft" align="right" valign="top">constexpr CONST_RVALUE_REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a015017e598c8340b3be3481a5ef7d1f8">operator[]</a> (<a class="el" href="structsumty_1_1index__t.html">index_t</a>&lt; I &gt; <a class="el" href="classsumty_1_1error__set.html#ae16ab6b77ec8c07ce9c5e558de5cd82b">index</a>) const &amp;&amp;</td></tr>
<tr class="memdesc:a015017e598c8340b3be3481a5ef7d1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative access operator by index.  <br /></td></tr>
<tr class="separator:a015017e598c8340b3be3481a5ef7d1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe93f72a909cf965adbf3fc1c3b73e6b" id="r_abe93f72a909cf965adbf3fc1c3b73e6b"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:abe93f72a909cf965adbf3fc1c3b73e6b"><td class="memTemplItemLeft" align="right" valign="top">constexpr REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#abe93f72a909cf965adbf3fc1c3b73e6b">operator[]</a> (<a class="el" href="structsumty_1_1type__t.html">type_t</a>&lt; U &gt; type) &amp;noexcept</td></tr>
<tr class="memdesc:abe93f72a909cf965adbf3fc1c3b73e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative access operator by type.  <br /></td></tr>
<tr class="separator:abe93f72a909cf965adbf3fc1c3b73e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7947e07a7b41fa6276746a4244a4923a" id="r_a7947e07a7b41fa6276746a4244a4923a"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a7947e07a7b41fa6276746a4244a4923a"><td class="memTemplItemLeft" align="right" valign="top">constexpr CONST_REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a7947e07a7b41fa6276746a4244a4923a">operator[]</a> (<a class="el" href="structsumty_1_1type__t.html">type_t</a>&lt; U &gt; type) const &amp;noexcept</td></tr>
<tr class="memdesc:a7947e07a7b41fa6276746a4244a4923a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative access operator by type.  <br /></td></tr>
<tr class="separator:a7947e07a7b41fa6276746a4244a4923a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ba2eeeab7db3966934aafe7db79735" id="r_a65ba2eeeab7db3966934aafe7db79735"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a65ba2eeeab7db3966934aafe7db79735"><td class="memTemplItemLeft" align="right" valign="top">constexpr RVALUE_REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a65ba2eeeab7db3966934aafe7db79735">operator[]</a> (<a class="el" href="structsumty_1_1type__t.html">type_t</a>&lt; U &gt; type) &amp;&amp;</td></tr>
<tr class="memdesc:a65ba2eeeab7db3966934aafe7db79735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative access operator by type.  <br /></td></tr>
<tr class="separator:a65ba2eeeab7db3966934aafe7db79735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9e8b0aad003da2ccef9e62f8133ad0" id="r_a5d9e8b0aad003da2ccef9e62f8133ad0"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a5d9e8b0aad003da2ccef9e62f8133ad0"><td class="memTemplItemLeft" align="right" valign="top">constexpr CONST_RVALUE_REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a5d9e8b0aad003da2ccef9e62f8133ad0">operator[]</a> (<a class="el" href="structsumty_1_1type__t.html">type_t</a>&lt; U &gt; type) const &amp;&amp;</td></tr>
<tr class="memdesc:a5d9e8b0aad003da2ccef9e62f8133ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative access operator by type.  <br /></td></tr>
<tr class="separator:a5d9e8b0aad003da2ccef9e62f8133ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb0f2e97a687affd34d9ece8c9c59bc" id="r_a5bb0f2e97a687affd34d9ece8c9c59bc"><td class="memTemplParams" colspan="2">template&lt;size_t I&gt; </td></tr>
<tr class="memitem:a5bb0f2e97a687affd34d9ece8c9c59bc"><td class="memTemplItemLeft" align="right" valign="top">constexpr REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a5bb0f2e97a687affd34d9ece8c9c59bc">get</a> () &amp;</td></tr>
<tr class="memdesc:a5bb0f2e97a687affd34d9ece8c9c59bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by index.  <br /></td></tr>
<tr class="separator:a5bb0f2e97a687affd34d9ece8c9c59bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cce71efb47892db3403e54fef6072e" id="r_a25cce71efb47892db3403e54fef6072e"><td class="memTemplParams" colspan="2">template&lt;size_t I&gt; </td></tr>
<tr class="memitem:a25cce71efb47892db3403e54fef6072e"><td class="memTemplItemLeft" align="right" valign="top">constexpr CONST_REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a25cce71efb47892db3403e54fef6072e">get</a> () const &amp;</td></tr>
<tr class="memdesc:a25cce71efb47892db3403e54fef6072e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by index.  <br /></td></tr>
<tr class="separator:a25cce71efb47892db3403e54fef6072e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e0f8f4c60cc6726ce6571168835d89" id="r_a66e0f8f4c60cc6726ce6571168835d89"><td class="memTemplParams" colspan="2">template&lt;size_t I&gt; </td></tr>
<tr class="memitem:a66e0f8f4c60cc6726ce6571168835d89"><td class="memTemplItemLeft" align="right" valign="top">constexpr RVALUE_REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a66e0f8f4c60cc6726ce6571168835d89">get</a> () &amp;&amp;</td></tr>
<tr class="memdesc:a66e0f8f4c60cc6726ce6571168835d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by index.  <br /></td></tr>
<tr class="separator:a66e0f8f4c60cc6726ce6571168835d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcc32bc6f1d424bb8041401437cd401" id="r_acfcc32bc6f1d424bb8041401437cd401"><td class="memTemplParams" colspan="2">template&lt;size_t I&gt; </td></tr>
<tr class="memitem:acfcc32bc6f1d424bb8041401437cd401"><td class="memTemplItemLeft" align="right" valign="top">constexpr CONST_RVALUE_REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#acfcc32bc6f1d424bb8041401437cd401">get</a> () const &amp;&amp;</td></tr>
<tr class="memdesc:acfcc32bc6f1d424bb8041401437cd401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by index.  <br /></td></tr>
<tr class="separator:acfcc32bc6f1d424bb8041401437cd401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb0f2e97a687affd34d9ece8c9c59bc" id="r_a5bb0f2e97a687affd34d9ece8c9c59bc"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a5bb0f2e97a687affd34d9ece8c9c59bc"><td class="memTemplItemLeft" align="right" valign="top">constexpr REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a5bb0f2e97a687affd34d9ece8c9c59bc">get</a> () &amp;</td></tr>
<tr class="memdesc:a5bb0f2e97a687affd34d9ece8c9c59bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by type.  <br /></td></tr>
<tr class="separator:a5bb0f2e97a687affd34d9ece8c9c59bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cce71efb47892db3403e54fef6072e" id="r_a25cce71efb47892db3403e54fef6072e"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a25cce71efb47892db3403e54fef6072e"><td class="memTemplItemLeft" align="right" valign="top">constexpr CONST_REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a25cce71efb47892db3403e54fef6072e">get</a> () const &amp;</td></tr>
<tr class="memdesc:a25cce71efb47892db3403e54fef6072e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by type.  <br /></td></tr>
<tr class="separator:a25cce71efb47892db3403e54fef6072e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e0f8f4c60cc6726ce6571168835d89" id="r_a66e0f8f4c60cc6726ce6571168835d89"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a66e0f8f4c60cc6726ce6571168835d89"><td class="memTemplItemLeft" align="right" valign="top">constexpr RVALUE_REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a66e0f8f4c60cc6726ce6571168835d89">get</a> () &amp;&amp;</td></tr>
<tr class="memdesc:a66e0f8f4c60cc6726ce6571168835d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by type.  <br /></td></tr>
<tr class="separator:a66e0f8f4c60cc6726ce6571168835d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcc32bc6f1d424bb8041401437cd401" id="r_acfcc32bc6f1d424bb8041401437cd401"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:acfcc32bc6f1d424bb8041401437cd401"><td class="memTemplItemLeft" align="right" valign="top">constexpr CONST_RVALUE_REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#acfcc32bc6f1d424bb8041401437cd401">get</a> () const &amp;&amp;</td></tr>
<tr class="memdesc:acfcc32bc6f1d424bb8041401437cd401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by type.  <br /></td></tr>
<tr class="separator:acfcc32bc6f1d424bb8041401437cd401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b10b57fcb769be2c692a4b6df452ab" id="r_a58b10b57fcb769be2c692a4b6df452ab"><td class="memTemplParams" colspan="2">template&lt;size_t I&gt; </td></tr>
<tr class="memitem:a58b10b57fcb769be2c692a4b6df452ab"><td class="memTemplItemLeft" align="right" valign="top">constexpr POINTER&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a58b10b57fcb769be2c692a4b6df452ab">get_if</a> () noexcept</td></tr>
<tr class="memdesc:a58b10b57fcb769be2c692a4b6df452ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative pointer by index if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> holds it.  <br /></td></tr>
<tr class="separator:a58b10b57fcb769be2c692a4b6df452ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265bae72c738f8886a40d3fcb358e70d" id="r_a265bae72c738f8886a40d3fcb358e70d"><td class="memTemplParams" colspan="2">template&lt;size_t I&gt; </td></tr>
<tr class="memitem:a265bae72c738f8886a40d3fcb358e70d"><td class="memTemplItemLeft" align="right" valign="top">constexpr CONST_POINTER&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a265bae72c738f8886a40d3fcb358e70d">get_if</a> () const noexcept</td></tr>
<tr class="memdesc:a265bae72c738f8886a40d3fcb358e70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative pointer by index if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> holds it.  <br /></td></tr>
<tr class="separator:a265bae72c738f8886a40d3fcb358e70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b10b57fcb769be2c692a4b6df452ab" id="r_a58b10b57fcb769be2c692a4b6df452ab"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a58b10b57fcb769be2c692a4b6df452ab"><td class="memTemplItemLeft" align="right" valign="top">constexpr POINTER&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a58b10b57fcb769be2c692a4b6df452ab">get_if</a> () noexcept</td></tr>
<tr class="memdesc:a58b10b57fcb769be2c692a4b6df452ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative pointer by type if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> holds it.  <br /></td></tr>
<tr class="separator:a58b10b57fcb769be2c692a4b6df452ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265bae72c738f8886a40d3fcb358e70d" id="r_a265bae72c738f8886a40d3fcb358e70d"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a265bae72c738f8886a40d3fcb358e70d"><td class="memTemplItemLeft" align="right" valign="top">constexpr CONST_POINTER&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a265bae72c738f8886a40d3fcb358e70d">get_if</a> () const noexcept</td></tr>
<tr class="memdesc:a265bae72c738f8886a40d3fcb358e70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative pointer by type if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> holds it.  <br /></td></tr>
<tr class="separator:a265bae72c738f8886a40d3fcb358e70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4ebf4f8a4bb3bccd7566476219bfa3" id="r_a7d4ebf4f8a4bb3bccd7566476219bfa3"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a7d4ebf4f8a4bb3bccd7566476219bfa3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a7d4ebf4f8a4bb3bccd7566476219bfa3">holds_alternative</a> () const noexcept</td></tr>
<tr class="memdesc:a7d4ebf4f8a4bb3bccd7566476219bfa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an <a class="el" href="classsumty_1_1error__set.html">error_set</a> contains a particular alternative.  <br /></td></tr>
<tr class="separator:a7d4ebf4f8a4bb3bccd7566476219bfa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f575e3e78ea2171d1be475f7f9a2d8" id="r_ae2f575e3e78ea2171d1be475f7f9a2d8"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:ae2f575e3e78ea2171d1be475f7f9a2d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr DEDUCED&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a> (V &amp;&amp;visitor) &amp;</td></tr>
<tr class="memdesc:ae2f575e3e78ea2171d1be475f7f9a2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a visitor callable with the contained alternative.  <br /></td></tr>
<tr class="separator:ae2f575e3e78ea2171d1be475f7f9a2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeca86cd9abb551e0c1e52ba81289f29" id="r_aeeca86cd9abb551e0c1e52ba81289f29"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:aeeca86cd9abb551e0c1e52ba81289f29"><td class="memTemplItemLeft" align="right" valign="top">constexpr DEDUCED&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#aeeca86cd9abb551e0c1e52ba81289f29">visit</a> (V &amp;&amp;visitor) const &amp;</td></tr>
<tr class="memdesc:aeeca86cd9abb551e0c1e52ba81289f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a visitor callable with the contained alternative.  <br /></td></tr>
<tr class="separator:aeeca86cd9abb551e0c1e52ba81289f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaaf65bdef1581aff9bda2ed4174143d" id="r_adaaf65bdef1581aff9bda2ed4174143d"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:adaaf65bdef1581aff9bda2ed4174143d"><td class="memTemplItemLeft" align="right" valign="top">constexpr DEDUCED&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#adaaf65bdef1581aff9bda2ed4174143d">visit</a> (V &amp;&amp;visitor) &amp;&amp;</td></tr>
<tr class="memdesc:adaaf65bdef1581aff9bda2ed4174143d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a visitor callable with the contained alternative.  <br /></td></tr>
<tr class="separator:adaaf65bdef1581aff9bda2ed4174143d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b9d6a30c96d7caac920ce264c66de1" id="r_a12b9d6a30c96d7caac920ce264c66de1"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a12b9d6a30c96d7caac920ce264c66de1"><td class="memTemplItemLeft" align="right" valign="top">constexpr DEDUCED&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a12b9d6a30c96d7caac920ce264c66de1">visit</a> (V &amp;&amp;visitor) const &amp;&amp;</td></tr>
<tr class="memdesc:a12b9d6a30c96d7caac920ce264c66de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a visitor callable with the contained alternative.  <br /></td></tr>
<tr class="separator:a12b9d6a30c96d7caac920ce264c66de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1656bb14f0a45ec7cfa81bb960acf924" id="r_a1656bb14f0a45ec7cfa81bb960acf924"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a1656bb14f0a45ec7cfa81bb960acf924"><td class="memTemplItemLeft" align="right" valign="top">constexpr DEDUCED&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a1656bb14f0a45ec7cfa81bb960acf924">visit_informed</a> (V &amp;&amp;visitor) &amp;</td></tr>
<tr class="memdesc:a1656bb14f0a45ec7cfa81bb960acf924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a visitor callable with the contained alternative and metadata.  <br /></td></tr>
<tr class="separator:a1656bb14f0a45ec7cfa81bb960acf924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb3a178a071dfb5bdecb8607d446a4b" id="r_aebb3a178a071dfb5bdecb8607d446a4b"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:aebb3a178a071dfb5bdecb8607d446a4b"><td class="memTemplItemLeft" align="right" valign="top">constexpr DEDUCED&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#aebb3a178a071dfb5bdecb8607d446a4b">visit_informed</a> (V &amp;&amp;visitor) const &amp;</td></tr>
<tr class="memdesc:aebb3a178a071dfb5bdecb8607d446a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a visitor callable with the contained alternative and metadata.  <br /></td></tr>
<tr class="separator:aebb3a178a071dfb5bdecb8607d446a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b181b22d126a38b86f5a93035b6b7bc" id="r_a2b181b22d126a38b86f5a93035b6b7bc"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a2b181b22d126a38b86f5a93035b6b7bc"><td class="memTemplItemLeft" align="right" valign="top">constexpr DEDUCED&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a2b181b22d126a38b86f5a93035b6b7bc">visit_informed</a> (V &amp;&amp;visitor) &amp;&amp;</td></tr>
<tr class="memdesc:a2b181b22d126a38b86f5a93035b6b7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a visitor callable with the contained alternative and metadata.  <br /></td></tr>
<tr class="separator:a2b181b22d126a38b86f5a93035b6b7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdb84ccc3402ad25040ee85cbffb9a3" id="r_affdb84ccc3402ad25040ee85cbffb9a3"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:affdb84ccc3402ad25040ee85cbffb9a3"><td class="memTemplItemLeft" align="right" valign="top">constexpr DEDUCED&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#affdb84ccc3402ad25040ee85cbffb9a3">visit_informed</a> (V &amp;&amp;visitor) const &amp;&amp;</td></tr>
<tr class="memdesc:affdb84ccc3402ad25040ee85cbffb9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a visitor callable with the contained alternative and metadata.  <br /></td></tr>
<tr class="separator:affdb84ccc3402ad25040ee85cbffb9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86176821a53c55817f118bc82521733d" id="r_a86176821a53c55817f118bc82521733d"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a86176821a53c55817f118bc82521733d">swap</a> (<a class="el" href="classsumty_1_1error__set.html">error_set</a> &amp;other) CONDITIONALLY_NOEXCEPT</td></tr>
<tr class="memdesc:a86176821a53c55817f118bc82521733d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two <a class="el" href="classsumty_1_1error__set.html">error_set</a> instances.  <br /></td></tr>
<tr class="separator:a86176821a53c55817f118bc82521733d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:a99f72be423e16e77bf438c0a2bc6a283" id="r_a99f72be423e16e77bf438c0a2bc6a283"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... U&gt; </td></tr>
<tr class="memitem:a99f72be423e16e77bf438c0a2bc6a283"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a99f72be423e16e77bf438c0a2bc6a283">holds_alternative</a> (const <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;e) noexcept</td></tr>
<tr class="memdesc:a99f72be423e16e77bf438c0a2bc6a283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an <a class="el" href="classsumty_1_1error__set.html">error_set</a> contains a particular alternative.  <br /></td></tr>
<tr class="separator:a99f72be423e16e77bf438c0a2bc6a283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07957e37505cc11f10db7d8d17182966" id="r_a07957e37505cc11f10db7d8d17182966"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename... T&gt; </td></tr>
<tr class="memitem:a07957e37505cc11f10db7d8d17182966"><td class="memTemplItemLeft" align="right" valign="top">constexpr REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a07957e37505cc11f10db7d8d17182966">get</a> (<a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T... &gt; &amp;e)</td></tr>
<tr class="memdesc:a07957e37505cc11f10db7d8d17182966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by index.  <br /></td></tr>
<tr class="separator:a07957e37505cc11f10db7d8d17182966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310562571ad5c34d977c99ce7e81c1a7" id="r_a310562571ad5c34d977c99ce7e81c1a7"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename... T&gt; </td></tr>
<tr class="memitem:a310562571ad5c34d977c99ce7e81c1a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr CONST_REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a310562571ad5c34d977c99ce7e81c1a7">get</a> (const <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T... &gt; &amp;e)</td></tr>
<tr class="memdesc:a310562571ad5c34d977c99ce7e81c1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by index.  <br /></td></tr>
<tr class="separator:a310562571ad5c34d977c99ce7e81c1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd10c3ec3f70ea53aecf71378af08cb3" id="r_acd10c3ec3f70ea53aecf71378af08cb3"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename... T&gt; </td></tr>
<tr class="memitem:acd10c3ec3f70ea53aecf71378af08cb3"><td class="memTemplItemLeft" align="right" valign="top">constexpr RVALUE_REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#acd10c3ec3f70ea53aecf71378af08cb3">get</a> (<a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T... &gt; &amp;&amp;e)</td></tr>
<tr class="memdesc:acd10c3ec3f70ea53aecf71378af08cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by index.  <br /></td></tr>
<tr class="separator:acd10c3ec3f70ea53aecf71378af08cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad3c31781c3739c593b02b00ca2c08f" id="r_acad3c31781c3739c593b02b00ca2c08f"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename... T&gt; </td></tr>
<tr class="memitem:acad3c31781c3739c593b02b00ca2c08f"><td class="memTemplItemLeft" align="right" valign="top">constexpr CONST_RVALUE_REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#acad3c31781c3739c593b02b00ca2c08f">get</a> (const <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T... &gt; &amp;&amp;e)</td></tr>
<tr class="memdesc:acad3c31781c3739c593b02b00ca2c08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by index.  <br /></td></tr>
<tr class="separator:acad3c31781c3739c593b02b00ca2c08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf770183eb5df5394b3d9c8ee84122b" id="r_aaaf770183eb5df5394b3d9c8ee84122b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... U&gt; </td></tr>
<tr class="memitem:aaaf770183eb5df5394b3d9c8ee84122b"><td class="memTemplItemLeft" align="right" valign="top">constexpr REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#aaaf770183eb5df5394b3d9c8ee84122b">get</a> (<a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;e)</td></tr>
<tr class="memdesc:aaaf770183eb5df5394b3d9c8ee84122b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by type.  <br /></td></tr>
<tr class="separator:aaaf770183eb5df5394b3d9c8ee84122b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade063549805a7c028dafe435ea1b97ae" id="r_ade063549805a7c028dafe435ea1b97ae"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... U&gt; </td></tr>
<tr class="memitem:ade063549805a7c028dafe435ea1b97ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr CONST_REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#ade063549805a7c028dafe435ea1b97ae">get</a> (const <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;e)</td></tr>
<tr class="memdesc:ade063549805a7c028dafe435ea1b97ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by type.  <br /></td></tr>
<tr class="separator:ade063549805a7c028dafe435ea1b97ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0a6c67537093186c34471536ff1037" id="r_a9c0a6c67537093186c34471536ff1037"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... U&gt; </td></tr>
<tr class="memitem:a9c0a6c67537093186c34471536ff1037"><td class="memTemplItemLeft" align="right" valign="top">constexpr RVALUE_REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a9c0a6c67537093186c34471536ff1037">get</a> (<a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;&amp;e)</td></tr>
<tr class="memdesc:a9c0a6c67537093186c34471536ff1037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by type.  <br /></td></tr>
<tr class="separator:a9c0a6c67537093186c34471536ff1037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4666bc4f06a8bb0cb572a47fd5d5f5ab" id="r_a4666bc4f06a8bb0cb572a47fd5d5f5ab"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... U&gt; </td></tr>
<tr class="memitem:a4666bc4f06a8bb0cb572a47fd5d5f5ab"><td class="memTemplItemLeft" align="right" valign="top">constexpr CONST_RVALUE_REFERENCE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a4666bc4f06a8bb0cb572a47fd5d5f5ab">get</a> (const <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;&amp;e)</td></tr>
<tr class="memdesc:a4666bc4f06a8bb0cb572a47fd5d5f5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative by type.  <br /></td></tr>
<tr class="separator:a4666bc4f06a8bb0cb572a47fd5d5f5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720782c76143d1be8ed926b6f730f49a" id="r_a720782c76143d1be8ed926b6f730f49a"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename... T&gt; </td></tr>
<tr class="memitem:a720782c76143d1be8ed926b6f730f49a"><td class="memTemplItemLeft" align="right" valign="top">constexpr POINTER&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a720782c76143d1be8ed926b6f730f49a">get_if</a> (<a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T... &gt; &amp;e) noexcept</td></tr>
<tr class="memdesc:a720782c76143d1be8ed926b6f730f49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative pointer by index if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> holds it.  <br /></td></tr>
<tr class="separator:a720782c76143d1be8ed926b6f730f49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12f5f7badd7d9d83a78e80ae285b45b" id="r_ab12f5f7badd7d9d83a78e80ae285b45b"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename... T&gt; </td></tr>
<tr class="memitem:ab12f5f7badd7d9d83a78e80ae285b45b"><td class="memTemplItemLeft" align="right" valign="top">constexpr CONST_POINTER&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#ab12f5f7badd7d9d83a78e80ae285b45b">get_if</a> (const <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T... &gt; &amp;e) noexcept</td></tr>
<tr class="memdesc:ab12f5f7badd7d9d83a78e80ae285b45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative pointer by index if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> holds it.  <br /></td></tr>
<tr class="separator:ab12f5f7badd7d9d83a78e80ae285b45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e79ec0aa07fe1604e9899354eaa70b" id="r_ae7e79ec0aa07fe1604e9899354eaa70b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... U&gt; </td></tr>
<tr class="memitem:ae7e79ec0aa07fe1604e9899354eaa70b"><td class="memTemplItemLeft" align="right" valign="top">constexpr POINTER&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#ae7e79ec0aa07fe1604e9899354eaa70b">get_if</a> (<a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;e) noexcept</td></tr>
<tr class="memdesc:ae7e79ec0aa07fe1604e9899354eaa70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative pointer by type if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> holds it.  <br /></td></tr>
<tr class="separator:ae7e79ec0aa07fe1604e9899354eaa70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6d985a6de9e81fdfcf01f52a995ee6" id="r_a2c6d985a6de9e81fdfcf01f52a995ee6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... U&gt; </td></tr>
<tr class="memitem:a2c6d985a6de9e81fdfcf01f52a995ee6"><td class="memTemplItemLeft" align="right" valign="top">constexpr CONST_POINTER&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a2c6d985a6de9e81fdfcf01f52a995ee6">get_if</a> (const <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;e) noexcept</td></tr>
<tr class="memdesc:a2c6d985a6de9e81fdfcf01f52a995ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an alternative pointer by type if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> holds it.  <br /></td></tr>
<tr class="separator:a2c6d985a6de9e81fdfcf01f52a995ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec6d7752f8c65b3e377ed39065aeccc" id="r_a5ec6d7752f8c65b3e377ed39065aeccc"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a5ec6d7752f8c65b3e377ed39065aeccc"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsumty_1_1error__set.html#a5ec6d7752f8c65b3e377ed39065aeccc">swap</a> (<a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T... &gt; &amp;a, <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T... &gt; &amp;b) CONDITIONALLY_NOEXCEPT</td></tr>
<tr class="memdesc:a5ec6d7752f8c65b3e377ed39065aeccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two <a class="el" href="classsumty_1_1error__set.html">error_set</a> instances.  <br /></td></tr>
<tr class="separator:a5ec6d7752f8c65b3e377ed39065aeccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename... T&gt;<br />
class sumty::error_set&lt; T &gt;</div><p>A discriminated union of unique error types. </p>
<p><a class="el" href="classsumty_1_1error__set.html">error_set</a> is very similar to <a class="el" href="classsumty_1_1variant.html">variant</a> in term of API. The key difference from <a class="el" href="classsumty_1_1variant.html">variant</a> is that <a class="el" href="classsumty_1_1error__set.html">error_set</a> requires all its alternatives to be unique, and <a class="el" href="classsumty_1_1error__set.html">error_set</a> allows direct conversions between different, but compatible, <a class="el" href="classsumty_1_1error__set.html">error_set</a> instantiations.</p>
<p>Given distinct types <code>A</code>, <code>B</code>, and <code>C</code>, <a class="el" href="classsumty_1_1error__set.html">error_set</a> allows the following implicit conversions (this is not exhaustive):</p><ul>
<li><code>A -&gt; <a class="el" href="classsumty_1_1error__set.html" title="A discriminated union of unique error types.">error_set</a>&lt;A, B, C&gt;</code></li>
<li><code>B -&gt; <a class="el" href="classsumty_1_1error__set.html" title="A discriminated union of unique error types.">error_set</a>&lt;A, B, C&gt;</code></li>
<li><code>C -&gt; <a class="el" href="classsumty_1_1error__set.html" title="A discriminated union of unique error types.">error_set</a>&lt;A, B, C&gt;</code></li>
<li><code><a class="el" href="classsumty_1_1error__set.html" title="A discriminated union of unique error types.">error_set</a>&lt;B&gt; -&gt; <a class="el" href="classsumty_1_1error__set.html" title="A discriminated union of unique error types.">error_set</a>&lt;A, B, C&gt;</code></li>
<li><code><a class="el" href="classsumty_1_1error__set.html" title="A discriminated union of unique error types.">error_set</a>&lt;C, A&gt; -&gt; <a class="el" href="classsumty_1_1error__set.html" title="A discriminated union of unique error types.">error_set</a>&lt;A, B, C&gt;</code></li>
<li><code><a class="el" href="classsumty_1_1error__set.html" title="A discriminated union of unique error types.">error_set</a>&lt;C, A, B&gt; -&gt; <a class="el" href="classsumty_1_1error__set.html" title="A discriminated union of unique error types.">error_set</a>&lt;A, B, C&gt;</code></li>
</ul>
<p>Generally, an <a class="el" href="classsumty_1_1error__set.html">error_set</a> can convert into a different error set as long as each of its alternatives unambiguously map to an alternative in the destination <a class="el" href="classsumty_1_1error__set.html">error_set</a>. Additionally, any bare type can convert into an <a class="el" href="classsumty_1_1error__set.html">error_set</a> if it can unambiguously convert into one of the destination alternatives.</p>
<p>The primary purpose of <a class="el" href="classsumty_1_1error__set.html">error_set</a> is to improve the convenience of error propagation with <a class="el" href="classsumty_1_1result.html">result</a>. The conversions shown above also apply to an <a class="el" href="classsumty_1_1error__set.html">error_set</a> nested as the error type of a <a class="el" href="classsumty_1_1result.html">result</a>. Below is a listing of the previous conversions examples, but now wrapped in <a class="el" href="classsumty_1_1result.html">result</a>, which is equally valid.</p><ul>
<li><code>result&lt;T, A&gt; -&gt; result&lt;T, <a class="el" href="classsumty_1_1error__set.html" title="A discriminated union of unique error types.">error_set</a>&lt;A, B, C&gt;&gt;</code></li>
<li><code>result&lt;T, B&gt; -&gt; result&lt;T, <a class="el" href="classsumty_1_1error__set.html" title="A discriminated union of unique error types.">error_set</a>&lt;A, B, C&gt;&gt;</code></li>
<li><code>result&lt;T, C&gt; -&gt; result&lt;T, <a class="el" href="classsumty_1_1error__set.html" title="A discriminated union of unique error types.">error_set</a>&lt;A, B, C&gt;&gt;</code></li>
<li><code>result&lt;T, <a class="el" href="classsumty_1_1error__set.html" title="A discriminated union of unique error types.">error_set</a>&lt;B&gt;&gt; -&gt; result&lt;T, <a class="el" href="classsumty_1_1error__set.html" title="A discriminated union of unique error types.">error_set</a>&lt;A, B, C&gt;&gt;</code></li>
<li><code>result&lt;T, <a class="el" href="classsumty_1_1error__set.html" title="A discriminated union of unique error types.">error_set</a>&lt;C, A&gt;&gt; -&gt; result&lt;T, <a class="el" href="classsumty_1_1error__set.html" title="A discriminated union of unique error types.">error_set</a>&lt;A, B, C&gt;&gt;</code></li>
<li><code>result&lt;T, <a class="el" href="classsumty_1_1error__set.html" title="A discriminated union of unique error types.">error_set</a>&lt;C, A, B&gt;&gt; -&gt; result&lt;T, <a class="el" href="classsumty_1_1error__set.html" title="A discriminated union of unique error types.">error_set</a>&lt;A, B, C&gt;&gt;</code></li>
</ul>
<p>Below is an example of how <a class="el" href="classsumty_1_1error__set.html">error_set</a> might be used in practice. </p><div class="fragment"><div class="line"><span class="comment">// specific error types</span></div>
<div class="line"><span class="keyword">struct </span>neg_int_error {};</div>
<div class="line"><span class="keyword">struct </span>int_parse_error {};</div>
<div class="line"><span class="keyword">struct </span>int_overflow_error {};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// union of the above error types</span></div>
<div class="line"><span class="keyword">using </span>my_errors = error_set&lt;</div>
<div class="line">    neg_int_error,</div>
<div class="line">    int_parse_error,</div>
<div class="line">    int_overflow_error</div>
<div class="line">&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// parse an integer from a string</span></div>
<div class="line">result&lt;int, int_parse_error&gt; parse_int(std::string_view str);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// calculate the absolute value of an integer</span></div>
<div class="line">result&lt;int, int_overflow_error&gt; abs_value(<span class="keywordtype">int</span> x);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// calculate the integer square root</span></div>
<div class="line">result&lt;int, neg_int_error&gt; isqrt(<span class="keywordtype">int</span> x);</div>
<div class="line"> </div>
<div class="line">result&lt;int, my_errors&gt; my_algorithm(std::string_view str) {</div>
<div class="line">    <span class="keyword">auto</span> parsed = parse_int(str);</div>
<div class="line">    <span class="keywordflow">if</span> (parsed.is_error()) { <span class="keywordflow">return</span> parsed; }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> positive = abs_value(*parsed);</div>
<div class="line">    <span class="keywordflow">if</span> (positive.is_error()) { <span class="keywordflow">return</span> positive; }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> isqrt(*positive);</div>
<div class="line">}</div>
</div><!-- fragment --><p>One possible pattern when using <a class="el" href="classsumty_1_1error__set.html">error_set</a> is to define all errors as empty types. Like all other sum types in sumty, an <a class="el" href="classsumty_1_1error__set.html">error_set</a> of all empty types only needs to actually store the discriminant. In this case, <a class="el" href="classsumty_1_1error__set.html">error_set</a> behaves like a flexible enum partially mapped into the type system. That is, a specific (empty) error type uniquely identifies an alternative in any <a class="el" href="classsumty_1_1error__set.html">error_set</a> that contains that error type, similar to how an enum value name identifies a value of that enum. So it is possible to create a set of error codes as types without giving them specific values and define subsets of those error codes for different use cases. A function might emit some, but not all, of the errors in your set of error codes, so that function need only declare that it can return those specific errors instead of all codes in the set.</p>
<p>That said, it is also perfectly valid for each error type to contain additional error information as needed. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="addff7a842486786bb2d73f5c7920f051" name="addff7a842486786bb2d73f5c7920f051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addff7a842486786bb2d73f5c7920f051">&#9670;&#160;</a></span>error_set() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Initializes the <a class="el" href="classsumty_1_1error__set.html">error_set</a> such that it contains a default constructed value of the first (index 0) alternative.</p>
<p>The first alternative <em>must</em> be default constructible for this constructor to participate in overload resoltuion, but no other alternatives need be default constructible.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">set</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">holds_alternative&lt;error1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">set</a>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">set</a>.index() == 0);</div>
<div class="ttc" id="aclasssumty_1_1result_html"><div class="ttname"><a href="classsumty_1_1result.html">sumty::result</a></div><div class="ttdoc">Type that contains an ok value, or an error.</div><div class="ttdef"><b>Definition</b> result.hpp:1262</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a90ab1726f393d524bca46bf28c10761b" name="a90ab1726f393d524bca46bf28c10761b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ab1726f393d524bca46bf28c10761b">&#9670;&#160;</a></span>error_set() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>A new <a class="el" href="classsumty_1_1error__set.html">error_set</a> is initialized such that it contains a copy constructed instance of the alternative contained in the source <a class="el" href="classsumty_1_1error__set.html">error_set</a>. If the source <a class="el" href="classsumty_1_1error__set.html">error_set</a> has more than one alternative of the same type, the new <a class="el" href="classsumty_1_1error__set.html">error_set</a> will contain the alternative of the same index.</p>
<p>All alternative types <em>must</em> be copy constructible for this constructor to participate in overload resolution.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e1</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e2</a>{<a class="code hl_class" href="classsumty_1_1result.html">e1</a>};</div>
<div class="line"> </div>
<div class="line">assert(holds_alternative&lt;error2&gt;(e2));</div>
<div class="line"> </div>
<div class="line">assert(e2.index() == 1);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a04d9a51f6dbdd64b09cf6dd4720bf39e" name="a04d9a51f6dbdd64b09cf6dd4720bf39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d9a51f6dbdd64b09cf6dd4720bf39e">&#9670;&#160;</a></span>error_set() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>A new <a class="el" href="classsumty_1_1error__set.html">error_set</a> is initialized such that it contains a move constructed instance of the alternative contained in the source <a class="el" href="classsumty_1_1error__set.html">error_set</a>. If the source <a class="el" href="classsumty_1_1error__set.html">error_set</a> has more than one alternative of the same type, the new <a class="el" href="classsumty_1_1error__set.html">error_set</a> will contain the alternative of the same index.</p>
<p>All alternative types <em>must</em> be move constructible for this constructor to participate in overload resolution.</p>
<p>The source <a class="el" href="classsumty_1_1error__set.html">error_set</a> will continue to contain an instance of the same alternative, but the value of the alternative after being moved depends on the move constructor of the type. In general, moved values are said to be in a valid, but unspecified, state.</p>
<h2><a class="anchor" id="autotoc_md28"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e1</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e2</a>{std::move(<a class="code hl_class" href="classsumty_1_1result.html">e1</a>)};</div>
<div class="line"> </div>
<div class="line">assert(holds_alternative&lt;error2&gt;(e2));</div>
<div class="line"> </div>
<div class="line">assert(e2.index() == 1);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a35063d5af416dedee7c7c00e8cb19b80" name="a35063d5af416dedee7c7c00e8cb19b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35063d5af416dedee7c7c00e8cb19b80">&#9670;&#160;</a></span>error_set() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> IDX, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::in_place_index_t&lt; <a class="el" href="classsumty_1_1result.html">IDX</a> &gt;&#160;</td>
          <td class="paramname"><em>inplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index emplacement constructor. </p>
<p>A new <a class="el" href="classsumty_1_1error__set.html">error_set</a> is initialized such that it contains a newly constructed instance of the alternative with the specified index. The arguments following <code>inplace</code> are forwarded directly to the constructor of the alternative type.</p>
<p>Given that <code>U</code> is the type of the alternative at the specified index, this constructor is always valid as long as <code>U</code> is constructible with the arguments, <code>std::forward&lt;Args&gt;(args)...</code>.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{std::in_place_index&lt;1&gt;, 5, <span class="charliteral">&#39;a&#39;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">holds_alternative&lt;std::string&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.index() == 1);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) == <span class="stringliteral">&quot;aaaaa&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inplace</td><td>Constructor tag that specifies the alternative index. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments used to construct the alternative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84cbee9be08c0da054b1558ce2991e04" name="a84cbee9be08c0da054b1558ce2991e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84cbee9be08c0da054b1558ce2991e04">&#9670;&#160;</a></span>error_set() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> IDX, <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::in_place_index_t&lt; <a class="el" href="classsumty_1_1result.html">IDX</a> &gt;&#160;</td>
          <td class="paramname"><em>inplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index emplacement constructor with <code>std::initializer_list</code> </p>
<p>A new <a class="el" href="classsumty_1_1error__set.html">error_set</a> is initialized such that it contains a newly constructed instance of the alternative with the specified index. The arguments following <code>inplace</code> are forwarded directly to the constructor of the alternative type.</p>
<p>Given that <code>U</code> is the type of the alternative at the specified index, this constructor is always valid as long as <code>U</code> is constructible with the arguments, <code>init, std::forward&lt;Args&gt;(args)...</code>.</p>
<h2><a class="anchor" id="autotoc_md30"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error, std::vector&lt;int&gt;</a>&gt; <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;,</div>
<div class="line">        {1, 2, 3, 4, 5}};</div>
<div class="line"> </div>
<div class="line">assert(<a class="code hl_function" href="classsumty_1_1error__set.html#a7d4ebf4f8a4bb3bccd7566476219bfa3">holds_alternative</a>&lt;std::vector&lt;int&gt;&gt;(e));</div>
<div class="line"> </div>
<div class="line">assert(e.index() == 1);</div>
<div class="line"> </div>
<div class="line">assert(get&lt;1&gt;(e).size() == 5);</div>
<div class="ttc" id="aclasssumty_1_1error__set_html_a7d4ebf4f8a4bb3bccd7566476219bfa3"><div class="ttname"><a href="classsumty_1_1error__set.html#a7d4ebf4f8a4bb3bccd7566476219bfa3">sumty::error_set::holds_alternative</a></div><div class="ttdeci">constexpr bool holds_alternative() const noexcept</div><div class="ttdoc">Checks if an error_set contains a particular alternative.</div><div class="ttdef"><b>Definition</b> error_set.hpp:1571</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inplace</td><td>Constructor tag that specifies the alternative index. </td></tr>
    <tr><td class="paramname">init</td><td>Initializer list forwarded to the alternative constructor </td></tr>
    <tr><td class="paramname">args</td><td>Additional arguments used to construct the alternative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07cd6f9c493e233bd4328a21e33d7af3" name="a07cd6f9c493e233bd4328a21e33d7af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cd6f9c493e233bd4328a21e33d7af3">&#9670;&#160;</a></span>error_set() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::in_place_type_t&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>inplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type emplacement constructor. </p>
<p>A new <a class="el" href="classsumty_1_1error__set.html">error_set</a> is initialized such that it contains a newly constructed instance of the alternative with the specified type. The arguments following <code>inplace</code> are forwarded directory to the constructor of the alternative type.</p>
<h2><a class="anchor" id="autotoc_md31"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_type&lt;std::string&gt;,</div>
<div class="line">        5, <span class="charliteral">&#39;a&#39;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">holds_alternative&lt;std::string&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.index() == 1);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) == <span class="stringliteral">&quot;aaaaa&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a307869b77e40fa40b1f48537bb296625" name="a307869b77e40fa40b1f48537bb296625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307869b77e40fa40b1f48537bb296625">&#9670;&#160;</a></span>error_set() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::in_place_type_t&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>inplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">V</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type emplacement constructor with <code>std::initializer_list</code> </p>
<p>A new <a class="el" href="classsumty_1_1error__set.html">error_set</a> is initialized such that it contains a newly constructed instance of the alternative with the specified type. The arguments following <code>inplace</code> are forwarded directory to the constructor of the alternative type.</p>
<h2><a class="anchor" id="autotoc_md32"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error, std::vector&lt;int&gt;</a>&gt; <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_type&lt;std::vector&lt;int&gt;&gt;,</div>
<div class="line">        {1, 2, 3, 4, 5}};</div>
<div class="line"> </div>
<div class="line">assert(<a class="code hl_function" href="classsumty_1_1error__set.html#a7d4ebf4f8a4bb3bccd7566476219bfa3">holds_alternative</a>&lt;std::vector&lt;int&gt;&gt;(e));</div>
<div class="line"> </div>
<div class="line">assert(e.index() == 1);</div>
<div class="line"> </div>
<div class="line">assert(get&lt;1&gt;(e).size() == 5);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae51ae4373d68b8a4b3b5ed161d346760" name="ae51ae4373d68b8a4b3b5ed161d346760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51ae4373d68b8a4b3b5ed161d346760">&#9670;&#160;</a></span>error_set() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">U</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwarding constructor. </p>
<p>A new <a class="el" href="classsumty_1_1error__set.html">error_set</a> is initialized such that an alternative is constructed in place with the provided value as the constructor argument.</p>
<p>To avoid ambiguity to the reader, this constructor only participates in overload resolution when there is only one alternative that could possibly be constructed from the value.</p>
<p>This constructor is <code>explicit</code> if the value is not implicitly convertible to the target alternative type.</p>
<h2><a class="anchor" id="autotoc_md33"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{<span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.index() == 1);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value that is used to construct the alternative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b2739845be27347e0a1f312d5c4f5a7" name="a2b2739845be27347e0a1f312d5c4f5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2739845be27347e0a1f312d5c4f5a7">&#9670;&#160;</a></span>error_set() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwarding constructor with initializer list. </p>
<p>A new <a class="el" href="classsumty_1_1error__set.html">error_set</a> is initialized such that an alternative is constructed in place with the provided <code>std::initializer_list</code> as the constructor argument.</p>
<p>To avoid ambiguity to the reader, this constructor only participates in overload resulotion when there is only one alternative that could possible be constructed from the initializer list.</p>
<p>This constructor is <code>explicit</code> if the <code>std::initializer_list</code> is not implicitly convertible to the target alternative type.</p>
<h2><a class="anchor" id="autotoc_md34"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error, std::vector&lt;int&gt;</a>&gt; <a class="code hl_class" href="classsumty_1_1result.html">e</a>({1, 2, 3, 4, 5});</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.index() == 1);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>).<a class="code hl_class" href="classsumty_1_1result.html">size</a>() == 5);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>The <code>std::initializer_list</code> that is used to construct the alternative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad98f18f5edbaa0b530fd391fa4e7a285" name="ad98f18f5edbaa0b530fd391fa4e7a285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98f18f5edbaa0b530fd391fa4e7a285">&#9670;&#160;</a></span>error_set() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;typename... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">CONDITIONALLY_EXPLICIT</a> <a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy conversion constructor. </p>
<p>A new <a class="el" href="classsumty_1_1error__set.html">error_set</a> is initialized from the value contained in another <a class="el" href="classsumty_1_1error__set.html">error_set</a> that is a non-strict subset of the destination <a class="el" href="classsumty_1_1error__set.html">error_set</a>. Each of the alternative types in the source <a class="el" href="classsumty_1_1error__set.html">error_set</a> must also be an alternative type in the destination <a class="el" href="classsumty_1_1error__set.html">error_set</a>, but they need not have the same index.</p>
<p>This constructor allows for values of <a class="el" href="classsumty_1_1error__set.html">error_set</a> to be easily propagated, whether returned directly, or as an alternative of any other sum type. Most commonly, this will be used to implicitly convert from a <a class="el" href="classsumty_1_1result.html">result</a> to another result with a superset of the errors as the source, such as when returning from a function.</p>
<h2><a class="anchor" id="autotoc_md35"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e1</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error2, error3, error1&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e2</a>{<a class="code hl_class" href="classsumty_1_1result.html">e1</a>};</div>
<div class="line"> </div>
<div class="line">assert(holds_alternative&lt;error2&gt;(e2));</div>
<div class="line"> </div>
<div class="line">assert(e2.index() == 0);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a03bf1fd41beb68334eb3ab9e9e48faad" name="a03bf1fd41beb68334eb3ab9e9e48faad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03bf1fd41beb68334eb3ab9e9e48faad">&#9670;&#160;</a></span>error_set() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;typename... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move conversion constructor. </p>
<p>A new <a class="el" href="classsumty_1_1error__set.html">error_set</a> is initialized from the value contained in another <a class="el" href="classsumty_1_1error__set.html">error_set</a> that is a non-strict subset of the destination <a class="el" href="classsumty_1_1error__set.html">error_set</a>. Each of the alternative types in the source <a class="el" href="classsumty_1_1error__set.html">error_set</a> must also be an alternative type in the destination <a class="el" href="classsumty_1_1error__set.html">error_set</a>, but they need not have the same index.</p>
<p>This constructor allows for values of <a class="el" href="classsumty_1_1error__set.html">error_set</a> to be easily propagated, whether returned directly, or as an alternative of any other sum type. Most commonly, this will be used to implicitly convert from a <a class="el" href="classsumty_1_1result.html">result</a> to another result with a superset of the errors as the source, such as when returning from a function.</p>
<h2><a class="anchor" id="autotoc_md36"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e1</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error2, error3, error1&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e2</a>{std::move(<a class="code hl_class" href="classsumty_1_1result.html">e1</a>)};</div>
<div class="line"> </div>
<div class="line">assert(holds_alternative&lt;error2&gt;(e2));</div>
<div class="line"> </div>
<div class="line">assert(e2.index() == 0);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5171ad3dd15a5dfc8eda67896f1e1844" name="a5171ad3dd15a5dfc8eda67896f1e1844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5171ad3dd15a5dfc8eda67896f1e1844">&#9670;&#160;</a></span>~error_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> ~<a class="el" href="classsumty_1_1error__set.html">error_set</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>The contained alternative of the <a class="el" href="classsumty_1_1error__set.html">error_set</a> will is destroyed in place.</p>
<p>The destructor is <code>noexcept</code> if all alternative types are nothrow destructible. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a51aa9c79ed9d904626ad89616ee4990f" name="a51aa9c79ed9d904626ad89616ee4990f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51aa9c79ed9d904626ad89616ee4990f">&#9670;&#160;</a></span>emplace() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new alternative in place by index. </p>
<p>This function destroys the alternative that the <a class="el" href="classsumty_1_1error__set.html">error_set</a> contains before the call, and constructs a new alternative with the specified index in place.</p>
<h2><a class="anchor" id="autotoc_md44"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">e</a>.<a class="code hl_function" href="classsumty_1_1result.html#a54263fe060a2027fef396d47ec9fc7ce">emplace</a>&lt;1&gt;(5, <span class="charliteral">&#39;a&#39;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">holds_alternative&lt;std::string&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.index() == 1);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) == <span class="stringliteral">&quot;aaaaa&quot;</span>);</div>
<div class="ttc" id="aclasssumty_1_1result_html_a54263fe060a2027fef396d47ec9fc7ce"><div class="ttname"><a href="classsumty_1_1result.html#a54263fe060a2027fef396d47ec9fc7ce">sumty::result::emplace</a></div><div class="ttdeci">constexpr reference emplace(Args &amp;&amp;... args)</div><div class="ttdoc">Constructs a new ok value in place into the result.</div><div class="ttdef"><b>Definition</b> result.hpp:4545</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Constructor arguments forwarded to the new alternative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the new alternative, if applicable </dd></dl>

</div>
</div>
<a id="a51aa9c79ed9d904626ad89616ee4990f" name="a51aa9c79ed9d904626ad89616ee4990f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51aa9c79ed9d904626ad89616ee4990f">&#9670;&#160;</a></span>emplace() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new alternative in place by type. </p>
<p>This function destroy the alternative that the <a class="el" href="classsumty_1_1error__set.html">error_set</a> contains before the call, and constructs a new alternative with the specified type in place.</p>
<h2><a class="anchor" id="autotoc_md46"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error, std::string&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">e</a>.<a class="code hl_function" href="classsumty_1_1result.html#a54263fe060a2027fef396d47ec9fc7ce">emplace</a>&lt;std::string&gt;(5, <span class="charliteral">&#39;a&#39;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">holds_alternative&lt;std::string&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.index() == 1);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) == <span class="stringliteral">&quot;aaaaa&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Constructor arguments forwarded to the new alternative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the new alternative, if applicable </dd></dl>

</div>
</div>
<a id="a4d75a701faaf7cda03a358a84acfe3ac" name="a4d75a701faaf7cda03a358a84acfe3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d75a701faaf7cda03a358a84acfe3ac">&#9670;&#160;</a></span>emplace() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> emplace </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new alternative in place by index. </p>
<p>This function destroys the alternative that the <a class="el" href="classsumty_1_1error__set.html">error_set</a> contains before the call, and constructs a new alternative with the specified index in place.</p>
<h2><a class="anchor" id="autotoc_md45"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error, std::vector&lt;int&gt;</a>&gt; <a class="code hl_class" href="classsumty_1_1result.html">e</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">e</a>.<a class="code hl_function" href="classsumty_1_1result.html#a54263fe060a2027fef396d47ec9fc7ce">emplace</a>&lt;1&gt;({1, 2, 3, 4, 5});</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_function" href="classsumty_1_1error__set.html#a7d4ebf4f8a4bb3bccd7566476219bfa3">holds_alternative</a>&lt;std::vector&lt;int&gt;&gt;(<a class="code hl_class" href="classsumty_1_1result.html">e</a>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.index() == 1);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>).<a class="code hl_class" href="classsumty_1_1result.html">size</a>() == 5);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>Initializer list forward to the new alternative </td></tr>
    <tr><td class="paramname">args</td><td>Constructor arguments forwarded to the new alternative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the new alternative, if applicable </dd></dl>

</div>
</div>
<a id="abe9de1c1c1f667f57155919abb7e79d6" name="abe9de1c1c1f667f57155919abb7e79d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9de1c1c1f667f57155919abb7e79d6">&#9670;&#160;</a></span>emplace() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> , <a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> emplace </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">V</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new alternative in place by type. </p>
<p>This function destroy the alternative that the <a class="el" href="classsumty_1_1error__set.html">error_set</a> contains before the call, and constructs a new alternative with the specified type in place.</p>
<h2><a class="anchor" id="autotoc_md47"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error, std::vector&lt;int&gt;</a>&gt; <a class="code hl_class" href="classsumty_1_1result.html">e</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">e</a>.<a class="code hl_function" href="classsumty_1_1result.html#a54263fe060a2027fef396d47ec9fc7ce">emplace</a>&lt;std::vector&lt;int&gt;&gt;({1, 2, 3, 4, 5});</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_function" href="classsumty_1_1error__set.html#a7d4ebf4f8a4bb3bccd7566476219bfa3">holds_alternative</a>&lt;std::vector&lt;int&gt;&gt;(<a class="code hl_class" href="classsumty_1_1result.html">e</a>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.index() == 1);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>).<a class="code hl_class" href="classsumty_1_1result.html">size</a>() == 5);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>Initializer list forward to the new alternative </td></tr>
    <tr><td class="paramname">args</td><td>Constructor arguments forwarded to the new alternative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the new alternative, if applicable </dd></dl>

</div>
</div>
<a id="a5bb0f2e97a687affd34d9ece8c9c59bc" name="a5bb0f2e97a687affd34d9ece8c9c59bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb0f2e97a687affd34d9ece8c9c59bc">&#9670;&#160;</a></span>get() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by index. </p>
<p>This function allows accessing alternatives by index, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md56"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;1&gt;() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">e</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;1&gt;() = <span class="stringliteral">&quot;no problem&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;1&gt;() == <span class="stringliteral">&quot;no problem&quot;</span>);</div>
<div class="ttc" id="aclasssumty_1_1result_html_a3bdfc23d3431292af06fb30707025eef"><div class="ttname"><a href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">sumty::result::get</a></div><div class="ttdeci">constexpr REFERENCE get(result&lt; T, E &gt; &amp;res)</div><div class="ttdoc">Gets a result value by index, as if it were a variant.</div><div class="ttdef"><b>Definition</b> result.hpp:5109</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative with the corresponding index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bb0f2e97a687affd34d9ece8c9c59bc" name="a5bb0f2e97a687affd34d9ece8c9c59bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb0f2e97a687affd34d9ece8c9c59bc">&#9670;&#160;</a></span>get() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by type. </p>
<p>This function allows accessing alternatives by type, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md60"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;std::string&gt;() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">e</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;std::string&gt;() = <span class="stringliteral">&quot;no problem&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;std::string&gt;() == <span class="stringliteral">&quot;no problem&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative with the corresponding type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66e0f8f4c60cc6726ce6571168835d89" name="a66e0f8f4c60cc6726ce6571168835d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e0f8f4c60cc6726ce6571168835d89">&#9670;&#160;</a></span>get() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by index. </p>
<p>This function allows accessing alternatives by index, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md58"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(std::move(<a class="code hl_class" href="classsumty_1_1result.html">e</a>).<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An rvalue reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative with the corresponding index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66e0f8f4c60cc6726ce6571168835d89" name="a66e0f8f4c60cc6726ce6571168835d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e0f8f4c60cc6726ce6571168835d89">&#9670;&#160;</a></span>get() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by type. </p>
<p>This function allows accessing alternatives by type, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md62"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(std::move(<a class="code hl_class" href="classsumty_1_1result.html">e</a>).<a class="code hl_class" href="classsumty_1_1result.html">get&lt;std::string&gt;</a>() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An rvalue reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative with the corresponding type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25cce71efb47892db3403e54fef6072e" name="a25cce71efb47892db3403e54fef6072e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cce71efb47892db3403e54fef6072e">&#9670;&#160;</a></span>get() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by index. </p>
<p>This function allows accessing alternatives by index, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md57"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;1&gt;() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative with the corresponding index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25cce71efb47892db3403e54fef6072e" name="a25cce71efb47892db3403e54fef6072e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cce71efb47892db3403e54fef6072e">&#9670;&#160;</a></span>get() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by type. </p>
<p>This function allows accessing alternatives by type, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md61"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.<a class="code hl_function" href="classsumty_1_1result.html#a3bdfc23d3431292af06fb30707025eef">get</a>&lt;std::string&gt;() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative with the corresponding type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfcc32bc6f1d424bb8041401437cd401" name="acfcc32bc6f1d424bb8041401437cd401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcc32bc6f1d424bb8041401437cd401">&#9670;&#160;</a></span>get() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by index. </p>
<p>This function allows accessing alternatives by index, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md59"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(std::move(<a class="code hl_class" href="classsumty_1_1result.html">e</a>).<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const rvalue reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative with the corresponding index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfcc32bc6f1d424bb8041401437cd401" name="acfcc32bc6f1d424bb8041401437cd401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcc32bc6f1d424bb8041401437cd401">&#9670;&#160;</a></span>get() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by type. </p>
<p>This function allows accessing alternatives by type, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md63"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(std::move(<a class="code hl_class" href="classsumty_1_1result.html">e</a>).<a class="code hl_class" href="classsumty_1_1result.html">get&lt;std::string&gt;</a>() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const rvalue reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative with the corresponding type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a265bae72c738f8886a40d3fcb358e70d" name="a265bae72c738f8886a40d3fcb358e70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265bae72c738f8886a40d3fcb358e70d">&#9670;&#160;</a></span>get_if() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_POINTER</a> get_if </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative pointer by index if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> holds it. </p>
<p>This functions tries to access an alternative by index. If the <a class="el" href="classsumty_1_1error__set.html">error_set</a> contains the alternative, this function returns a pointer to the alternative, if applicable. If the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative, this function returns null. In the case where the alternative is of type <code>void</code>, this function does nothing.</p>
<h2><a class="anchor" id="autotoc_md65"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.get_if&lt;1&gt;() != <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.get_if&lt;0&gt;() == <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const pointer to the accessed alternative, if applicable, or null </dd></dl>

</div>
</div>
<a id="a265bae72c738f8886a40d3fcb358e70d" name="a265bae72c738f8886a40d3fcb358e70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265bae72c738f8886a40d3fcb358e70d">&#9670;&#160;</a></span>get_if() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_POINTER</a> get_if </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative pointer by type if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> holds it. </p>
<p>This functions tries to access an alternative by type. If the <a class="el" href="classsumty_1_1error__set.html">error_set</a> contains the alternative, this function returns a pointer to the alternative, if applicable. If the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative, this function returns null. In the case where the alternative is of type <code>void</code>, this function does nothing.</p>
<h2><a class="anchor" id="autotoc_md67"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.get_if&lt;<a class="code hl_class" href="classsumty_1_1result.html">error2</a>&gt;() != <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.get_if&lt;<a class="code hl_class" href="classsumty_1_1result.html">error1</a>&gt;() == <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const pointer to the accessed alternative, if applicable, or null </dd></dl>

</div>
</div>
<a id="a58b10b57fcb769be2c692a4b6df452ab" name="a58b10b57fcb769be2c692a4b6df452ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b10b57fcb769be2c692a4b6df452ab">&#9670;&#160;</a></span>get_if() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">POINTER</a> get_if </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative pointer by index if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> holds it. </p>
<p>This functions tries to access an alternative by index. If the <a class="el" href="classsumty_1_1error__set.html">error_set</a> contains the alternative, this function returns a pointer to the alternative, if applicable. If the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative, this function returns null. In the case where the alternative is of type <code>void</code>, this function does nothing.</p>
<h2><a class="anchor" id="autotoc_md64"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.get_if&lt;1&gt;() != <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.get_if&lt;0&gt;() == <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the accessed alternative, if applicable, or null </dd></dl>

</div>
</div>
<a id="a58b10b57fcb769be2c692a4b6df452ab" name="a58b10b57fcb769be2c692a4b6df452ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b10b57fcb769be2c692a4b6df452ab">&#9670;&#160;</a></span>get_if() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">POINTER</a> get_if </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative pointer by type if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> holds it. </p>
<p>This functions tries to access an alternative by type. If the <a class="el" href="classsumty_1_1error__set.html">error_set</a> contains the alternative, this function returns a pointer to the alternative, if applicable. If the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative, this function returns null. In the case where the alternative is of type <code>void</code>, this function does nothing.</p>
<h2><a class="anchor" id="autotoc_md66"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.get_if&lt;<a class="code hl_class" href="classsumty_1_1result.html">error2</a>&gt;() != <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.get_if&lt;<a class="code hl_class" href="classsumty_1_1result.html">error1</a>&gt;() == <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the accessed alternative, if applicable, or null </dd></dl>

</div>
</div>
<a id="a7d4ebf4f8a4bb3bccd7566476219bfa3" name="a7d4ebf4f8a4bb3bccd7566476219bfa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4ebf4f8a4bb3bccd7566476219bfa3">&#9670;&#160;</a></span>holds_alternative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a> holds_alternative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an <a class="el" href="classsumty_1_1error__set.html">error_set</a> contains a particular alternative. </p>
<p>Given a type parameter, this function checks if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> currently holds an alternative that has the exact same type.</p>
<h2><a class="anchor" id="autotoc_md68"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e1</a>{std::in_place_index&lt;0&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e1</a>.holds_alternative&lt;<a class="code hl_class" href="classsumty_1_1result.html">error1</a>&gt;());</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e2</a>{std::in_place_index&lt;2&gt;};</div>
<div class="line"> </div>
<div class="line">assert(e2.holds_alternative&lt;error1&gt;());</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> holds an alternative of the given type. </dd></dl>

</div>
</div>
<a id="ae16ab6b77ec8c07ce9c5e558de5cd82b" name="ae16ab6b77ec8c07ce9c5e558de5cd82b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16ab6b77ec8c07ce9c5e558de5cd82b">&#9670;&#160;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">size_t</a> index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the index of the contained alternative. </p>
<p>The set of alternatives of a <a class="el" href="classsumty_1_1error__set.html">error_set</a> has a zero-based index based on the order in which they are specified in the <a class="el" href="classsumty_1_1error__set.html">error_set</a> template arguments.</p>
<p>This index is the normalized discriminant of the <a class="el" href="classsumty_1_1error__set.html">error_set</a>. The discriminant may be represented differently internally, depending on the alternative types, so this function normalizes the discriminant by converting it to a zero-based index in order to provide a common interface for all <a class="el" href="classsumty_1_1error__set.html">error_set</a> instantiations.</p>
<h2><a class="anchor" id="autotoc_md43"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3, error4&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{std::in_place_index&lt;2&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>.index() == 2);</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The index of the contained alternative. </dd></dl>

</div>
</div>
<a id="a9914b7590e4cf82a5c595f93f7e0a4a9" name="a9914b7590e4cf82a5c595f93f7e0a4a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9914b7590e4cf82a5c595f93f7e0a4a9">&#9670;&#160;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p>Copy assignment of an <a class="el" href="classsumty_1_1error__set.html">error_set</a> can take one of two possible code paths.</p>
<p>If the source and destination <a class="el" href="classsumty_1_1error__set.html">error_set</a> hold the same alternative (same index), the alternative value is copied via copy assignment.</p>
<p>Otherwise, if the source and destination hold different alternatives (different indices, but possibly the same type), the alternative of the destination <a class="el" href="classsumty_1_1error__set.html">error_set</a> is destroyed in place, and the new alternative is copy constructed.</p>
<p>All alternatives <em>must</em> be both copy assignable and copy constructible for this function to participate in overload resolution.</p>
<h2><a class="anchor" id="autotoc_md37"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e1</a>{std::in_place_index&lt;0&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;error2, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e2</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line">e1 = e2;</div>
<div class="line"> </div>
<div class="line">assert(holds_alternative&lt;error2&gt;(e1));</div>
<div class="line"> </div>
<div class="line">assert(e1.index() == 1);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="afd9ddc6a1c6269702b84cdeb0a255589" name="afd9ddc6a1c6269702b84cdeb0a255589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9ddc6a1c6269702b84cdeb0a255589">&#9670;&#160;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;typename... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy conversion assignment operator. </p>
<p>This function assigns the value contained in another <a class="el" href="classsumty_1_1error__set.html">error_set</a> that is a non-strict subset of the destination <a class="el" href="classsumty_1_1error__set.html">error_set</a>. Each of the alternative types in the source <a class="el" href="classsumty_1_1error__set.html">error_set</a> must also be an alternative type in the destination <a class="el" href="classsumty_1_1error__set.html">error_set</a>, but they need not have the same index.</p>
<h2><a class="anchor" id="autotoc_md41"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e1</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error2, error3, error1&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e2</a>{};</div>
<div class="line"> </div>
<div class="line">e2 = e1;</div>
<div class="line"> </div>
<div class="line">assert(holds_alternative&lt;error2&gt;(e2));</div>
<div class="line"> </div>
<div class="line">assert(e2.index() == 0);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af01c6c74db9db385eb66e13d5feea66f" name="af01c6c74db9db385eb66e13d5feea66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01c6c74db9db385eb66e13d5feea66f">&#9670;&#160;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<p>Move assignment of an <a class="el" href="classsumty_1_1error__set.html">error_set</a> can take one of two possible code paths.</p>
<p>If the source and destination <a class="el" href="classsumty_1_1error__set.html">error_set</a> hold the same alternative (same index), the alternative value is moved from the source to the destination via move assignment.</p>
<p>Otherwise, if the source and destination hold different alternatives (different indices, but possibly the same type), the alternative of the destination <a class="el" href="classsumty_1_1error__set.html">error_set</a> is destroyed in place, and the new alternative is move constructed.</p>
<p>The source <a class="el" href="classsumty_1_1error__set.html">error_set</a> will still contain the same alternative, but the value of the alternative depends on the move assignment or move constructor of the alternative's type. In general, moved values are said to be in a valid, but unspecified, state.</p>
<p>All alternatives <em>must</em> be both move assignable and move constructible for this function to participate in overload resolution.</p>
<h2><a class="anchor" id="autotoc_md38"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e1</a>{std::in_place_index&lt;0&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e2</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line">e1 = std::move(e2);</div>
<div class="line"> </div>
<div class="line">assert(holds_alternative&lt;error2&gt;(e1));</div>
<div class="line"> </div>
<div class="line">assert(e1.index() == 1);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aaaba45b9fee017793bf1d7d9c0cd41d6" name="aaaba45b9fee017793bf1d7d9c0cd41d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaba45b9fee017793bf1d7d9c0cd41d6">&#9670;&#160;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;typename... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move conversion assignment operator. </p>
<p>This function assigns the value contained in another <a class="el" href="classsumty_1_1error__set.html">error_set</a> that is a non-strict subset of the destination <a class="el" href="classsumty_1_1error__set.html">error_set</a>. Each of the alternative types in the source <a class="el" href="classsumty_1_1error__set.html">error_set</a> must also be an alternative type in the destination <a class="el" href="classsumty_1_1error__set.html">error_set</a>, but they need not have the same index.</p>
<h2><a class="anchor" id="autotoc_md42"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e1</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error2, error3, error1&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e2</a>{};</div>
<div class="line"> </div>
<div class="line">e2 = std::move(e1);</div>
<div class="line"> </div>
<div class="line">assert(holds_alternative&lt;error2&gt;(e2));</div>
<div class="line"> </div>
<div class="line">assert(e2.index() == 0);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa6047a0cca2d735ae4e7ef8922e6aa25" name="aa6047a0cca2d735ae4e7ef8922e6aa25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6047a0cca2d735ae4e7ef8922e6aa25">&#9670;&#160;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwarding assignment operator with initializer list. </p>
<p>This function assigns a <code>std::initializer_list</code> directoy to an alternative. If the <a class="el" href="classsumty_1_1error__set.html">error_set</a> already contains the target alternative, the <code>std::initializer_list</code> is assigned uting the alternative type's assignment operator. Otherwise, the target alternative is constructed with the <code>std::initializer_list</code>.</p>
<p>To avoid ambiguity to the reader, this function only participates in overload resolution when there is only one alternative that could possibly be assigned from the <code>std::initializer_list</code>.</p>
<h2><a class="anchor" id="autotoc_md40"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">variant&lt;error, std::vector&lt;int&gt;</a>&gt; <a class="code hl_class" href="classsumty_1_1result.html">e</a>{};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">e</a> = {1, 2, 3, 4, 5};</div>
<div class="line"> </div>
<div class="line">assert(<a class="code hl_function" href="classsumty_1_1error__set.html#a7d4ebf4f8a4bb3bccd7566476219bfa3">holds_alternative</a>&lt;std::vector&lt;int&gt;&gt;(e));</div>
<div class="line"> </div>
<div class="line">assert(e.index() == 1);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The <code>std::initializer_list</code> to be assigned to the alternative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4ee06fef43ce99cc62166cac7311159" name="ac4ee06fef43ce99cc62166cac7311159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ee06fef43ce99cc62166cac7311159">&#9670;&#160;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">U</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwarding assignment operator. </p>
<p>This function assigns a value directly to an alternative. If the <a class="el" href="classsumty_1_1error__set.html">error_set</a> already contains the target alternative, the value is assigned using the alternative type's assignemnt operator. Otherwise, the target alternative is constructed with the value.</p>
<p>To avoid ambiguity to the reader, this function only participates in overload resolution when there is only one alternative that could possibly be assigned from the value.</p>
<h2><a class="anchor" id="autotoc_md39"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">e</a> = <a class="code hl_class" href="classsumty_1_1result.html">error2</a>{};</div>
<div class="line"> </div>
<div class="line">assert(holds_alternative&lt;error2&gt;(e));</div>
<div class="line"> </div>
<div class="line">assert(e.index() == 1);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The value to be assigned to the alternative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d78cf19fadfc52be6fc46b972746912" name="a7d78cf19fadfc52be6fc46b972746912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d78cf19fadfc52be6fc46b972746912">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a> operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsumty_1_1index__t.html">index_t</a>&lt; <a class="el" href="classsumty_1_1result.html">I</a> &gt;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternative access operator by index. </p>
<p>This function allows accessing alternatives by index using the square bracket operator. Because the index must be a compile time value, instead of passing the index directly, the index is provided as an instance of <a class="el" href="structsumty_1_1index__t.html">index_t</a>.</p>
<p>This operator is unchecked and does not throw an exception. Passing an index that does not correspond to the currently contained alternative results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md50"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(std::move(<a class="code hl_class" href="classsumty_1_1result.html">e</a>)[<a class="code hl_class" href="classsumty_1_1result.html">index&lt;1&gt;</a>] == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A tag value that communicates a compile time index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed alternative, if applicable </dd></dl>

</div>
</div>
<a id="aff2d2b17eb46b78620e923b1b58a1899" name="aff2d2b17eb46b78620e923b1b58a1899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2d2b17eb46b78620e923b1b58a1899">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsumty_1_1index__t.html">index_t</a>&lt; <a class="el" href="classsumty_1_1result.html">I</a> &gt;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternative access operator by index. </p>
<p>This function allows accessing alternatives by index using the square bracket operator. Because the index must be a compile time value, instead of passing the index directly, the index is provided as an instance of <a class="el" href="structsumty_1_1index__t.html">index_t</a>.</p>
<p>This operator is unchecked and does not throw an exception. Passing an index that does not correspond to the currently contained alternative results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md48"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>[<a class="code hl_class" href="classsumty_1_1result.html">index&lt;1&gt;</a>] == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>[<a class="code hl_class" href="classsumty_1_1result.html">index&lt;1&gt;</a>] = <span class="stringliteral">&quot;no problem&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == <span class="stringliteral">&quot;no problem&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A tag value that communicates a compile time index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed alternative, if applicable </dd></dl>

</div>
</div>
<a id="a015017e598c8340b3be3481a5ef7d1f8" name="a015017e598c8340b3be3481a5ef7d1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015017e598c8340b3be3481a5ef7d1f8">&#9670;&#160;</a></span>operator[]() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a> operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsumty_1_1index__t.html">index_t</a>&lt; <a class="el" href="classsumty_1_1result.html">I</a> &gt;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternative access operator by index. </p>
<p>This function allows accessing alternatives by index using the square bracket operator. Because the index must be a compile time value, instead of passing the index directly, the index is provided as an instance of <a class="el" href="structsumty_1_1index__t.html">index_t</a>.</p>
<p>This operator is unchecked and does not throw an exception. Passing an index that does not correspond to the currently contained alternative results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md51"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(std::move(<a class="code hl_class" href="classsumty_1_1result.html">e</a>)[<a class="code hl_class" href="classsumty_1_1result.html">index&lt;1&gt;</a>] == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A tag value that communicates a compile time index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed alternative, if applicable </dd></dl>

</div>
</div>
<a id="a4acc04a3c20910caf473d04e3df96dac" name="a4acc04a3c20910caf473d04e3df96dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4acc04a3c20910caf473d04e3df96dac">&#9670;&#160;</a></span>operator[]() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a> operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsumty_1_1index__t.html">index_t</a>&lt; <a class="el" href="classsumty_1_1result.html">I</a> &gt;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternative access operator by index. </p>
<p>This function allows accessing alternatives by index using the square bracket operator. Because the index must be a compile time value, instead of passing the index directly, the index is provided as an instance of <a class="el" href="structsumty_1_1index__t.html">index_t</a>.</p>
<p>This operator is unchecked and does not throw an exception. Passing an index that does not correspond to the currently contained alternative results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md49"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>[<a class="code hl_class" href="classsumty_1_1result.html">index&lt;1&gt;</a>] == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A tag value that communicates a compile time index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed alternative, if applicable </dd></dl>

</div>
</div>
<a id="a65ba2eeeab7db3966934aafe7db79735" name="a65ba2eeeab7db3966934aafe7db79735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ba2eeeab7db3966934aafe7db79735">&#9670;&#160;</a></span>operator[]() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a> operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsumty_1_1type__t.html">type_t</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternative access operator by type. </p>
<p>This function allows accessing alternatives by type using the square bracket operator. Because the index must be a compile time value, the index is provided as an instance of <a class="el" href="structsumty_1_1type__t.html">type_t</a>.</p>
<p>This operator is unchecked and does not throw an exception. Passing an index that does not correspond to the currently contained alternative results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md54"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(std::move(<a class="code hl_class" href="classsumty_1_1result.html">e</a>)[<a class="code hl_class" href="classsumty_1_1result.html">type&lt;std::string&gt;</a>] == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A tag value that communicates a compile time index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The accessed alternative value, if applicable </dd></dl>

</div>
</div>
<a id="abe93f72a909cf965adbf3fc1c3b73e6b" name="abe93f72a909cf965adbf3fc1c3b73e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe93f72a909cf965adbf3fc1c3b73e6b">&#9670;&#160;</a></span>operator[]() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsumty_1_1type__t.html">type_t</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternative access operator by type. </p>
<p>This function allows accessing alternatives by type using the square bracket operator. Because the index must be a compile time value, the index is provided as an instance of <a class="el" href="structsumty_1_1type__t.html">type_t</a>.</p>
<p>This operator is unchecked and does not throw an exception. Passing an index that does not correspond to the currently contained alternative results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md52"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>[<a class="code hl_class" href="classsumty_1_1result.html">type&lt;std::string&gt;</a>] == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">v</a>[<a class="code hl_class" href="classsumty_1_1result.html">type&lt;std::string&gt;</a>] = <span class="stringliteral">&quot;no problem&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;std::string&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">v</a>) == <span class="stringliteral">&quot;no problem&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A tag value that communicates a compile time index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The accessed alternative value, if applicable </dd></dl>

</div>
</div>
<a id="a5d9e8b0aad003da2ccef9e62f8133ad0" name="a5d9e8b0aad003da2ccef9e62f8133ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9e8b0aad003da2ccef9e62f8133ad0">&#9670;&#160;</a></span>operator[]() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a> operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsumty_1_1type__t.html">type_t</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternative access operator by type. </p>
<p>This function allows accessing alternatives by type using the square bracket operator. Because the index must be a compile time value, the index is provided as an instance of <a class="el" href="structsumty_1_1type__t.html">type_t</a>.</p>
<p>This operator is unchecked and does not throw an exception. Passing an index that does not correspond to the currently contained alternative results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md55"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(std::move(<a class="code hl_class" href="classsumty_1_1result.html">e</a>)[<a class="code hl_class" href="classsumty_1_1result.html">type&lt;std::string&gt;</a>] == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A tag value that communicates a compile time index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The accessed alternative value, if applicable </dd></dl>

</div>
</div>
<a id="a7947e07a7b41fa6276746a4244a4923a" name="a7947e07a7b41fa6276746a4244a4923a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7947e07a7b41fa6276746a4244a4923a">&#9670;&#160;</a></span>operator[]() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">U</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a> operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsumty_1_1type__t.html">type_t</a>&lt; <a class="el" href="classsumty_1_1result.html">U</a> &gt;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternative access operator by type. </p>
<p>This function allows accessing alternatives by type using the square bracket operator. Because the index must be a compile time value, the index is provided as an instance of <a class="el" href="structsumty_1_1type__t.html">type_t</a>.</p>
<p>This operator is unchecked and does not throw an exception. Passing an index that does not correspond to the currently contained alternative results in undefined behavior.</p>
<h2><a class="anchor" id="autotoc_md53"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>[<a class="code hl_class" href="classsumty_1_1result.html">type&lt;std::string&gt;</a>] == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>A tag value that communicates a compile time index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The accessed alternative value, if applicable </dd></dl>

</div>
</div>
<a id="a86176821a53c55817f118bc82521733d" name="a86176821a53c55817f118bc82521733d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86176821a53c55817f118bc82521733d">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">void</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two <a class="el" href="classsumty_1_1error__set.html">error_set</a> instances. </p>
<p>If the two <a class="el" href="classsumty_1_1error__set.html">error_set</a> instances contain the same alternative, the alternative values are swapped directly. Otherwise, the alternatives are swapped by moving out of the variants, destroying the old alternatives, and move constructed into the new alternatives.</p>
<h2><a class="anchor" id="autotoc_md77"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e1</a>{std::in_place_index&lt;0&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e2</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line">e1.<a class="code hl_function" href="classsumty_1_1result.html#a9a3be55eeb914e44478166807b43eef9">swap</a>(e2);</div>
<div class="line"> </div>
<div class="line">assert(e1.index() == 1);</div>
<div class="line"> </div>
<div class="line">assert(e2.index() == 0);</div>
<div class="ttc" id="aclasssumty_1_1result_html_a9a3be55eeb914e44478166807b43eef9"><div class="ttname"><a href="classsumty_1_1result.html#a9a3be55eeb914e44478166807b43eef9">sumty::result::swap</a></div><div class="ttdeci">constexpr void swap(result &amp;other) CONDITIONALLY_NOEXCEPT</div><div class="ttdoc">Swaps two result instances.</div><div class="ttdef"><b>Definition</b> result.hpp:5066</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The "other" <a class="el" href="classsumty_1_1error__set.html">error_set</a> to swap with this <a class="el" href="classsumty_1_1error__set.html">error_set</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2f575e3e78ea2171d1be475f7f9a2d8" name="ae2f575e3e78ea2171d1be475f7f9a2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f575e3e78ea2171d1be475f7f9a2d8">&#9670;&#160;</a></span>visit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a visitor callable with the contained alternative. </p>
<p>This function calls the visitor as <code>std::invoke(visitor, alternative)</code> and returns the result of that call, if any. As such, <code>visitor</code> <em>must</em> be able to accecpt any alternative type as an argument. In the case of an alternative of type <code>void</code>, the visitor must be callable as <code>std::invoke(visitor, void_v)</code>.</p>
<p>Note that the overload function can be helpful for defining a visitor inline.</p>
<p>Also note that this function is implemented as a compile-time-defined jump table (array of function pointers). In performance critical applications, be wary of any assumptions about how well or poorly your compiler will optimize a call to this function.</p>
<h2><a class="anchor" id="autotoc_md69"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e1</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">e1</a>.<a class="code hl_function" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>(overload(</div>
<div class="line">    [](<a class="code hl_class" href="classsumty_1_1result.html">error1</a>&amp; <a class="code hl_class" href="classsumty_1_1result.html">e</a>) { <a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">false</span>); },</div>
<div class="line">    [](error2&amp; e) { assert(<span class="keyword">true</span>); },</div>
<div class="line">    [](error3&amp; e) { assert(<span class="keyword">false</span>); }</div>
<div class="line">));</div>
<div class="ttc" id="aclasssumty_1_1result_html_ae2f575e3e78ea2171d1be475f7f9a2d8"><div class="ttname"><a href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">sumty::result::visit</a></div><div class="ttdeci">constexpr DEDUCED visit(V &amp;&amp;visitor) &amp;</div><div class="ttdoc">Invokes a visitor witht he contained value.</div><div class="ttdef"><b>Definition</b> result.hpp:4664</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The callable object that will be passed an alternative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the visitor, if any. </dd></dl>

</div>
</div>
<a id="adaaf65bdef1581aff9bda2ed4174143d" name="adaaf65bdef1581aff9bda2ed4174143d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaaf65bdef1581aff9bda2ed4174143d">&#9670;&#160;</a></span>visit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a visitor callable with the contained alternative. </p>
<p>This function calls the visitor as <code>std::invoke(visitor, alternative)</code> and returns the result of that call, if any. As such, <code>visitor</code> <em>must</em> be able to accecpt any alternative type as an argument. In the case of an alternative of type <code>void</code>, the visitor must be callable as <code>std::invoke(visitor, void_v)</code>.</p>
<p>Note that the overload function can be helpful for defining a visitor inline.</p>
<p>Also note that this function is implemented as a compile-time-defined jump table (array of function pointers). In performance critical applications, be wary of any assumptions about how well or poorly your compiler will optimize a call to this function.</p>
<h2><a class="anchor" id="autotoc_md71"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e1</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line">std::move(<a class="code hl_class" href="classsumty_1_1result.html">e1</a>).<a class="code hl_function" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>(overload(</div>
<div class="line">    [](<a class="code hl_class" href="classsumty_1_1result.html">error1</a>&amp;&amp; <a class="code hl_class" href="classsumty_1_1result.html">e</a>) { <a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">false</span>); },</div>
<div class="line">    [](error2&amp;&amp; e) { assert(<span class="keyword">true</span>); },</div>
<div class="line">    [](error3&amp;&amp; e) { assert(<span class="keyword">false</span>); }</div>
<div class="line">));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The callable object that will be passed an alternative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the visitor, if any. </dd></dl>

</div>
</div>
<a id="aeeca86cd9abb551e0c1e52ba81289f29" name="aeeca86cd9abb551e0c1e52ba81289f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeca86cd9abb551e0c1e52ba81289f29">&#9670;&#160;</a></span>visit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a visitor callable with the contained alternative. </p>
<p>This function calls the visitor as <code>std::invoke(visitor, alternative)</code> and returns the result of that call, if any. As such, <code>visitor</code> <em>must</em> be able to accecpt any alternative type as an argument. In the case of an alternative of type <code>void</code>, the visitor must be callable as <code>std::invoke(visitor, void_v)</code>.</p>
<p>Note that the overload function can be helpful for defining a visitor inline.</p>
<p>Also note that this function is implemented as a compile-time-defined jump table (array of function pointers). In performance critical applications, be wary of any assumptions about how well or poorly your compiler will optimize a call to this function.</p>
<h2><a class="anchor" id="autotoc_md70"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e1</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">e1</a>.<a class="code hl_function" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>(overload(</div>
<div class="line">    [](<span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error1</a>&amp; <a class="code hl_class" href="classsumty_1_1result.html">e</a>) { <a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">false</span>); },</div>
<div class="line">    [](<span class="keyword">const</span> error2&amp; e) { assert(<span class="keyword">true</span>); },</div>
<div class="line">    [](<span class="keyword">const</span> error3&amp; e) { assert(<span class="keyword">false</span>); }</div>
<div class="line">));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The callable object that will be passed an alternative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the visitor, if any. </dd></dl>

</div>
</div>
<a id="a12b9d6a30c96d7caac920ce264c66de1" name="a12b9d6a30c96d7caac920ce264c66de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b9d6a30c96d7caac920ce264c66de1">&#9670;&#160;</a></span>visit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a visitor callable with the contained alternative. </p>
<p>This function calls the visitor as <code>std::invoke(visitor, alternative)</code> and returns the result of that call, if any. As such, <code>visitor</code> <em>must</em> be able to accecpt any alternative type as an argument. In the case of an alternative of type <code>void</code>, the visitor must be callable as <code>std::invoke(visitor, void_v)</code>.</p>
<p>Note that the overload function can be helpful for defining a visitor inline.</p>
<p>Also note that this function is implemented as a compile-time-defined jump table (array of function pointers). In performance critical applications, be wary of any assumptions about how well or poorly your compiler will optimize a call to this function.</p>
<h2><a class="anchor" id="autotoc_md72"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e1</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line">std::move(<a class="code hl_class" href="classsumty_1_1result.html">e1</a>).<a class="code hl_function" href="classsumty_1_1result.html#ae2f575e3e78ea2171d1be475f7f9a2d8">visit</a>(overload(</div>
<div class="line">    [](<span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error1</a>&amp;&amp; <a class="code hl_class" href="classsumty_1_1result.html">e</a>) { <a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">false</span>); },</div>
<div class="line">    [](<span class="keyword">const</span> error2&amp;&amp; e) { assert(<span class="keyword">true</span>); },</div>
<div class="line">    [](<span class="keyword">const</span> error3&amp;&amp; e) { assert(<span class="keyword">false</span>); }</div>
<div class="line">));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The callable object that will be passed an alternative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the visitor, if any. </dd></dl>

</div>
</div>
<a id="a1656bb14f0a45ec7cfa81bb960acf924" name="a1656bb14f0a45ec7cfa81bb960acf924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1656bb14f0a45ec7cfa81bb960acf924">&#9670;&#160;</a></span>visit_informed() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit_informed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a visitor callable with the contained alternative and metadata. </p>
<p>This function calls the visitor as <code>std::invoke(visitor, alternative, info)</code>, and returns the result of that call, if any. As such, <code>visitor</code> <em>must</em> be able to accept any alternative type as an argument. In the case of an alternative of type <code>void</code>, the visitor must be callable as <code>std::invoke(visitor, void_v, info)</code>.</p>
<p>The <code>info</code> argument passed to the visitor, which differentiates this function from <code>.visit(...)</code>, communicates <code>constexpr</code> information about the alternative being visited. The type of the <code>info</code> object is not meant to be named, but it has the API shown below. Note that <code>info</code> is always an empty type.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>alternative_info {</div>
<div class="line">    <span class="comment">// index of the alternative in the source error_set</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> index = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// type of the alternative as declared in the source error_set</span></div>
<div class="line">    <span class="keyword">using </span>type = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// helper function for forwarding non-const alternative values</span></div>
<div class="line">    <span class="comment">// without needing to provide a template argument.</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) forward(...);</div>
<div class="line">};</div>
</div><!-- fragment --><p>Note that the overload function can be helpful for defining a visitor inline.</p>
<p>Also note that this function is implemented as a compile-time-defined jump table (array of function pointers). In performance critical applications, be wary of any assumptions about how well or poorly your compiler will optimize a call to this function.</p>
<h2><a class="anchor" id="autotoc_md73"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e1</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">e1</a>.<a class="code hl_function" href="classsumty_1_1result.html#a1656bb14f0a45ec7cfa81bb960acf924">visit_informed</a>([](<span class="keyword">auto</span>&amp; value, <span class="keyword">auto</span> <a class="code hl_class" href="classsumty_1_1result.html">info</a>) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<a class="code hl_class" href="classsumty_1_1result.html">info</a>.index == 0) {</div>
<div class="line">        <a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">false</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 1) {</div>
<div class="line">        assert(<span class="keyword">true</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 2) {</div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="ttc" id="aclasssumty_1_1result_html_a1656bb14f0a45ec7cfa81bb960acf924"><div class="ttname"><a href="classsumty_1_1result.html#a1656bb14f0a45ec7cfa81bb960acf924">sumty::result::visit_informed</a></div><div class="ttdeci">constexpr DEDUCED visit_informed(V &amp;&amp;visitor) &amp;</div><div class="ttdoc">Invokes a visitor with the contained value and meta data.</div><div class="ttdef"><b>Definition</b> result.hpp:4848</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The callable object that will be passed an alternative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the visitor, if any. </dd></dl>

</div>
</div>
<a id="a2b181b22d126a38b86f5a93035b6b7bc" name="a2b181b22d126a38b86f5a93035b6b7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b181b22d126a38b86f5a93035b6b7bc">&#9670;&#160;</a></span>visit_informed() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit_informed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a visitor callable with the contained alternative and metadata. </p>
<p>This function calls the visitor as <code>std::invoke(visitor, alternative, info)</code>, and returns the result of that call, if any. As such, <code>visitor</code> <em>must</em> be able to accept any alternative type as an argument. In the case of an alternative of type <code>void</code>, the visitor must be callable as <code>std::invoke(visitor, void_v, info)</code>.</p>
<p>The <code>info</code> argument passed to the visitor, which differentiates this function from <code>.visit(...)</code>, communicates <code>constexpr</code> information about the alternative being visited. The type of the <code>info</code> object is not meant to be named, but it has the API shown below. Note that <code>info</code> is always an empty type.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>alternative_info {</div>
<div class="line">    <span class="comment">// index of the alternative in the source error_set</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> index = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// type of the alternative as declared in the source error_set</span></div>
<div class="line">    <span class="keyword">using </span>type = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// helper function for forwarding non-const alternative values</span></div>
<div class="line">    <span class="comment">// without needing to provide a template argument.</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) forward(...);</div>
<div class="line">};</div>
</div><!-- fragment --><p>Note that the overload function can be helpful for defining a visitor inline.</p>
<p>Also note that this function is implemented as a compile-time-defined jump table (array of function pointers). In performance critical applications, be wary of any assumptions about how well or poorly your compiler will optimize a call to this function.</p>
<h2><a class="anchor" id="autotoc_md75"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e1</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line">std::move(<a class="code hl_class" href="classsumty_1_1result.html">e1</a>).<a class="code hl_function" href="classsumty_1_1result.html#a1656bb14f0a45ec7cfa81bb960acf924">visit_informed</a>([](<span class="keyword">auto</span>&amp;&amp; value, <span class="keyword">auto</span> <a class="code hl_class" href="classsumty_1_1result.html">info</a>) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<a class="code hl_class" href="classsumty_1_1result.html">info</a>.index == 0) {</div>
<div class="line">        <a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">false</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 1) {</div>
<div class="line">        assert(<span class="keyword">true</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 2) {</div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The callable object that will be passed an alternative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the visitor, if any. </dd></dl>

</div>
</div>
<a id="aebb3a178a071dfb5bdecb8607d446a4b" name="aebb3a178a071dfb5bdecb8607d446a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb3a178a071dfb5bdecb8607d446a4b">&#9670;&#160;</a></span>visit_informed() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit_informed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a visitor callable with the contained alternative and metadata. </p>
<p>This function calls the visitor as <code>std::invoke(visitor, alternative, info)</code>, and returns the result of that call, if any. As such, <code>visitor</code> <em>must</em> be able to accept any alternative type as an argument. In the case of an alternative of type <code>void</code>, the visitor must be callable as <code>std::invoke(visitor, void_v, info)</code>.</p>
<p>The <code>info</code> argument passed to the visitor, which differentiates this function from <code>.visit(...)</code>, communicates <code>constexpr</code> information about the alternative being visited. The type of the <code>info</code> object is not meant to be named, but it has the API shown below. Note that <code>info</code> is always an empty type.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>alternative_info {</div>
<div class="line">    <span class="comment">// index of the alternative in the source error_set</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> index = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// type of the alternative as declared in the source error_set</span></div>
<div class="line">    <span class="keyword">using </span>type = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// helper function for forwarding non-const alternative values</span></div>
<div class="line">    <span class="comment">// without needing to provide a template argument.</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) forward(...);</div>
<div class="line">};</div>
</div><!-- fragment --><p>Note that the overload function can be helpful for defining a visitor inline.</p>
<p>Also note that this function is implemented as a compile-time-defined jump table (array of function pointers). In performance critical applications, be wary of any assumptions about how well or poorly your compiler will optimize a call to this function.</p>
<h2><a class="anchor" id="autotoc_md74"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e1</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">e1</a>.<a class="code hl_function" href="classsumty_1_1result.html#a1656bb14f0a45ec7cfa81bb960acf924">visit_informed</a>([](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; value, <span class="keyword">auto</span> <a class="code hl_class" href="classsumty_1_1result.html">info</a>) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<a class="code hl_class" href="classsumty_1_1result.html">info</a>.index == 0) {</div>
<div class="line">        <a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">false</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 1) {</div>
<div class="line">        assert(<span class="keyword">true</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 2) {</div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The callable object that will be passed an alternative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the visitor, if any. </dd></dl>

</div>
</div>
<a id="affdb84ccc3402ad25040ee85cbffb9a3" name="affdb84ccc3402ad25040ee85cbffb9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdb84ccc3402ad25040ee85cbffb9a3">&#9670;&#160;</a></span>visit_informed() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> <a class="el" href="classsumty_1_1result.html">V</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">DEDUCED</a> visit_informed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a visitor callable with the contained alternative and metadata. </p>
<p>This function calls the visitor as <code>std::invoke(visitor, alternative, info)</code>, and returns the result of that call, if any. As such, <code>visitor</code> <em>must</em> be able to accept any alternative type as an argument. In the case of an alternative of type <code>void</code>, the visitor must be callable as <code>std::invoke(visitor, void_v, info)</code>.</p>
<p>The <code>info</code> argument passed to the visitor, which differentiates this function from <code>.visit(...)</code>, communicates <code>constexpr</code> information about the alternative being visited. The type of the <code>info</code> object is not meant to be named, but it has the API shown below. Note that <code>info</code> is always an empty type.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>alternative_info {</div>
<div class="line">    <span class="comment">// index of the alternative in the source error_set</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> index = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// type of the alternative as declared in the source error_set</span></div>
<div class="line">    <span class="keyword">using </span>type = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// helper function for forwarding non-const alternative values</span></div>
<div class="line">    <span class="comment">// without needing to provide a template argument.</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) forward(...);</div>
<div class="line">};</div>
</div><!-- fragment --><p>Note that the overload function can be helpful for defining a visitor inline.</p>
<p>Also note that this function is implemented as a compile-time-defined jump table (array of function pointers). In performance critical applications, be wary of any assumptions about how well or poorly your compiler will optimize a call to this function.</p>
<h2><a class="anchor" id="autotoc_md76"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e1</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line">std::move(<a class="code hl_class" href="classsumty_1_1result.html">e1</a>).<a class="code hl_function" href="classsumty_1_1result.html#a1656bb14f0a45ec7cfa81bb960acf924">visit_informed</a>([](<span class="keyword">const</span> <span class="keyword">auto</span>&amp;&amp; value, <span class="keyword">auto</span> <a class="code hl_class" href="classsumty_1_1result.html">info</a>) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<a class="code hl_class" href="classsumty_1_1result.html">info</a>.index == 0) {</div>
<div class="line">        <a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<span class="keyword">false</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 1) {</div>
<div class="line">        assert(<span class="keyword">true</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (info.index == 2) {</div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The callable object that will be passed an alternative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of the visitor, if any. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="acad3c31781c3739c593b02b00ca2c08f" name="acad3c31781c3739c593b02b00ca2c08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad3c31781c3739c593b02b00ca2c08f">&#9670;&#160;</a></span>get() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by index. </p>
<p>This function allows accessing alternatives by index, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(std::move(<a class="code hl_class" href="classsumty_1_1result.html">e</a>)) == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const rvalue reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative with the corresponding index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a310562571ad5c34d977c99ce7e81c1a7" name="a310562571ad5c34d977c99ce7e81c1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310562571ad5c34d977c99ce7e81c1a7">&#9670;&#160;</a></span>get() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by index. </p>
<p>This function allows accessing alternatives by index, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative with the corresponding index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4666bc4f06a8bb0cb572a47fd5d5f5ab" name="a4666bc4f06a8bb0cb572a47fd5d5f5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4666bc4f06a8bb0cb572a47fd5d5f5ab">&#9670;&#160;</a></span>get() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_RVALUE_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by type. </p>
<p>This function allows accessing alternatives by type, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(std::move(<a class="code hl_class" href="classsumty_1_1result.html">e</a>).<a class="code hl_class" href="classsumty_1_1result.html">get&lt;std::string&gt;</a>() == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const rvalue reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative with the corresponding type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade063549805a7c028dafe435ea1b97ae" name="ade063549805a7c028dafe435ea1b97ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade063549805a7c028dafe435ea1b97ae">&#9670;&#160;</a></span>get() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by type. </p>
<p>This function allows accessing alternatives by type, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;std::string&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative with the corresponding type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd10c3ec3f70ea53aecf71378af08cb3" name="acd10c3ec3f70ea53aecf71378af08cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd10c3ec3f70ea53aecf71378af08cb3">&#9670;&#160;</a></span>get() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by index. </p>
<p>This function allows accessing alternatives by index, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(std::move(<a class="code hl_class" href="classsumty_1_1result.html">e</a>)) == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An rvalue reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative with the corresponding index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07957e37505cc11f10db7d8d17182966" name="a07957e37505cc11f10db7d8d17182966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07957e37505cc11f10db7d8d17182966">&#9670;&#160;</a></span>get() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by index. </p>
<p>This function allows accessing alternatives by index, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md1"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) = <span class="stringliteral">&quot;no problem&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) == <span class="stringliteral">&quot;no problem&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative with the corresponding index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c0a6c67537093186c34471536ff1037" name="a9c0a6c67537093186c34471536ff1037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0a6c67537093186c34471536ff1037">&#9670;&#160;</a></span>get() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">RVALUE_REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by type. </p>
<p>This function allows accessing alternatives by type, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;std::string&gt;</a>(std::move(<a class="code hl_class" href="classsumty_1_1result.html">e</a>)) == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An rvalue reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative with the corresponding type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaaf770183eb5df5394b3d9c8ee84122b" name="aaaf770183eb5df5394b3d9c8ee84122b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf770183eb5df5394b3d9c8ee84122b">&#9670;&#160;</a></span>get() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">REFERENCE</a> get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative by type. </p>
<p>This function allows accessing alternatives by type, which is provided as a template argument.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, std::string, error2&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{</div>
<div class="line">        std::in_place_index&lt;1&gt;, <span class="stringliteral">&quot;oh no&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;std::string&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) == <span class="stringliteral">&quot;oh no&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">get&lt;std::string&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) = <span class="stringliteral">&quot;no problem&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get&lt;std::string&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) == <span class="stringliteral">&quot;no problem&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the accessed alternative, if applicable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classsumty_1_1bad__variant__access.html">bad_variant_access</a></td><td>Thrown if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative with the corresponding type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab12f5f7badd7d9d83a78e80ae285b45b" name="ab12f5f7badd7d9d83a78e80ae285b45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12f5f7badd7d9d83a78e80ae285b45b">&#9670;&#160;</a></span>get_if() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_POINTER</a> get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative pointer by index if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> holds it. </p>
<p>This functions tries to access an alternative by index. If the <a class="el" href="classsumty_1_1error__set.html">error_set</a> contains the alternative, this function returns a pointer to the alternative, if applicable. If the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative, this function returns null. In the case where the alternative is of type <code>void</code>, this function does nothing.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) != <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;0&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) == <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const pointer to the accessed alternative, if applicable, or null </dd></dl>

</div>
</div>
<a id="a2c6d985a6de9e81fdfcf01f52a995ee6" name="a2c6d985a6de9e81fdfcf01f52a995ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6d985a6de9e81fdfcf01f52a995ee6">&#9670;&#160;</a></span>get_if() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">CONST_POINTER</a> get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative pointer by type if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> holds it. </p>
<p>This functions tries to access an alternative by type. If the <a class="el" href="classsumty_1_1error__set.html">error_set</a> contains the alternative, this function returns a pointer to the alternative, if applicable. If the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative, this function returns null. In the case where the alternative is of type <code>void</code>, this function does nothing.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;error2&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) != <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;error1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) == <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const pointer to the accessed alternative, if applicable, or null </dd></dl>

</div>
</div>
<a id="a720782c76143d1be8ed926b6f730f49a" name="a720782c76143d1be8ed926b6f730f49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720782c76143d1be8ed926b6f730f49a">&#9670;&#160;</a></span>get_if() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">size_t</a> I, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">POINTER</a> get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative pointer by index if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> holds it. </p>
<p>This functions tries to access an alternative by index. If the <a class="el" href="classsumty_1_1error__set.html">error_set</a> contains the alternative, this function returns a pointer to the alternative, if applicable. If the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative, this function returns null. In the case where the alternative is of type <code>void</code>, this function does nothing.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) != <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;0&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) == <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the accessed alternative, if applicable, or null </dd></dl>

</div>
</div>
<a id="ae7e79ec0aa07fe1604e9899354eaa70b" name="ae7e79ec0aa07fe1604e9899354eaa70b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e79ec0aa07fe1604e9899354eaa70b">&#9670;&#160;</a></span>get_if() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">POINTER</a> get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an alternative pointer by type if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> holds it. </p>
<p>This functions tries to access an alternative by type. If the <a class="el" href="classsumty_1_1error__set.html">error_set</a> contains the alternative, this function returns a pointer to the alternative, if applicable. If the <a class="el" href="classsumty_1_1error__set.html">error_set</a> does not contain the alternative, this function returns null. In the case where the alternative is of type <code>void</code>, this function does nothing.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;error2&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) != <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">get_if&lt;error1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e</a>) == <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the alternative to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the accessed alternative, if applicable, or null </dd></dl>

</div>
</div>
<a id="a99f72be423e16e77bf438c0a2bc6a283" name="a99f72be423e16e77bf438c0a2bc6a283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f72be423e16e77bf438c0a2bc6a283">&#9670;&#160;</a></span>holds_alternative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classsumty_1_1result.html">typename</a> T , typename... U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">bool</a> holds_alternative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1result.html">const</a> <a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; U... &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an <a class="el" href="classsumty_1_1error__set.html">error_set</a> contains a particular alternative. </p>
<p>Given a type parameter, this function checks if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> currently holds an alternative that has the exact same type.</p>
<h2><a class="anchor" id="autotoc_md0"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e1</a>{std::in_place_index&lt;0&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">assert</a>(<a class="code hl_class" href="classsumty_1_1result.html">holds_alternative&lt;error1&gt;</a>(<a class="code hl_class" href="classsumty_1_1result.html">e1</a>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e2</a>{std::in_place_index&lt;2&gt;};</div>
<div class="line"> </div>
<div class="line">assert(holds_alternative&lt;error1&gt;(e2));</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classsumty_1_1error__set.html">error_set</a> holds an alternative of the given type. </dd></dl>

</div>
</div>
<a id="a5ec6d7752f8c65b3e377ed39065aeccc" name="a5ec6d7752f8c65b3e377ed39065aeccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec6d7752f8c65b3e377ed39065aeccc">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsumty_1_1result.html">constexpr</a> <a class="el" href="classsumty_1_1result.html">void</a> swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsumty_1_1error__set.html">error_set</a>&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two <a class="el" href="classsumty_1_1error__set.html">error_set</a> instances. </p>
<p>If the two <a class="el" href="classsumty_1_1error__set.html">error_set</a> instances contain the same alternative, the alternative values are swapped directly. Otherwise, the alternatives are swapped by moving out of the variants, destroying the old alternatives, and move constructed into the new alternatives.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e1</a>{std::in_place_index&lt;0&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classsumty_1_1result.html">error_set&lt;error1, error2, error3&gt;</a> <a class="code hl_class" href="classsumty_1_1result.html">e2</a>{std::in_place_index&lt;1&gt;};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="classsumty_1_1error__set.html#a86176821a53c55817f118bc82521733d">swap</a>(e1, e2);</div>
<div class="line"> </div>
<div class="line">assert(e1.index() == 1);</div>
<div class="line"> </div>
<div class="line">assert(e2.index() == 0);</div>
<div class="ttc" id="aclasssumty_1_1error__set_html_a86176821a53c55817f118bc82521733d"><div class="ttname"><a href="classsumty_1_1error__set.html#a86176821a53c55817f118bc82521733d">sumty::error_set::swap</a></div><div class="ttdeci">constexpr void swap(error_set &amp;other) CONDITIONALLY_NOEXCEPT</div><div class="ttdoc">Swaps two error_set instances.</div><div class="ttdef"><b>Definition</b> error_set.hpp:2041</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The "other" <a class="el" href="classsumty_1_1error__set.html">error_set</a> to swap with this <a class="el" href="classsumty_1_1error__set.html">error_set</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sumty/detail/<a class="el" href="fwd_8hpp_source.html">fwd.hpp</a></li>
<li>sumty/<a class="el" href="error__set_8hpp_source.html">error_set.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>sumty</b></li><li class="navelem"><a class="el" href="classsumty_1_1error__set.html">error_set</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
